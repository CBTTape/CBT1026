<html><head>
      <meta http-equiv="Content-Language" content="en-us">
      <meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
      <title>MVS Utility Programss - IBM and User Written</title>
      <meta name="GENERATOR" content="Microsoft FrontPage 4.0">
      <meta name="ProgId" content="FrontPage.Editor.Document">
      <style type="text/css">
         a.button {display: block; width: 310px; height: 30px; background-color: lawngreen; padding: 10x; text-align: center; border-radius: 5px; color: black; font-size: 24px; font-family: helvetica;  }
      </style>
   </head>
   <body bgcolor="#FFFFCC">
      <h1 align="center">MVS Utility Programs - IBM and User Written</h1>
      <h4 align="center">January, 2022</h4>
      <blockquote>
         <blockquote>
            <blockquote>
               <table width="90%" border="0">
                  <tbody><tr>
                     <td width="100%"><font size="4"><font color="#FF0000">January, 2022</font>
                        - Except for corrections to this page, which was originally
                        created in 2001 and was oriented to MVT and not MVS, I had never made a significant update to the
                        contents.&nbsp; So I thought that after two decades it was
                        time to examine it with the goal of adding information for other
                        utility type programs that might be useful to the Hercules/MVS user
                        community.&nbsp; In addition to the original ten IBM utility
                        programs, I have added a few more IBM utilities that I use
                        regularly, or have used at least occasionally, on my MVS system
                        running under Hercules.&nbsp; But there are also some utility type
                        programs that did not originate with IBM that I regularly use that
                        I have added.&nbsp; Some of the programs in that latter
                        group may be documented more extensively on other pages of my
                        site, but I think the concise format of this page will make them a useful addition
                        here.</font>
                     </td>
                  </tr>
               </tbody></table>
            </blockquote>
         </blockquote>
      </blockquote>
      <blockquote>
         <p style="border-style: solid; border-width: 1; padding: 1">There were
            numerous sources for the information provided on this page, and in some cases
            what appears here for any particular utility program may be an amalgamation from
            several sources.&nbsp; In at least a few cases, the only source of information
            that I could utilize was the source for the program.&nbsp; With very few
            exceptions, the examples of jobstreams I have provided have been successfully
            executed on my MVS 3.8j system running under Hercules.<br>
            <br>
            It is possible to locate PDF copies of some IBM manuals
            on the internet, particularly at <a href="https://archive.org/">Internet
            Archive</a> and <a href="http://bitsavers.org/">Bitsavers</a>.&nbsp; It is
            also possible to occasionally find used copies of recommended books that cover
            JCL and utility programs at <a href="https://www.abebooks.com/">Advanced Book
            Exchange</a> and Amazon, which since 2008 are really the same company.&nbsp;&nbsp;<br>
            <br>
            In particular, the textbooks I recommend are:&nbsp; <b>System/370 Job Control Language</b>
            by Gary DeWard Brown,
            and <b>OS JCL and UTILITIES</b> by Michael Trobetta
            and Sue Carolyn Finkelstein.
         </p>
      </blockquote>
      <p>The content of this page is available as a printable document at <a href="http://www.jaymoseley.com/hercules/os_utilities/mvs_utilities.pdf" target="_blank">mvs_utilities.pdf</a>.
      </p>
      <table width="90%" cellspacing="0" cellpadding="0" border="1">
        <tbody><tr>
          <th width="162" valign="top">
            <p align="center">Program</p></th>
          <th width="203" valign="top">
            <p align="center">Source</p></th>
          <th width="1499">&nbsp; Function</th>
        </tr>
        <tr>
          <td width="162" valign="top"><a href="#AMASPZAPi">AMASPZAP</a></td>
          <td width="203" valign="top">IBM</td>
          <td width="1499">Inspect and/or modify a load module or data record stored on
         disk.</td>
        </tr>
        <tr>
          <td width="162" valign="top"><a href="#AMBLISTi">AMBLIST</a></td>
          <td width="203" valign="top">IBM</td>
          <td width="1499">Produce a formatted listing of an object or load module,
            produce
         a map and cross-reference listing of a nucleus, produce a list of IDRDATA from
         a CSECT, or produce a map of all modules in the reenterable load module area
         (the Link Pack area).</td>
        </tr>
        <tr>
          <td width="162" valign="top"><a href="#CMPRSEQi">CMPRSEQ</a></td>
          <td width="203" valign="top">IBM</td>
          <td width="1499">Compare two sequential datasets or members of two partitioned datasets at the
         logical record level.</td>
        </tr>
        <tr>
          <td width="162" valign="top"><a href="#COPYMODSi">COPYMODS</a></td>
          <td width="203" valign="top">CBT File #229</td>
          <td width="1499">Copy all files of an input tape onto 1 to 16 output
            tapes, strip labels from tape files, add new labels to tape files,
            correct label records, initialize tape volumes.</td>
        </tr>
        <tr>
          <td width="162" valign="top"><a href="#DSSDUMPi">DSSDUMP</a></td>
          <td width="203" valign="top">CBT File #860</td>
          <td width="1499">Create a backup sequential dataset, ADRDSSU format, containing the contents of one
         or more DASD datasets.</td>
        </tr>
        <tr>
          <td width="162" valign="top"><a href="#DSSRESTi">DSSREST</a></td>
          <td width="203" valign="top">CBT File #860</td>
          <td width="1499">Restore one or more datasets from a backup set created by
            ADRDSSU
         or DSSDUMP.</td>
        </tr>
        <tr>
          <td width="162" valign="top"><a href="#FIXDSCBi">FIXDSCB</a></td>
          <td width="203" valign="top">CBT File #566</td>
          <td width="1499">Modify and repair of dataset control blocks (DSCBs).</td>
        </tr>
        <tr>
          <td width="162" valign="top"><a href="#ICKDSFi">ICKDSF</a></td>
          <td width="203" valign="top">IBM</td>
          <td width="1499">Prepare an
         offline DASD
         volume so that it can be used in an MVS system.</td>
        </tr>
        <tr>
          <td width="162" valign="top"><a href="#IEBCOMPRi">IEBCOMPR</a></td>
          <td width="203" valign="top">IBM</td>
          <td width="1499">Compare two sequential datasets or two partitioned datasets at the
         logical record level to verify a backup copy.</td>
        </tr>
        <tr>
          <td width="162" valign="top"><a href="#IEBCOPYi">IEBCOPY</a></td>
          <td width="203" valign="top">IBM</td>
          <td width="1499">Copy one or more partitioned datasets or to merge
         partitioned datasets.&nbsp;</td>
        </tr>
        <tr>
          <td width="162" valign="top"><a href="#IEBGENERi">IEBGENER</a></td>
          <td width="203" valign="top">IBM</td>
          <td width="1499">Copy a sequential dataset, or a member of a partitioned
         dataset, to a sequential dataset or a member of a partitioned dataset.</td>
        </tr>
        <tr>
          <td width="162" valign="top"><a href="#IEBISAMi">IEBISAM</a></td>
          <td width="203" valign="top">IBM</td>
          <td width="1499">
               <p align="LEFT"> Copy an indexed sequential (ISAM) dataset from one DASD
                  volume to another,&nbsp;or into a sequential dataset on DASD
               or tape; create an ISAM dataset from an unloaded dataset, or
               print an ISAM dataset.</p></td>
        </tr>
        <tr>
          <td width="162" valign="top"><a href="#IEBPTPCHi">IEBPTPCH</a></td>
          <td width="203" valign="top">IBM</td>
          <td width="1499">
               <p align="LEFT">Print or punch:&nbsp; all/selected
               members/selected records from a sequential or partitioned dataset,
               or the directory of a partitioned dataset.</p></td>
        </tr>
        <tr>
          <td width="162" valign="top"><a href="#IEBUPDTEi">IEBUPDTE</a></td>
          <td width="203" valign="top">IBM</td>
          <td width="1499">Incorporate source language modifications into
            sequential or partitioned datasets.</td>
        </tr>
        <tr>
          <td width="162" valign="top"><a href="#IEHDASDRi">IEHDASDR</a></td>
          <td width="203" valign="top">IBM</td>
          <td width="1499">Prepare DASD volumes for use, dump/restore the entire contents or portions of a
            DASD volume to a volume or volumes of the same DASD type,
         or to a tape volume or volumes.</td>
        </tr>
        <tr>
          <td width="162" valign="top"><a href="#IEHINITTi">IEHINITT</a></td>
          <td width="203" valign="top">IBM</td>
          <td width="1499">Prepare tape volumes for use by writing IBM 
volume label sets in EBCDIC onto any number of magnetic tapes mounted on
 one or more tape
            units.</td>
        </tr>
        <tr>
          <td width="162" valign="top"><a href="#IEHLISTi">IEHLIST</a></td>
          <td width="203" valign="top">IBM</td>
          <td width="1499">Print entries in a DASD Volume Table Of Contents or entries in the directory of one or more partitioned
            datasets.</td>
        </tr>
        <tr>
          <td width="162" valign="top"><a href="#IEHMAPi">IEHMAP</a></td>
          <td width="203" valign="top">CBT V129 File#83</td>
          <td width="1499">Print a formatted listing of a VTOC or a dataset.</td>
        </tr>
        <tr>
          <td width="162" valign="top"><a href="#IEHMOVEi">IEHMOVE</a></td>
          <td width="203" valign="top">IBM</td>
          <td width="1499">Move or copy one or several datasets from one DASD
         volume to another, or to a tape.</td>
        </tr>
        <tr>
          <td width="162" valign="top"><a href="#IEHPROGMi">IEHPROGM</a></td>
          <td width="203" valign="top">IBM</td>
          <td width="1499">Modify system control data and to maintain datasets at an organizational level.</td>
        </tr>
        <tr>
          <td width="162" valign="top"><a href="#LISTPDSi">LISTPDS</a></td>
          <td width="203" valign="top">CBT File #316</td>
          <td width="1499">Prints formatted listings of a
         PDS directory, the contents of processed members or sequential 
files, as well as (optionally) punching processed members and/or 
sequential datasets.</td>
        </tr>
        <tr>
          <td width="162" valign="top"><a href="#MINIUNZi">MINIUNZ</a></td>
          <td width="203" valign="top">CBT File #135</td>
          <td width="1499">Uncompress the contents of datasets created by compression
      utilities commonly used on PCs and by the companion program MINIZIP.</td>
        </tr>
        <tr>
          <td width="162" valign="top"><a href="#MINIZIPi">MINIZIP</a></td>
          <td width="203" valign="top">CBT File #135</td>
          <td width="1499">Compress the contents of:&nbsp; 1) one or more sequential
      datasets or members of partitioned datasets; or 2) all the members of a
      one or more partitioned datasets, to create a smaller, portable copy of
      the original data.</td>
        </tr>
        <tr>
          <td width="162" valign="top"><a href="#OFFLOADi">OFFLOAD</a></td>
          <td width="203" valign="top">CBT File #093</td>
          <td width="1499">Sequentialize a partitioned dataset.</td>
        </tr>
        <tr>
          <td width="162" valign="top"><a href="#PDSLOADi">PDSLOAD</a></td>
          <td width="203" valign="top">CBT File #093</td>
          <td width="1499">Recreate a partitioned dataset from a sequential
            dataset that contains control statements interspersed with data
            records.</td>
        </tr>
        <tr>
          <td width="162" valign="top"><a href="#PDSMATCHi">PDSMATCH</a></td>
          <td width="203" valign="top">CBT File #357</td>
          <td width="1499">Compare two partitioned datasets.</td>
        </tr>
        <tr>
          <td width="162" valign="top"><a href="#PDSPRINTi">PDSPRINT</a></td>
          <td width="203" valign="top">CBT File #316</td>
          <td width="1499">Print or punch members from a partitioned dataset.</td>
        </tr>
        <tr>
          <td width="162" valign="top"><a href="#PDSPROGMi">PDSPROGM</a></td>
          <td width="203" valign="top">CBT File #316</td>
          <td width="1499">Perform maintenance on partitioned datasets.</td>
        </tr>
        <tr>
          <td width="162" valign="top"><a href="#PDSSCANi">PDSSCAN</a></td>
          <td width="203" valign="top">CBT File #684</td>
          <td width="1499">Scan all members of one or more partitioned datasets, searching for
         specified strings.</td>
        </tr>
        <tr>
          <td width="162" valign="top"><a href="#PDSUPDTEi">PDSUPDTE</a></td>
          <td width="203" valign="top">CBT OFL FIle #065</td>
          <td width="1499">Scan all members of one or more partitioned datasets, searching for
         specified strings and replacing those found with replacement strings.</td>
        </tr>
        <tr>
          <td width="162" valign="top"><a href="#PDSURi">PDSUR</a></td>
          <td width="203" valign="top">CBT File #949</td>
          <td width="1499">Copy partitioned datasets from DASD to tape (unload) and from tape to
         DASD (reload) in IEHMOVE format.</td>
        </tr>
        <tr>
          <td width="162" valign="top"><a href="#RECV370i">RECV370</a></td>
          <td width="203" valign="top">CBT File #571</td>
          <td width="1499">Process XMIT files produced by either the TSO/E TRANSMIT command
         processor, the XMIT370 batch program, or a similar facility.</td>
        </tr>
        <tr>
          <td width="162" valign="top"><a href="#RESETDSi">RESETDS</a></td>
          <td width="203" valign="top">NaSPA 1986</td>
          <td width="1499">Reset to empty status partitioned or sequential datasets in
         preparation for a reload.</td>
        </tr>
        <tr>
          <td width="162" valign="top"><a href="#REVLMODi">REVLMOD</a></td>
          <td width="203" valign="top">CBT File #134</td>
          <td width="1499">Reload load modules that have been offloaded with REVIEW's OFFLOAD
         command.</td>
        </tr>
        <tr>
          <td width="162" valign="top"><a href="#SORTi">SORT</a></td>
          <td width="203" valign="top">IBM</td>
          <td width="1499">Sort data records from one or more sequential datasets.</td>
        </tr>
        <tr>
          <td width="162" valign="top"><a href="#SUPERLSTi">SUPERLST</a></td>
          <td width="203" valign="top">CBT File #134</td>
          <td width="1499">Print DASD VTOC listing, with optional Partitioned dataset directory
         information and volume allocation map.</td>
        </tr>
        <tr>
          <td width="162" valign="top"><a href="#SYSREPROi">SYSREPRO</a></td>
          <td width="203" valign="top">CBT File #316</td>
          <td width="1499">Copy data records from a sequential dataset or member of a
         partitioned dataset to another sequential dataset or member.&nbsp;</td>
        </tr>
        <tr>
          <td width="162" valign="top"><a href="#TAPEMAPi">TAPEMAP</a></td>
          <td width="203" valign="top">CBT File #299</td>
          <td width="1499">Read a tape volume and report everything it contains, including
         detailed information about file contents when the creation program is
         recognized.</td>
        </tr>
        <tr>
          <td width="162" valign="top"><a href="#TAPESCANi">TAPESCAN</a></td>
          <td width="203" valign="top">CBT File #102</td>
          <td width="1499">Read a tape volume and report an overview of the datasets on a tape,
         copy files and recover data past the first end of volume indicator.</td>
        </tr>
        <tr>
          <td width="162" valign="top"><a href="#UNUPDTEi">UNUPDTE</a></td>
          <td width="203" valign="top">CBT File #093</td>
          <td width="1499">Sequentialize a partitioned dataset.</td>
        </tr>
        <tr>
          <td width="162" valign="top"><a href="#UPDTEi">UPDTE</a></td>
          <td width="203" valign="top">CBT File #093</td>
          <td width="1499">Recreate a partitioned dataset from a sequential dataset that
         contains ADD control statements interspersed with data records.&nbsp;</td>
        </tr>
        <tr>
          <td width="162" valign="top"><a href="#VTOCLISTi">VTOCLIST</a></td>
          <td width="203" valign="top">CBT OFL File #343</td>
          <td width="1499">Print formatted VTOC listing.</td>
        </tr>
        <tr>
          <td width="162" valign="top"><a href="#XMIT370i">XMIT370</a></td>
          <td width="203" valign="top">CBT File #571</td>
          <td width="1499">Read partitioned datasets to produce XMIT files equivalent to the
            TSO/E
         TRANSMIT command processor or a similar facility.</td>
        </tr>
        <tr>
          <td width="162" valign="top"><a href="#ZAPDSCBi">ZAPDSCB</a></td>
          <td width="203" valign="top">CBT File #163</td>
          <td width="1499">Update DSCBs for specified datasets with values supplied on DD
         statements.</td>
        </tr>
        <tr>
          <td width="162" valign="top"><a href="#ZTDUMPTPi">ZTDUMPTP</a></td>
          <td width="203" valign="top">CBT File #316</td>
          <td width="1499">Print data records from datasets on tape.</td>
        </tr>
        <tr>
          <td width="162" valign="top"><a href="#ZZRELINKi">ZZRELINK</a></td>
          <td width="203" valign="top">CBT File #860</td>
          <td width="1499">Re-link-edit one or more existing load modules.</td>
        </tr>
      </tbody></table>
      <hr size="8" noshade="noshade">
      <h1 align="center">Index of Programs With Control Statements and Example
      JCL
      </h1>
      <p>&nbsp;
      </p>
      <table width="90%" height="1504" cellspacing="1" cellpadding="2" border="1">
         <tbody><tr>
            <th width="17%" valign="top" height="22">
               <p align="center"> Program Name
            </p></th>
            <th width="20%" valign="top" height="22">
               <p align="center">Control Statements
            </p></th>
            <th width="103%" valign="top" height="22">
               <p align="center">Examples (JCL)
            </p></th>
         </tr>
         <tr>
            <td width="17%" valign="top" height="116">
               <h3><a href="#AMASPZAP" name="AMASPZAPi">AMASPZAP</a></h3>
            </td>
            <td width="20%" valign="top" height="116">
               <a href="#AMASPZAPabsdump">
               ABSDUMP | ABSDUMPT</a><br>
               <a href="#AMASPZAPdump">
               DUMP | DUMPT</a><br>
               <a href="#AMASPZAPidrdata">
               IDRDATA</a><br>
               <a href="#AMASPZAPrep">
               REP</a><br>     
               <a href="#AMASPZAPver">VER | VERIFY</a><br>
               <a href="#AMASPZAPsetssi">
               SETSSI</a>
            </td>
            <td width="103%" valign="top" height="116">1) <a href="#AMASPZAPj01">Dump
               the CSECT from a load module<br>
               </a>2) <a href="#AMASPZAPj02">Verify/Replace instruction in a load module<br>
               </a>3) <a href="#AMASPZAPj03">Dump a record from a file<br>
               </a>4) <a href="#AMASPZAPj04">Inspect/Modify a data record</a><br>
            </td>
         </tr>
         <tr>
            <td width="17%" valign="top" height="22">
               <h3><a href="#AMBLIST" name="AMBLISTi">AMBLIST</a></h3>
            </td>
            <td width="20%" valign="top" height="22">
               <a href="#AMBLISTlistidr">LISTIDR</a><a href="#AMBLISTlistload"><br>
               LISTLOAD<br>
               </a><a href="#AMBLISTlistlpa">LISTLPA</a><br>
               <a href="#AMBLISTlistobj">LISTOBJ</a>
            </td>
            <td width="103%" valign="top" height="22">1) <a href="#AMBLISTj01">List Load
               Module</a><br>
               2) <a href="#AMBLISTj02">List Object Module</a><br>
               3) <a href="#AMBLISTj03">List Identification Records from one or more
               CSECTs</a><br>
               4) <a href="#AMBLISTj04">List Link Pack area</a>
            </td>
         </tr>
         <tr>
            <td width="17%" valign="top" height="22">
               <h3><a href="#CMPRSEQ" name="CMPRSEQi">CMPRSEQ</a></h3>
            </td>
            <td width="20%" valign="top" height="22"></td>
            <td width="103%" valign="top" height="22">1) <a href="#CMPRSEQj01">Compare
               members of
               two partitioned datasets</a>&nbsp;
            </td>
         </tr>
         <tr>
            <td width="17%" valign="top" height="22">
               <h3><a href="#COPYMODS" name="COPYMODSi">COPYMODS</a></h3>
            </td>
            <td width="20%" valign="top" height="22"><a href="#COPYMODSblkcnt">BLKCNT |
               NOBLKCNT</a><br>
               <a href="#COPYMODSbytes">BYTES</a><br>
               <a href="#COPYMODSchgvol">CHGVOL | NOCHGVOL</a><br>
               <a href="#COPYMODScopyltm">COPYLTM | SKIPLTM</a><br>
               <a href="#COPYMODScorrblks">CORRBLKS</a><br>
               <a href="#COPYMODScu">CUMTOT | CUMSEP</a><br>
               <a href="#COPYMODSeof1">EOF1 | NOEOF1</a><br>
               <a href="#COPYMODSeof2">EOF2 | NOEOF2</a><br>
               <a href="#COPYMODSeofs">EOFS | NOEOFS</a><br>
               <a href="#COPYMODSeov1">EOV1 | NOEOV1</a><br>
               <a href="#COPYMODSeov2">EOV2 | NOEOV2</a><br>
               <a href="#COPYMODSeov2eof">EOV2EOF | NOEOVCHG</a><br>
               <a href="#COPYMODSeovs">EOVS | NOEOVS</a><br>
               <a href="#COPYMODSexnull">EXNULL | NOEXNULL<br>
               </a><a href="#COPYVOLSfootage">FOOTAGE</a><br>
               <a href="#COPYMODSfilelimit">FILELIMIT</a><br>
               <a href="#COPYMODShdr1">HDR1 | NOHDR1</a><br>
               <a href="#COPYMODShdr2">HDR2 | NOHDR2<br>
               </a><a href="#COPYMODShexprt">HEXPRT<br>
               </a><a href="#COPYMODSidrcoff">IDRCOFF<br>
               </a><a href="#COPYMODSkeepvol">KEEPVOL</a><br>
               <a href="#COPYMODSlabaddin">LABADDIN</a><br>
               <a href="#COPYMODSlabelimit">LABELIMIT</a><br>
               <a href="#COPYMODSlabldump">LABLDUMP | NOLABELD</a><br>
               <a href="#COPYMODSlblfix">LBLFIX | NOLBLFIX</a><br>
               <a href="#COPYMODSlblinfo">LBLINFO | NOLABL<br>
               </a><a href="#COPYMODSminmax">MINMAX</a><br>
               <a href="#COPYMODSoutvolall">OUTVOLALL</a><br>
               <a href="#COPYMODSpraddlbl">PRADDLBL | NOPRADDL<br>
               </a><a href="#COPYMODSprintrcds">PRINTRCDS</a><br>
               <a href="#COPYMODSread">READ | WRITE<br>
               </a><a href="#COPYMODSrecsize">RECSIZE<br>
               </a><a href="#COPYMODSsecoff">SECOFF<br>
               </a><a href="#COPYMODSshoovl">SHOOVL</a><a href="#COPYMODSsecoff"><br>
               </a><a href="#COPYMODSstrip">STRIP</a><br>
               <a href="#COPYMODSsysin">SYSIN | NOSYSIN</a><br>
               <a href="#COPYMODStapeowner">TAPEOWNER</a><br>
               <a href="#COPYMODSvollbl">VOLLBL | NOVOLLBL</a>
            </td>
            <td width="103%" valign="top" height="22">1)&nbsp;<a href="#COPYMODSj01">Copy
               tape to 3 output tapes, SL output, change VOL1s</a><br>
               2)&nbsp;<a href="#COPYMODSj02">Simulate copy, print input tape information</a>
            </td>
         </tr>
         <tr>
            <td width="17%" valign="top" height="22">
               <h3><a href="#DSSDUMP" name="DSSDUMPi">DSSDUMP</a></h3>
            </td>
            <td width="20%" valign="top" height="22"><a href="#DSSDUMPinclude">
               DUMP<br>
               </a><a href="#DSSDUMPexclude">EXCLUDE<br>
               </a><a href="#DSSDUMPinclude">INCLUDE</a><a href="#DSSDUMPoptions"><br>
               OPTIONS</a><br>
               <a href="#DSSDUMPprefix">PREFIX</a><br>
               <a href="#DSSDUMPrename">RENAME<br>
               </a><a href="#DSSDUMPstrip">STRIP</a>
            </td>
            <td width="103%" valign="top" height="22">1) <a href="#DSSDUMPj01">Run a
               test (simulation) dump</a><br>
               2) <a href="#DSSDUMPj02">Dump a dataset, substituting new HLQ on backup
               set</a><br>
               3) <a href="#DSSDUMPj03">Dump two groups of datasets contained on one
               volume</a><br>
            </td>
         </tr>
         <tr>
            <td width="17%" valign="top" height="22">
               <h3><a href="#DSSREST" name="DSSRESTi">DSSREST</a></h3>
            </td>
            <td width="20%" valign="top" height="22"></td>
            <td width="103%" valign="top" height="22">1) <a href="#DSSRESTj01">Read
               backup set, generate report and restore JCL</a><br>
               2) <a href="#DSSRESTj02">Restore a single dataset from backup set</a><br>
               3) <a href="#DSSRESTj03">Restore more than one, but not all, datasets from
               backup set</a>
            </td>
         </tr>
         <tr>
            <td width="17%" valign="top" height="22">
               <h3><a href="#FIXDSCB" name="FIXDSCBi">FIXDSCB</a></h3>
            </td>
            <td width="20%" valign="top" height="22"><a href="#FIXDSCBexpire">EXPIRE<br>
               </a><a href="#FIXDSCBextend">EXTEND</a><br>
               <a href="#FIXDSCBname">NAME<br>
               </a>
               &nbsp; <a href="#FIXDSCBblksize">BLKSIZE<br>
               </a>
               &nbsp; <a href="#FIXDSCBdsorg">DSORG<br>
               </a>
               &nbsp; <a href="#FIXDSCBkeyl">KEYL</a><a href="#FIXDSCBblksize"><br>
               </a>
               &nbsp; <a href="#FIXDSCBlrecl">LRECL<br>
               </a>
               &nbsp; <a href="#FIXDSCBoptcode">OPTCODE<br>
               </a>
               &nbsp; <a href="#FIXDSCBrecfm">RECFM</a><br>
               &nbsp; <a href="#FIXDSCBrkp">RKP</a><br>
               <a href="#FIXDSCBprotect">PROTECT</a> <a href="#FIXDSCBoptcode"><br>
               </a><a href="#FIXDSCBrename">RENAME</a> <a href="#FIXDSCBoptcode"><br>
               </a><a href="#FIXDSCBrenew">RENEW</a> <a href="#FIXDSCBoptcode"><br>
               </a><a href="#FIXDSCBscratch">SCRATCH</a> <a href="#FIXDSCBoptcode"><br>
               </a><a href="#FIXDSCBsetnopwr">
               SETNOPWR</a> <a href="#FIXDSCBoptcode"><br>
               </a><a href="#FIXDSCBunlock">UNLOCK</a> <a href="#FIXDSCBoptcode"><br>
               </a><a href="#FIXDSCBzeroexpd">ZEROEXPD</a>
            </td>
            <td width="103%" valign="top" height="22">1) <a href="#FIXDSCBj01">Extend
               expiration date for dataset</a><br>
               2) <a href="#FIXDSCBj02">Modify RECFM, LRECL, BLKSIZE</a>
            </td>
         </tr>
         <tr>
            <td width="17%" valign="top" height="22">
               <h3><a href="#ICKDSF" name="ICKDSFi">ICKDSF</a></h3>
            </td>
            <td width="20%" valign="top" height="22"><a href="#ICKDSFinit">INIT</a></td>
            <td width="103%" valign="top" height="22">1) <a href="#ICKDSFj01">Initialize
               2314, 3330, 3340, 3350 DASD</a>&nbsp;<br>
               2)&nbsp;<a href="#ICKDSFj02">Initialize 3375, 3380, 3390 DASD</a>
            </td>
         </tr>
         <tr>
            <td width="17%" valign="top" height="22">
               <h3><a href="#IEBCOMPR" name="IEBCOMPRi">IEBCOMPR</a></h3>
            </td>
            <td width="20%" valign="top" height="22"><a href="#IEBCOMPRtypeorg">COMPARE<br>
               </a>
               <a href="#IEBCOMPRexits">EXITS</a><br>
               <a href="#IEBCOMPRlabels">LABELS</a>
            </td>
            <td width="103%" valign="top" height="22">1) <a href="#IEBCOMPRj01">Compare
               two sequential datasets</a><br>
               2) <a href="#IEBCOMPRj02">Compare two partitioned datasets</a>
            </td>
         </tr>
         <tr>
            <td width="17%" valign="top" height="22">
               <h3><a href="#IEBCOPY" name="IEBCOPYi">IEBCOPY</a></h3>
            </td>
            <td width="20%" valign="top" height="22"><a href="#IEBCOPYcopy">COPY<br>
               </a><a href="#IEBCOPYexclude">EXCLUDE</a><br>
               <a href="#IEBCOPYselect">SELECT</a>
            </td>
            <td width="103%" valign="top" height="22">1) <a href="#IEBCOPYj01">Copy
               partitioned dataset from one DASD to another DASD, including all members</a><br>
               2) <a href="#IEBCOPYj02">Copy partitioned dataset from one DASD to another
               DASD, selecting specific members</a><br>
               3) <a href="#IEBCOPYj03">Copy members from two partitioned datasets,
               creating a new partitioned dataset, replacing any members with the same
               name from dataset 2</a><br>
               4) <a href="#IEBCOPYj04">Compress partitioned dataset</a><br>
               5) <a href="#IEBCOPYj05">Unload a partitioned dataset to tape</a><br>
               6) <a href="#IEBCOPYj06">Reload some members of an unloaded partitioned
               dataset</a>
            </td>
         </tr>
         <tr>
            <td width="17%" valign="top" height="22">
               <h3><a href="#IEBGENER" name="IEBGENERi">IEBGENER</a></h3>
            </td>
            <td width="20%" valign="top" height="22"><a href="#IEBGENERexits">EXITS</a><a href="#IEBGENERgenerate"><br>
               GENERATE</a><br>
               <a href="#IEBGENERlabels">LABELS</a><br>
               <a href="#IEBGENERmember">MEMBER</a><br>
               <a href="#IEBGENERrecord">RECORD</a>
            </td>
            <td width="103%" valign="top" height="22">1) <a href="#IEBGENERj01"> Copying tape to
               tape</a>&nbsp;<br>
               2)&nbsp;<a href="#IEBGENERj02">Tape to print</a><br>
               3)&nbsp;<a href="#IEBGENERj03">Card to tape</a>
            </td>
         </tr>
         <tr>
            <td width="17%" valign="top" height="22">
               <h3><a href="#IEBISAM" name="IEBISAMi">IEBISAM</a></h3>
            </td>
            <td width="20%" valign="top" height="22"><a href="#IEBISAMcopy">COPY</a><br>
               <a href="#IEBISAMexit">EXIT</a><br>
               <a href="#IEBISAMload">LOAD</a><br>
               <a href="#IEBISAMprintl">PRINTL<br>
               </a><a href="#IEBISAMunload">UNLOAD</a>
            </td>
            <td width="103%" valign="top" height="22">1) <a href="#IEBISAMj01">Copy ISAM
               dataset blocking data records</a><br>
               2) <a href="#IEBISAMj02">Copy ISAM dataset to portable copy (unloaded)</a><br>
               3) <a href="#IEBISAMj03">Reload ISAM dataset from unloaded copy</a><br>
               4) <a href="#IEBISAMj04">Print ISAM data records</a>
            </td>
         </tr>
         <tr>
            <td width="17%" valign="top" height="22">
               <h3><a href="#IEBPTPCH" name="IEBPTPCHi">IEBPTPCH</a></h3>
            </td>
            <td width="20%" valign="top" height="22"><a href="#IEBPTPCHexits">EXITS<br>
               </a><a href="#IEBPTPCHlabels">LABELS</a><a href="#IEBPTPCHexits"><br>
               </a><a href="#IEBPTPCHmember">MEMBER</a><a href="#IEBPTPCHprint"><br>
               PRINT</a><br>
               <a href="#IEBPTPCHpunch">PUNCH<br>
               </a><a href="#IEBPTPCHrecord">RECORD</a>
               <a href="#IEBPTPCHpunch"><br>
               </a><a href="#IEBPTPCHtitle">TITLE</a>
            </td>
            <td width="103%" valign="top" height="22">1) <a href="#IEBPTPCHj01">Print
               sequential dataset with conversion to hex</a><br>
               2) <a href="#IEBPTPCHj02">Print partitioned dataset, 10 records from each
               member</a><br>
               3) <a href="#IEBPTPCHj03">Copy all members from PDS onto single file on
               tape</a><br>
               4) <a href="#IEBPTPCHj04">Print two members of PDS</a><br>
               5) <a href="#IEBPTPCHj05">Resequence card deck</a><br>
            </td>
         </tr>
         <tr>
            <td width="17%" valign="top" height="22">
               <h3><a href="#IEBUPDTE" name="IEBUPDTEi">IEBUPDTE</a></h3>
            </td>
            <td width="20%" valign="top" height="22"><a href="#IEBUPDTEadd">ADD<br>
               </a><a href="#IEBUPDTEalias">ALIAS</a><br>
               <a href="#IEBUPDTEchange">CHANGE<br>
               </a><a href="#IEBUPDTEdelete">DELETE<br>
               </a><a href="#IEBUPDTEendup">ENDUP<br>
               </a><a href="#IEBUPDTEnumber">NUMBER</a><br>
               <a href="#IEBUPDTErepl">REPL</a><br>
               <a href="#IEBUPDTErepro">REPRO</a>
            </td>
            <td width="103%" valign="top" height="22">1)&nbsp;<a href="#IEBUPDTEj01">Add
               two members to a partitioned dataset</a><br>
               2)&nbsp;<a href="#IEBUPDTEj02">Change member in partitioned dataset,
               update in place</a><br>
               3)&nbsp;<a href="#IEBUPDTEj03">Add records to member in partitioned
               dataset</a><br>
               4) <a href="#IEBUPDTEj04">Delete records from a member in a partitioned
               dataset</a>&nbsp;<br>
               5)&nbsp;<a href="#IEBUPDTEj05">Create a partitioned dataset, input data
               contained solely in control dataset</a><br>
               6) <a href="#IEBUPDTEj06">Create a partitioned dataset, input data copied
               from existing dataset</a>&nbsp;
            </td>
         </tr>
         <tr>
            <td width="17%" valign="top" height="22">
               <h3><a href="#IEHDASDR" name="IEHDASDRi">IEHDASDR</a></h3>
            </td>
            <td width="20%" valign="top" height="22"><a href="#IEHDASDRanalyze">ANALYZE</a><br>
               <a href="#IEHDASDRdump">DUMP<br>
               </a><a href="#IEHDASDRlabel">LABEL</a><br>
               <a href="#IEHDASDRrestore">RESTORE</a>
            </td>
            <td width="103%" valign="top" height="22">1) <a href="#IEHDASDRj01">Initialize
               2314, 3330 (1 and 2), 3340, 3350 DASD volumes</a><br>
               2) <a href="#IEHDASDRj02">Dump DASD volume to tape</a><br>
               3) <a href="#IEHDASDRj03">Restore DASD volume from backup</a><br>
               4) <a href="#IEHDASDRj04">Alter Volume Serial on offline 2314</a>&nbsp;
            </td>
         </tr>
         <tr>
            <td width="17%" valign="top" height="22">
               <h3><a href="#IEHINITT" name="IEHINITTi">IEHINITT</a></h3>
            </td>
            <td width="20%" valign="top" height="22"><a href="#IEHINITTinitt">INITT</a></td>
            <td width="103%" valign="top" height="22">1) <a href="#IEHINITTj01">Initialize
               3 tapes</a>
            </td>
         </tr>
         <tr>
            <td width="17%" valign="top" height="22">
               <h3><a href="#IEHLIST" name="IEHLISTi">IEHLIST</a></h3>
            </td>
            <td width="20%" valign="top" height="22"><a href="#IEHLISTlistctlg">LISTCTLG</a><br>
               <a href="#IEHLISTlistpds">LISTPDS</a>
               <a href="#IEHLISTlistctlg"><br>
               </a><a href="#IEHLISTlistvtoc">LISTVTOC</a>
            </td>
            <td width="103%" valign="top" height="22">1) <a href="#IEHLISTj01">List VTOC</a><br>
               2) <a href="#IEHLISTj02">List PDS</a>&nbsp;&nbsp;
            </td>
         </tr>
         <tr>
            <td width="17%" valign="top" height="22">
               <h3><a href="#IEHMAP" name="IEHMAPi">IEHMAP</a></h3>
            </td>
            <td width="20%" valign="top" height="22"><a href="#IEHMAPattrib">ATTRIB<br>
               </a><a href="#IEHMAPavail">AVAIL<br>
               </a><a href="#IEHMAPcchhr">CCHHR<br>
               </a><a href="#IEHMAPdir">DIR<br>
               </a><a href="#IEHMAPdsname">DSNAME</a><a href="#IEHMAPdir"><br>
               </a><a href="#IEHMAPdump">DUMP</a><br>
               <a href="#IEHMAPdump456">DUMP456<br>
               </a><a href="#IEHMAPfixup">FIXUP</a>
               <a href="#IEHMAPdump456"><br>
               </a><a href="#IEHMAPfree">FREE<br>
               </a><a href="#IEHMAPmap">MAP<br>
               </a><a href="#IEHMAPmissing">MISSING</a><a href="#IEHMAPname"><br>
               NAME<br>
               </a><a href="#IEHMAPoverlap">OVERLAP<br>
               </a><a href="#IEHMAPpds">PDS<br>
               </a><a href="#IEHMAPsort">SORT</a><br>
               <a href="#IEHMAPtracks">TRACKS</a><br>
               <a href="#IEHMAPttr">TTR</a><br>
               <a href="#IEHMAPverify">VERIFY</a>
            </td>
            <td width="103%" valign="top" height="22">
               1)&nbsp;<a href="#IEHMAPj01">List
               all datasets on volume</a>
               <p>All other functions are documented in the job above.</p>
            </td>
         </tr>
         <tr>
            <td width="17%" valign="top" height="22">
               <h3><a href="#IEHMOVE" name="IEHMOVEi">IEHMOVE</a></h3>
            </td>
            <td width="20%" valign="top" height="22"><a href="#IEHMOVEcopydsgroup">COPY DSGROUP</a><a href="#IEHMOVEmovedsname"><br>
               </a><a href="#IEHMOVEcopydsname">COPY DSNAME</a><a href="#IEHMOVEmovedsname"><br>
               </a><a href="#IEHMOVEcopypds">COPY PDS</a><a href="#IEHMOVEmovedsname"><br>
               </a><a href="#IEHMOVEcopyvolume">COPY VOLUME<br>
               </a><a href="#IEHMOVEmovedsgroup">MOVE DSGROUP</a><a href="#IEHMOVEmovedsname"><br>
               MOVE
               DSNAME</a><br>
               <a href="#IEHMOVEmovepds">MOVE PDS</a><br>
               <a href="#IEHMOVEmovevolume">MOVE VOLUME</a>
            </td>
            <td width="103%" valign="top" height="22">1) <a href="#IEHMOVEj01">Copy
               partitioned dataset from one DASD to another DASD, recataloging</a><br>
               2) <a href="#IEHMOVEj02">Copy all datasets from one DASD volume to another
               DASD volume</a><br>
               3) <a href="#IEHMOVEj03">Move all datasets matching HLQ from one DASD to
               another DASD, recataloging</a><br>
               4) <a href="#IEHMOVEj04">Unload all datasets matching HLQ from DASD to
               tape</a><br>
               5) <a href="#IEHMOVEj05">Reload
               partitioned dataset from tape to DASD</a><br>
               6)&nbsp;<br>
            </td>
         </tr>
         <tr>
            <td width="17%" valign="top" height="22">
               <h3><a href="#IEHPROGM" name="IEHPROGMi">IEHPROGM</a></h3>
            </td>
            <td width="20%" valign="top" height="22"><a href="#IEHPROGMadd">ADD</a><a href="#IEHPROGMcatlg"><br>
               CATLG<br>
               </a><a href="#IEHPROGMdeletep">DELETEP<br>
               </a><a href="#IEHPROGMlist">LIST</a><br>
               <a href="#IEHPROGMrename">
               RENAME</a><br>
               <a href="#IEHPROGMreplace">REPLACE</a><br>
               <a href="#IEHPROGMscratch">
               SCRATCH</a><br>
               <a href="#IEHPROGMuncatlg">
               UNCATLG</a>
            </td>
            <td width="103%" valign="top" height="22">1)&nbsp;<a href="#IEHPROGMj01">Scratch
               all expired datasets, including SYS datasets</a><br>
               2)&nbsp;<a href="#IEHPROGMj02">Remove all datasets on volume, regardless
               of expiration status</a><br>
               3)&nbsp;<a href="#IEHPROGMj03">Scratch and uncatalog two datasets</a><br>
               4)&nbsp;<a href="#IEHPROGMj04">Rename and recatalog a dataset</a><br>
               5)&nbsp;<a href="#IEHPROGMj05">Add passwords to a dataset</a><br>
               6) <a href="#IEHPROGMj06">List passwords for a dataset</a><br>
               7) <a href="#IEHPROGMj07">Rename a member of a Partitioned dataset</a>
            </td>
         </tr>
         <tr>
            <td width="17%" valign="top" height="22">
               <h3><a href="#LISTPDS" name="LISTPDSi">LISTPDS</a></h3>
            </td>
            <td width="20%" valign="top" height="22"><a href="#LISTPDSdeck">DECK | NODECK<br>
               </a><a href="#LISTPDSeject">EJECT | NOEJECT<br>
               </a><a href="#LISTPDSeropt">EROPT<br>
               </a><a href="#LISTPDShexout">HEXOUT | NOHEXOUT<br>
               </a><a href="#LISTPDSlinecnt">LINECNT</a><a href="#LISTPDSlist"><br>
               LIST |
               NOLIST</a><br>
               <a href="#LISTPDSlistdir">LISTDIR</a><a href="#LISTPDSxlate"><br>
               </a><a href="#LISTPDSnum">NUM | NONUM<br>
               </a><a href="#LISTPDSrits">RITS | CRBE | CRJE<br>
               </a><a href="#LISTPDSselect">SELECT | NOSEL | EXCLUDE</a><a href="#LISTPDSrits"><br>
               </a><a href="#LISTPDSspf">SPF | NOSPF</a><br>
               <a href="#LISTPDSssi">SSI | NOSSI</a><br>
               <a href="#LISTPDStrunc">TRUNC | NOTRUNC</a><br>
               <a href="#LISTPDSupdte">UPDTE | NOUPDTE</a><br>
               <a href="#LISTPDSxlate">XLATE | TEXT | NOXLATE | NOTEXT</a>
            </td>
            <td width="103%" valign="top" height="22">1) <a href="#LISTPDSj01">Print the
               directory of a partitioned dataset</a><br>
               2) <a href="#LISTPDSj02">Print all members of a partitioned dataset</a><br>
               3) <a href="#LISTPDSj03">Punch selected members of a partitioned dataset</a><br>
               4) <a href="#LISTPDSj04">Punch selected members of a partitioned dataset
               with IEBUPDTE cards</a><br>
               5) <a href="#LISTPDSj05">Punch and print sequential dataset</a>&nbsp;
            </td>
         </tr>
         <tr>
            <td width="17%" valign="top" height="22">
               <h3><a href="#MINIUNZ" name="MINIUNZi">MINIUNZ</a></h3>
            </td>
            <td width="20%" valign="top" height="22">
            </td>
            <td width="103%" valign="top" height="22">1) <a href="#MINIUNZj01">List
              contents of archive</a><br>
              2) <a href="#MINIUNZj02">Extract entire contents of archive to a
              partitioned dataset</a><br>
              3) <a href="#MINIUNZj03">Extract a single member from an archive
              to a sequential dataset</a>
            </td>
         </tr>
         <tr>
            <td width="17%" valign="top" height="22">
               <h3><a href="#MINIZIP" name="MINIZIPi">MINIZIP</a></h3>
            </td>
            <td width="20%" valign="top" height="22">
            </td>
            <td width="103%" valign="top" height="22">1) <a href="#MINIZIPj01">Compress
              all members of a partitioned dataset to archive</a><br>
              2) <a href="#MINIZIPj02">Compress all members of three partitioned
              datasets to archive</a><br>
              3) <a href="#MINIZIPj03">Compress three sequential datasets to
              archive</a><br>
              4) <a href="#MINIZIPj04">Compress four members of a partitioned
              dataset to archive</a>
            </td>
         </tr>
         <tr>
            <td width="17%" valign="top" height="22">
               <h3><a href="#OFFLOAD" name="OFFLOADi">OFFLOAD</a></h3>
            </td>
            <td width="20%" valign="top" height="22"><a href="#OFFLOADexclude">E
               (Exclude)</a><a href="#OFFLOADoffload"><br>
               O (Offload)</a><br>
               <a href="#OFFLOADselect">S (Select)</a>
            </td>
            <td width="103%" valign="top" height="22">1) <a href="#OFFLOADj01">Offload
               selected members of a partitioned dataset</a><br>
               2) <a href="#OFFLOADj02">Offload all but excluded member of a partitioned
               dataset</a><br>
               3) <a href="#OFFLOADj03">Offload all members of a partitioned dataset</a>&nbsp;
            </td>
         </tr>
         <tr>
            <td width="17%" valign="top" height="22">
               <h3><a href="#PDSLOAD" name="PDSLOADi">PDSLOAD</a></h3>
            </td>
            <td width="20%" valign="top" height="22"><a href="#PDSLOADck3">CK3</a><br>
               <a href="#PDSLOADctl">CTL(xx)</a><br>
               <a href="#PDSLOADname">NAME={CHK|ASIS|IBM}</a><br>
               <a href="#PDSLOADnew">NEW</a><br>
               <a href="#PDSLOADs">S(namemask)</a><br>
               <a href="#PDSLOADspf">SPF</a><br>
               <a href="#PDSLOADupdte">UPDTE(x)</a>
            </td>
            <td width="103%" valign="top" height="22">1)&nbsp;<a href="#PDSLOADj01">Load
               partitioned dataset from OFFLOADed dataset</a><br>
               2)&nbsp;<a href="#PDSLOADj02">Load partitioned dataset using mask to
               select members</a><br>
               3)&nbsp;<a href="#PDSLOADj03">Add members to partitioned dataset from
               OFFLOADed dataset</a>
            </td>
         </tr>
         <tr>
            <td width="17%" valign="top" height="22">
               <h3><a href="#PDSMATCH" name="PDSMATCHi">PDSMATCH</a></h3>
            </td>
            <td width="20%" valign="top" height="22"></td>
            <td width="103%" valign="top" height="22">1) <a href="#PDSMATCHj01">Compare
               two partitioned datasets, names only</a><br>
               2) <a href="#PDSMATCHj02">Compare two partitioned datasets, names and
               userdata</a><br>
               3) <a href="#PDSMATCHj03">Compare two partitioned datasets, names and
               actual data records</a>
            </td>
         </tr>
         <tr>
            <td width="17%" valign="top" height="22">
               <h3><a href="#PDSPRINT" name="PDSPRINTi">PDSPRINT</a></h3>
            </td>
            <td width="20%" valign="top" height="22"><a href="#PDSPRINTprint">PRINT</a><br>
               <a href="#PDSPRINTpunch">PUNCH</a>
            </td>
            <td width="103%" valign="top" height="22">1) <a href="#PDSPRINTj01">Punch
               all members with IEBUPDTE ADD cards</a><br>
               2) <a href="#PDSPRINTj02">Print selected members</a><br>
               3) <a href="#PDSPRINTj03">Punch long list of selected members</a><br>
               4) <a href="#PDSPRINTj04">Print members selected with name pattern</a>&nbsp;
            </td>
         </tr>
         <tr>
            <td width="17%" valign="top" height="22">
               <h3><a href="#PDSPROGM" name="PDSPROGMi">PDSPROGM</a></h3>
            </td>
            <td width="20%" valign="top" height="22"><a href="#PDSPROGMalias">ALIAS</a><br>
               <a href="#PDSPROGMdelete">DELETE</a><br>
               <a href="#PDSPROGMfile">FILE</a><br>
               <a href="#PDSPROGMoption">OPTION</a><br>
               <a href="#PDSPROGMrename">RENAME</a>
            </td>
            <td width="103%" valign="top" height="22">1) <a href="#PDSPROGMj01">Partitioned
               dataset maintenance</a>&nbsp;
            </td>
         </tr>
         <tr>
            <td width="17%" valign="top" height="22">
               <h3><a href="#PDSSCAN" name="PDSSCANi">PDSSCAN</a></h3>
            </td>
            <td width="20%" valign="top" height="22"></td>
            <td width="103%" valign="top" height="22">1) <a href="#PDSSCANj01">Scan two
               partitioned datasets searching for strings</a>
            </td>
         </tr>
         <tr>
            <td width="17%" valign="top" height="22">
               <h3><a href="#PDSUPDTE" name="PDSUPDTEi">PDSUPDTE</a></h3>
            </td>
            <td width="20%" valign="top" height="22"></td>
            <td width="103%" valign="top" height="22">1) <a href="#PDSUPDTEj01">Scan two
               partitioned datasets searching for strings</a>&nbsp;<br>
               2) <a href="#PDSUPDTEj02">Scan a partitioned dataset, two matchings
               strings required, update if found</a>
            </td>
         </tr>
         <tr>
            <td width="17%" valign="top" height="22">
               <h3><a href="#PDSUR" name="PDSURi">PDSUR</a></h3>
            </td>
            <td width="20%" valign="top" height="22"><a href="#PDSURlist">LIST</a><br>
               <a href="#PDSURmember">MEMBER</a><br>
               <a href="#PDSURreload">RELOAD</a><br>
               <a href="#PDSURunload">UNLOAD</a>
            </td>
            <td width="103%" valign="top" height="22">1) <a href="#PDSURj01">Unload two
               partitioned datasets</a><br>
               2) <a href="#PDSURj02">Reload a partitioned dataset</a><br>
               3) <a href="#PDSURj03">Unload and reload a partitioned dataset in one step</a><br>
               4) <a href="#PDSURj04">List three unloaded partitioned datasets</a><br>
               5) <a href="#PDSURj05">Unload with selects and excludes</a><br>
               6) <a href="#PDSURj06">Reload with selects and excludes</a>
            </td>
         </tr>
         <tr>
            <td width="17%" valign="top" height="22">
               <h3><a href="#RECV370" name="RECV370i">RECV370</a></h3>
            </td>
            <td width="20%" valign="top" height="22"></td>
            <td width="103%" valign="top" height="22">1) <a href="#RECV370j01">Unpack
               XMIT to create PDS</a>
            </td>
         </tr>
         <tr>
            <td width="17%" valign="top" height="22">
               <h3><a href="#RESETDS" name="RESETDSi">RESETDS</a></h3>
            </td>
            <td width="20%" valign="top" height="22"></td>
            <td width="103%" valign="top" height="22">1) <a href="#RESETDSj01">Reset
               datasets to empty</a>
            </td>
         </tr>
         <tr>
            <td width="17%" valign="top" height="22">
               <h3><a href="#REVLMOD" name="REVLMODi">REVLMOD</a></h3>
            </td>
            <td width="20%" valign="top" height="22"></td>
            <td width="103%" valign="top" height="22">1) <a href="#REVLMODj01">Reload
               load module from sequential dataset</a>
            </td>
         </tr>
         <tr>
            <td width="17%" valign="top" height="22">
               <h3><a href="#SORT" name="SORTi">SORT</a></h3>
            </td>
            <td width="20%" valign="top" height="22"><a href="#SORTsort">SORT</a><br>
               <a href="#SORTmerge">MERGE</a><br>
               <a href="#SORTrecord">RECORD</a><br>
               <a href="#SORTmods">MODS</a><br>
               <a href="#SORTend">END</a>
            </td>
            <td width="103%" valign="top" height="22">1) <a href="#SORTj01">Sort 1 tape
               dataset, creating a disk dataset</a><br>
               2) <a href="#SORTj02">Sort 2 tape datasets (implicit merge), creating a
               disk dataset</a><br>
               3) <a href="#SORTj03">Merge 2 disk datasets, creating a disk dataset</a><br>
               4) <a href="#SORTj04">Sort disk dataset on split sequence field<br>
               </a>5) <a href="#SORTj05">Sort disk dataset on split sequence field, all
               CH data</a>
            </td>
         </tr>
         <tr>
            <td width="17%" valign="top" height="22">
               <h3><a href="#SUPERLST" name="SUPERLSTi">SUPERLST</a></h3>
            </td>
            <td width="20%" valign="top" height="22"></td>
            <td width="103%" valign="top" height="22">1) <a href="#SUPERLSTj01">List
               VTOCs and PDS directories on two volumes</a>
            </td>
         </tr>
         <tr>
            <td width="17%" valign="top" height="22">
               <h3><a href="#SYSREPRO" name="SYSREPROi">SYSREPRO</a></h3>
            </td>
            <td width="20%" valign="top" height="22"></td>
            <td width="103%" valign="top" height="22">1) <a href="#SYSREPROj01">Print a
               card dataset</a><br>
               2) <a href="#SYSREPROj02">Copy a sequential dataset, disk to disk</a><br>
               3) <a href="#SYSREPROj03">Copy a tape dataset to disk</a><br>
               4) <a href="#SYSREPROj04">Add member to existing partitioned dataset from
               cards</a>
            </td>
         </tr>
         <tr>
            <td width="17%" valign="top" height="22">
               <h3><a href="#TAPEMAP" name="TAPEMAPi">TAPEMAP</a></h3>
            </td>
            <td width="20%" valign="top" height="22"></td>
            <td width="103%" valign="top" height="22">1) <a href="#TAPEMAPj01">Analyze
               tape and report on files and their contents</a>
            </td>
         </tr>
         <tr>
            <td width="17%" valign="top" height="22">
               <h3><a href="#TAPESCAN" name="TAPESCANi">TAPESCAN</a></h3>
            </td>
            <td width="20%" valign="top" height="22"></td>
            <td width="103%" valign="top" height="22">1) <a href="#TAPESCANj01">Print
               dataset VTOC for SL tape</a><br>
               2) <a href="#TAPESCANj02">Copy 4th and 5th datasets to second tape</a>
            </td>
         </tr>
         <tr>
            <td width="17%" valign="top" height="22">
               <h3><a href="#UNUPDTE" name="UNUPDTEi">UNUPDTE</a></h3>
            </td>
            <td width="20%" valign="top" height="22"></td>
            <td width="103%" valign="top" height="22">1) <a href="#UNUPDTEj01">Offload members of a partitioned dataset
               to sequential dataset</a>
            </td>
         </tr>
         <tr>
            <td width="17%" valign="top" height="22">
               <h3><a href="#UPDTE" name="UPDTEi">UPDTE</a></h3>
            </td>
            <td width="20%" valign="top" height="22"></td>
            <td width="103%" valign="top" height="22">1) <a href="#UPDTEj01">Load partitioned dataset
               from sequential dataset</a>
            </td>
         </tr>
         <tr>
            <td width="17%" valign="top" height="22">
               <h3><a href="#VTOCLIST" name="VTOCLISTi">VTOCLIST</a></h3>
            </td>
            <td width="20%" valign="top" height="22"></td>
            <td width="103%" valign="top" height="22">1) <a href="#VTOCLISTj01">List
               VTOC for DASD volume</a><br>
               2) <a href="#VTOCLISTj02">List VTOC for DASD volume with PDS directory
               information</a>
            </td>
         </tr>
         <tr>
            <td width="17%" valign="top" height="22">
               <h3><a href="#XMIT370" name="XMIT370i">XMIT370</a></h3>
            </td>
            <td width="20%" valign="top" height="22"></td>
            <td width="103%" valign="top" height="22">1) <a href="#XMIT370j01">Pack
               partitioned dataset into XMIT</a>
            </td>
         </tr>
         <tr>
            <td width="17%" valign="top" height="22">
               <h3><a href="#ZAPDSCB" name="ZAPDSCBi">ZAPDSCB</a></h3>
            </td>
            <td width="20%" valign="top" height="22"></td>
            <td width="103%" valign="top" height="22">1) <a href="#ZAPDSCBj01">Modify
               DSCB fields for dataset</a>
            </td>
         </tr>
         <tr>
            <td width="17%" valign="top" height="22">
               <h3><a href="#ZTDUMPTP" name="ZTDUMPTPi">ZTDUMPTP</a></h3>
            </td>
            <td width="20%" valign="top" height="22"><a href="#ZTDUMPTPfiles">FILES</a><br>
               <a href="#ZTDUMPTPmode">MODE</a><br>
               <a href="#ZTDUMPTPprint">PRINT</a><br>
               <a href="#ZTDUMPTPrec">REC</a><br>
               <a href="#ZTDUMPTPredun">REDUN</a><br>
               <a href="#ZTDUMPTPrun">RUN</a><br>
               <a href="#ZTDUMPTPskpfil">SKPFIL</a><br>
               <a href="#ZTDUMPTPskprec">SKPREC</a>
            </td>
            <td width="103%" valign="top" height="22">1) <a href="#ZTDUMPTPj01">Dump and
               print first 20 records from first 5 files on tape</a>
            </td>
         </tr>
         <tr>
            <td width="17%" valign="top" height="22">
               <h3><a href="#ZZRELINK" name="ZZRELINKi">ZZRELINK</a></h3>
            </td>
            <td width="20%" valign="top" height="22"><a href="#ZZRELINKlink">LINK</a><br>
               <a href="#ZZRELINKselect">SELECT</a>
            </td>
            <td width="103%" valign="top" height="22">1)&nbsp;<a href="#ZZRELINKj01">Create
               (on SYSPUNCH) JCL for job to relink a load module</a><br>
               2)&nbsp;<a href="#ZZRELINKj02">Re-link-edit all members of a load library
               to a new library</a><br>
               3) <a href="#ZZRELINKj03">Re-link-edit a load module, renaming it into the
               input library</a><br>
               4) <a href="#ZZRELINKj04">Re-link-edit a group of modules to a new
               library, replacing duplicates</a>
            </td>
         </tr>
      </tbody></table>
      <hr size="8" noshade="noshade">
      <h2><a name="AMASPZAP"></a>AMASPZAP <font size="2">[supplied by IBM, located in
         SYS1.LINKLIB]</font>
      </h2>
      <p>Used for inspecting and/or modifying a load module or data record stored on
         disk.&nbsp; AMASPZAP requires the following DD statements:
      </p>
      <ul>
         <li>SYSPRINT - defines a sequential output message dataset.</li>
         <li>
            SYSLIB - defines the load library or dataset that will be accessed.
            <p>DSNAME and DISP (either OLD or SHR) are required.<br>
               The VOLUME and UNIT parameters are necessary only if the dataset is not
               cataloged.<br>
               When the dataset is the VTOC, DSNAME=FORMAT4.DSCB must be specified.<br>
               The SYSLIB DD statement cannot define a concatenated dataset.<br>
         </p></li>
         <li>SYSIN - defines a sequential input dataset that contains AMASPZAP control
            statements.
         </li>
      </ul>
      <h3>&nbsp;</h3>
      <h3>Control Statements</h3>
      <blockquote>
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="9%">
                  <pre><a name="AMASPZAPname"></a>NAME</pre>
               </td>
               <td width="91%">
                  <pre>member</pre>
               </td>
            </tr>
            <tr>
               <td width="9%">
                  <pre></pre>
               </td>
               <td width="91%">
                  <pre>csect</pre>
               </td>
            </tr>
         </tbody></table>
         <p>The NAME control statement specifies the CSECT in a load module that is to be the object of
            subsequent VERIFY, REP, IDRDATA or SETSSI operations.&nbsp; The parameters
            are:
         </p>
         <blockquote>
            <p>member</p>
            <blockquote>
               <p>Specifies the member name of the load module that contains the control section
                  in which the data to be inspected and/or modified is contained.&nbsp;
                  The load module must be a member of the partitioned dataset defined by
                  the SYSLIB DD statement.
               </p>
            </blockquote>
            <p>csect</p>
            <blockquote>
               <p>Specifies the name of the particular control section that contains the data to
                  be verified or replaced.&nbsp; When this parameter is omitted, it is
                  assumed that the first CSECT contained in the load module is the one to
                  be referenced.&nbsp; If there is only one CSECT in the load module, this
                  parameter is not required.
               </p>
            </blockquote>
         </blockquote>
         <hr color="#808080">
      </blockquote>
      <blockquote>
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="9%">
                  <pre><a name="AMASPZAPcchr"></a>CCHHR</pre>
               </td>
               <td width="91%">
                  <pre>record address</pre>
               </td>
            </tr>
         </tbody></table>
         <p>The CCHHR control statement specifies the address of a 
physical record on a direct access device that is to be
            modified or verified.&nbsp; The record must be located 
within the dataset defined by the
            SYSLIB DD statement.&nbsp; Any immediately following REP or 
VERIFY control statements will reference the data in the specified 
record.&nbsp; The
            parameter is:
         </p>
         <blockquote>
            <p>record address</p>
            <blockquote>
               <p>Specifies the actual direct access device address of the record containing the
                  data to be replaced or verified.&nbsp; It must be specified as a 10-digit
                  hexadecimal number in the form cccchhhhrr, where cccc is the cylinder,
                  hhhh is the track, and rr is the record number.&nbsp; For example,
                  0001000A01 addresses record 1 of cylinder 1, track 10.&nbsp; A zero
                  record number is invalid and will default to 1.
               </p>
            </blockquote>
         </blockquote>
         <p>More than one CCHHR control statement can be supplied in the input stream,
            however, the VERIFY, REP and SETSSI control statements associated with each
            CCHHR control statement must immediately follow the specific CCHHR
            control statement to
            which they apply.
         </p>
         <hr color="#808080">
      </blockquote>
      <blockquote>
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="18%">
                  <pre><a name="AMASPZAPver"></a>VER | VERIFY </pre>
               </td>
               <td width="82%">
                  <pre>offset </pre>
               </td>
            </tr>
            <tr>
               <td width="18%">
                  <pre></pre>
               </td>
               <td width="82%">
                  <pre>expected content</pre>
               </td>
            </tr>
         </tbody></table>
         <p>The VERIFY control statement specifies that the contents at a
 specified location within a control section or
            physical record are to be compared with the data the user 
supplies in the
            control statement.&nbsp; VERIFY may be abbreviated to 
VER.&nbsp; If the two fields being compared are not in agreement, no
            succeeding REP or SETSSI operations will be performed until 
the next NAME or
            CCHHR control statement is encountered.&nbsp; A formatted 
dump is provided
            of each CSECT or record for which a VERIFY operation 
failed.&nbsp; The
            parameters are:
         </p>
         <blockquote>
            <p>offset</p>
            <blockquote>
               <p>Specifies the hexadecimal displacement of the data to be inspected in a CSECT
                  or record.&nbsp; This displacement must be specified as a multiple of two
                  hexadecimal digits (0D, 021C, 014682, etc.).&nbsp; If this offset value
                  is outside the limits of the CSECT or data record defined by the
                  preceding NAME or CCHHR control statement, the VERIFY control statement will be
                  rejected.&nbsp; When inspecting a record with a key, the length of the
                  key should be considered in the calculation of the displacement; that
                  is, offset zero is the first byte of the key.
               </p>
            </blockquote>
            <p>expected content</p>
            <blockquote>
               <p>Specifies the bytes of data that are expected at the specified
                  location.&nbsp; As with the offset parameter, the number of bytes of
                  data defined must be specified as a multiple of two hexadecimal
                  digits.&nbsp; If desired, the data within the parameters may be
                  separated by commas (never blanks), but again, the number of digits
                  between commas must also be a multiple of two.&nbsp; For example, the
                  data may look like this:&nbsp; 5840C032 (no commas), or this:&nbsp; 5840,C032
                  (commas).
               </p>
               <p>If all the data will not fit into one VERIFY control statement (one 80-byte
                  logical record), then another VERIFY control statement must be supplied.
               </p>
            </blockquote>
         </blockquote>
         <hr color="#808080">
      </blockquote>
      <blockquote>
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="10%">
                  <pre><a name="AMASPZAPrep"></a>REP</pre>
               </td>
               <td width="90%">
                  <pre>offset </pre>
               </td>
            </tr>
            <tr>
               <td width="10%">
                  <pre></pre>
               </td>
               <td width="90%">
                  <pre>data</pre>
               </td>
            </tr>
         </tbody></table>
         <p>The REP control statement modifies data at a specified location in a CSECT or physical record that has
            been previously defined by a NAME or CCHHR control statement.&nbsp; The data
            specified on the REP control statement will replace the data at the record or CSECT
            location stipulated in the offset parameter field.&nbsp; (Note:&nbsp; You
            should always first use the VERIFY function to make sure you know what you are
            going to change with the REP function.)&nbsp; A message will be issued to
            record the contents of the specified location as they were before the change
            was made.&nbsp; The parameters are:
         </p>
         <blockquote>
            <p>offset</p>
            <blockquote>
               <p>Specifies the hexadecimal displacement of the data to be inspected in a CSECT
                  or record.&nbsp; This displacement must be specified as a multiple of two
                  hexadecimal digits (0D, 021C, 014682, etc.).&nbsp; If this offset value
                  is outside the limits of the CSECT or data record defined by the
                  preceding NAME or CCHHR control statement, the REP control statement will be
                  rejected.&nbsp; When modifying a record with a key, the length of the
                  key should be considered in the calculation of the displacement; that
                  is, offset zero is the first byte of the key.
               </p>
            </blockquote>
            <p>data</p>
            <blockquote>
               <p>Specifies the bytes of data that are to be inserted at the specified
                  location.&nbsp; As with the offset parameter, the number of bytes of
                  data defined must be specified as multiples of two hexadecimal
                  digits.&nbsp; If desired, the data within the parameter may be separated
                  by commas (never blanks), but again, the number of digits between commas
                  must also be a multiple of two.&nbsp; For example, the data may look
                  like this:&nbsp; 4160BB20 (no commas), or this:&nbsp; 4160,BB20
                  (commas).
               </p>
               <p>If all the data to be modified will not fit into one REP control statement
                  (one 80-byte logical record), then another REP control statement must be
                  supplied.
               </p>
            </blockquote>
         </blockquote>
         <p>AMASPZAP automatically updates the system status index (SSI) when it successfully
            modifies the associated load module.
         </p>
         <p>If multiple VERIFY and REP operations are to be performed on a CSECT,
            then all the VERIFY control statements should precede all the REP control statements.&nbsp;
            This will ensure that all the REP operations are ignored if any VERIFY
            reject occurs.
         </p>
         <p>When a record in the VTOC (that is, a DSCB) is accessed for modification,
            a message is written to the console.
         </p>
         <hr color="#808080">
      </blockquote>
      <blockquote>
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="13%">
                  <pre><a name="AMASPZAPidrdata"></a>IDRDATA</pre>
               </td>
               <td width="87%">
                  <pre>xxxxxxxx</pre>
               </td>
            </tr>
         </tbody></table>
         <p>The IDRDATA control statement places up to eight bytes of user data into the CSECT Identification
            Record of the load module.&nbsp; This is only done if a REP operation associated
            with a NAME control statement is performed and the load module has been processed by
            the Linkage Editor to include CSECT Identification Records.&nbsp; The
            parameter is:
         </p>
         <blockquote>
            <p>xxxxxxxx</p>
            <blockquote>
               <p>Specifies one to eight characters of user data (with no embedded blanks) that
                  is to be placed in the user data field of the IDR of the load
                  module.&nbsp; If more than eight characters are in the parameter field,
                  only the first eight characters will be used.
               </p>
            </blockquote>
         </blockquote>
         <p>The IDRDATA control statement is valid only when used in conjunction with the
            NAME control statement.&nbsp; It must follow its associated NAME control statement and
            precede any DUMP or ABSDUMP control statement.&nbsp; IDRDATA control statements associated
            with CCHHR control statements will be ignored.
         </p>
         <hr color="#808080">
      </blockquote>
      <blockquote>
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="10%">
                  <pre><a name="AMASPZAPsetssi"></a>SETSSI</pre>
               </td>
               <td width="90%">
                  <pre>xxyynnnn</pre>
               </td>
            </tr>
         </tbody></table>
         <p>The SETSSI control statement places user supplied system status information in the partitioned dataset
            directory entry for the library member specified in the preceding NAME
            control statement.&nbsp; The SSI, however, must have been created when the load
            module was link edited.&nbsp; The parameter is:
         </p>
         <blockquote>
            <p>xxyynnnn</p>
            <blockquote>
               <p>Specifies the 4 bytes of system status information the user wishes
                  to place in the SSI field for this member.&nbsp; Each byte is supplied
                  as two hexadecimal digits signifying the following:
               </p>
               <blockquote>
                  <p>xx - change level<br>
                     yy - flag byte<br>
                     nnnn - modification serial number
                  </p>
               </blockquote>
            </blockquote>
         </blockquote>
         <p>If an error has been detected in any previous VERIFY or REP operation,
            the SETSSI function will not be performed.
         </p>
         <p>Since all bits in the SSI entry are set (or reset) by the 
SETSSI control statement, extreme care should be exercised in its use to
 avoid altering information
            vital to the depiction of the maintenance status of the 
program being
            changed.&nbsp; A message will be issued to record the SSI as
 it was before
            the SETSSI operation was performed.
         </p>
         <hr color="#808080">
      </blockquote>
      <blockquote>
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="17%">
                  <pre><a name="AMASPZAPdump"></a>DUMP | DUMPT</pre>
               </td>
               <td width="83%">
                  <pre>member</pre>
               </td>
            </tr>
            <tr>
               <td width="17%">
                  <pre></pre>
               </td>
               <td width="83%">
                  <pre>csect | ALL</pre>
               </td>
            </tr>
         </tbody></table>
         <p>The DUMP control statement dumps a specific control section or all control sections in a load
            module.&nbsp; The format of the output of this dump is hexadecimal.&nbsp;
            The DUMPT control statement differs from the DUMP control statement in that it also gives the
            user an EBCDIC and instruction mnemonic translation of the hexadecimal
            data.&nbsp; The parameters are:
         </p>
         <blockquote>
            <p>member</p>
            <blockquote>
               <p>Specifies the member name of the load module that contains the control
                  section(s) to be dumped.&nbsp; This module must be a member of a
                  partitioned dataset that is defined by the SYSLIB DD statement.
               </p>
            </blockquote>
            <p>csect</p>
            <blockquote>
               <p>Specifies the name of the particular control section that is to be
                  dumped.&nbsp; To dump all the CSECTs of a load module, code ALL instead
                  of the CSECT name.&nbsp; If the CESCT parameter is omitted entirely, it
                  is assumed that the user means to dump only the first control section
                  contained in the load module.
               </p>
            </blockquote>
         </blockquote>
         <hr color="#808080">
      </blockquote>
      <blockquote>
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="25%">
                  <pre><a name="AMASPZAPabsdump"></a>ABSDUMP | ABSDUMPT</pre>
               </td>
               <td width="75%">
                  <pre>startaddr stopaddr | membername | ALL</pre>
               </td>
            </tr>
         </tbody></table>
         <p>The ABSDUMP control statement dumps a group of data records, a member of a partitioned dataset,
            or an entire dataset, as defined in the SYSLIB DD statement.&nbsp; If the
            key associated with each record is to be formatted, DCB=(KEYLEN=nn), when nn
            is the length of the record key, must also be specified by the SYSLIB DD statement.&nbsp;
            Note that when dumping a VTOC, DCB=(KEYLEN=44) should be specified; when
            dumping a PDS directory, DCB=(KEYLEN=8) should be specified.
         </p>
         <p>ABSDUMP produces a hexadecimal printout only, while ABSDUMPT prints the hexadecimal
            data, the EBCDIC translation, ant the mnemonic equivalent of the data.&nbsp;
            The parameters are:
         </p>
         <blockquote>
            <p>startaddr</p>
            <blockquote>
               <p>Specifies the absolute direct access device address of the first record to be
                  dumped.&nbsp; This address must be specified in hexadecimal in the form
                  cccchhhhrr (cylinder, track and record number).
               </p>
            </blockquote>
            <p>stopaddr</p>
            <blockquote>
               <p>Specifies the absolute direct access device address of the last record to be
                  dumped, and it must be in the same format as the start address.
               </p>
            </blockquote>
            <p>Both addresses must be specified when this method of dumping records is
               used, and both addresses must be within the limits of the dataset defined
               by the SYSLIB DD statement.&nbsp; The record number specified in the start
               address must be a valid record number.&nbsp; The record number specified
               as the stop address need not be a valid record number, but if it is not,
               the dump will continue until the last record on the track specified in the
               stop address has been dumped.
            </p>
            <p>membername</p>
            <blockquote>
               <p>Specifies the name of a member of a partitioned dataset.&nbsp; The member can
                  be a group of data records or a load module.&nbsp; In either case, the
                  entire member is dumped when this parameter is specified.
               </p>
            </blockquote>
            <p>ALL</p>
            <blockquote>
               <p>Specifies that the entire dataset defined by the SYSLIB DD statement
                  is to be dumped.&nbsp; How much of the space allocated to the dataset is
                  dumped depends on how the dataset is organized:&nbsp; for sequential
                  datasets, the dump will continue until it reaches end of file;&nbsp; for
                  indexed sequential and direct access datasets, the dump will contain all
                  extents; for partitioned datasets, the dump will contain all extents,
                  including all linkage editor control records, if any exist.
               </p>
            </blockquote>
         </blockquote>
         <hr color="#808080">
      </blockquote>
      <blockquote>
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="10%">
                  <pre><a name="AMASPZAPbase"></a>BASE</pre>
               </td>
               <td width="90%">
                  <pre>xxxxxx</pre>
               </td>
            </tr>
         </tbody></table>
         <p>The BASE control statement is used to adjust offset values that are to be specified in any subsequent
            VERIFY and REP control statements.&nbsp; This control statement should be used when the offsets
            given in the VERIFY and REP control statements for a CSECT are to be obtained from an
            assembly listing in which the starting address of the CSECT is not location
            zero.
         </p>
         <p>For example, assume that CSECT ABC begins at assembly listing location
            x'000400', and that the data to be replaced in this CSECT is at location
            x'000408'.&nbsp; The actual displacement of the data in the CSECT is
            x'08'.&nbsp; However, an offset of 'x0408' (obtained from the assembly listing
            location x'000408') can be specified in the REP control statement if a BASE statement
            specifying x'000400' is included prior to the REP control statement in the input
            stream.&nbsp; When the REP control statement is processed, the base value x'000400' will
            be subtracted from the offset x'0408' to determine the proper displacement of
            data within the CSECT.&nbsp; The parameter is:
         </p>
         <blockquote>
            <p>xxxxxx</p>
            <blockquote>
               <p>Specifies a 6-character hexadecimal offset that it to be used as a base for subsequent
                  VERIFY and REP operations.&nbsp; This value should reflect the starting assembly
                  listing address of the CSECT being inspected or modified.
               </p>
            </blockquote>
         </blockquote>
         <p>The BASE control statement should be included in the input stream immediately
            following the NAME control statement that identifies the control section that is to be
            involved in the&nbsp; operations.&nbsp; The specified base value remains in
            effect until all VERIFY, REP, and SETSSI operations for the CSECT have been
            processed.
         </p>
      </blockquote>
      <h3>&nbsp;</h3>
      <h3>Examples</h3>
      <blockquote>
         <table width="75%" cellspacing="1" border="1">
            <tbody><tr>
               <td width="33%">
                  <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="AMASPZAPj01"></a>Dump
                     the CSECT from a load module
               </p></td>
            </tr>
            <tr>
               <td width="33%">
                  <pre><b>//AMASPZAP JOB (SYS),'AMASPZAP DUMP',CLASS=A,MSGCLASS=X  
//AMASPZAP EXEC PGM=AMASPZAP                             
//SYSPRINT DD  SYSOUT=*                                  
//SYSLIB   DD  DISP=SHR,DSN=SYSC.LINKLIB                 
//SYSIN    DD  *                                         
  NAME   IKFCBL01 IKF011                                 
  DUMPT IKFCBL01 IKF011                                  
/*                                                       
//                                                       </b></pre>
               </td>
            </tr>
            <tr>
               <td width="33%">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="AMASPZAPj02"></a>Verify/Replace
                  instruction in a load module
               </td>
            </tr>
            <tr>
               <td width="33%">
                  <pre><b>//AMASPZAP JOB (SYS),'AMASPZAP REP ',CLASS=A,MSGCLASS=X 
//AMASPZAP EXEC PGM=AMASPZAP 
//SYSPRINT DD SYSOUT=* 
//SYSLIB DD DISP=SHR,DSN=JAY01.LOAD 
//SYSIN DD * 
  NAME ISLOAD 
  VER 0616 9640,1051 
  REP 0616 966B,1051 
  SETSSI 01212134 
/* 
// </b></pre>
               </td>
            </tr>
            <tr>
               <td width="33%">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="AMASPZAPj03"></a>Dump
                  a record from a file
               </td>
            </tr>
            <tr>
               <td width="33%">
                  <pre><b>//AMASPZAP JOB (SYS),'AMASPZAP DUMP',CLASS=A,MSGCLASS=X 
//AMASPZAP EXEC PGM=AMASPZAP 
//SYSPRINT DD SYSOUT=* 
//SYSLIB DD DISP=SHR,DSN=JAY01.ISAM.MASTER 
//SYSIN DD * 
  ABSDUMPT 007A000120 007A000120 
/* 
//</b></pre>
               </td>
            </tr>
            <tr>
               <td width="33%"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="AMASPZAPj04"></a></b>Inspect/Modify
                  a data record
               </td>
            </tr>
            <tr>
               <td width="33%">
                  <pre><b>//AMASPZAP JOB (SYS),'AMASPZAP CH VTOC',CLASS=A,MSGCLASS=X 
//AMASPZAP EXEC PGM=AMASPZAP 
//SYSPRINT DD SYSOUT=* 
//SYSLIB DD DISP=OLD,DSN=FORMAT4.DSCB,UNIT=3330,VOL=SER=111111,DCB=(KEYLEN=44) 
//SYSIN DD * 
  CCHHR   005000001
  VERIFY  2C 0504
  REP     2C 0A08
  REP     2E 0001,03000102
  ABSDUMPT ALL 
/* 
//</b></pre>
               </td>
            </tr>
         </tbody></table>
      </blockquote>
      <p><font size="1">Source:&nbsp; <a href="http://bitsavers.org/pdf/ibm/370/OS_VS2/Release_3.0_1975/GC28-0683-1_OS_VS2_Supervisor_Services_and_Macro_Instructions_Rel_3_Jun75.pdf" target="_blank">GC28-0633-1 OS/VS Service AIDS</a></font></p>
      <hr size="8" noshade="noshade">
      <h2><a name="AMBLIST"></a>AMBLIST <font size="2">[supplied by IBM, located in
         SYS1.LINKLIB]</font>
      </h2>
      <p>Used for producing a formatted listing of an object or load module, producing
         a map and cross-reference listing of a nucleus, producing a list of IDRDATA from
         a CSECT, or producing a map of all modules in the reenterable load module area
         (the Link Pack area).&nbsp; AMBLIST requires the following DD statements:
      </p>
      <ul>
         <li>SYSPRINT - defines a sequential output message dataset.</li>
         <li>SYSLIB or any DD name specified on the control statement - defines the load
            or object library that will be accessed.
         </li>
         <li>SYSIN - defines a sequential input dataset that contains AMBLIST control
            statements.
         </li>
      </ul>
      <h3>&nbsp;</h3>
      <h3>Control 
Statements&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</h3>
      <blockquote>
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="12%">
                  <pre><a name="AMBLISTlistload"></a>LISTLOAD</pre>
               </td>
               <td width="88%">
                  <pre>[OUTPUT={MODLIST | XREF | BOTH}]</pre>
               </td>
            </tr>
            <tr>
               <td width="12%">
                  <pre></pre>
               </td>
               <td width="88%">
                  <pre>[,TITLE=('title',position)]</pre>
               </td>
            </tr>
            <tr>
               <td width="12%"></td>
               <td width="88%">
                  <pre>[,DDN=ddname]</pre>
               </td>
            </tr>
            <tr>
               <td width="12%"></td>
               <td width="88%">
                  <pre>[,MEMBER={membername | (membername[,membername]...)]</pre>
               </td>
            </tr>
            <tr>
               <td width="12%"></td>
               <td width="88%">
                  <pre>[,RELOC=nnnnnn]</pre>
               </td>
            </tr>
         </tbody></table>
         <p>The LISTLOAD control statement produces a listing of the load module along with its module map and cross-reference
            listing.&nbsp; The parameters are:
         </p>
         <blockquote>
            <p>OUTPUT=type</p>
            <blockquote>
               <p>Specifies the type of load module listing to be produced.&nbsp; The
                  choices for type are:
               </p>
               <ul>
                  <li>MODLIST - Requests a formatted listing of the control and text records,
                     including its External Symbol Dictionary and Relocation Dictionary
                     Records.
                  </li>
                  <li>XREF - Requests a module map and cross-reference listing.</li>
                  <li>BOTH - Requests both MODLIST and XREF.</li>
               </ul>
            </blockquote>
            <p> If omitted, BOTH is
               assumed.
            </p>
            <p>TITLE=('title',position)</p>
            <blockquote>
               <p>Specifies a title, one to forty characters, to be printed below the
                  heading line on each page of the output.&nbsp; The optional position
                  specifies the number of characters from the left margin the user's title
                  is to be indented.&nbsp; There may be no commas included in the 'title'
                  text, as commas are recognized as delimiters; any characters beyond the
                  first comma encountered will be ignored.
               </p>
            </blockquote>
            <p>DDN=ddname</p>
            <blockquote>
               <p>Identifies the DD statement that defines the dataset containing the
                  input module.&nbsp; If omitted, SYSLIB is the default DD name.
               </p>
            </blockquote>
            <p>MEMBER={membername | (membername[,membername]...)&nbsp;</p>
            <blockquote>
               <p>Identifies the input load module(s) by member name or alias name.&nbsp;
                  To specify more than one load module, enclose the list of names in
                  parentheses and separate the names with commas.&nbsp; If you omit the
                  MEMBER= parameter, all modules in the dataset will be printed.
               </p>
            </blockquote>
            <p>RELOC=nnnnnn</p>
            <blockquote>
               <p>Specifies a relocation or base address in hexadecimal of up to six
                  characters.&nbsp; When the relocation address is added to each relative
                  map and cross-reference address, it gives the absolute main storage adress
                  for each item on the output listing.&nbsp; If omitted, no relocation is
                  performed.
               </p>
            </blockquote>
         </blockquote>
      </blockquote>
      <blockquote>
         <hr color="#808080">
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="12%">
                  <pre><a name="AMBLISTlistobj"></a>LISTOBJ</pre>
               </td>
               <td width="88%">
                  <pre>[TITLE=('title',position)]</pre>
               </td>
            </tr>
            <tr>
               <td width="12%"></td>
               <td width="88%">
                  <pre>[,DDN=ddname]</pre>
               </td>
            </tr>
            <tr>
               <td width="12%"></td>
               <td width="88%">
                  <pre>[,MEMBER={membername | (membername[,membername]...)}]</pre>
               </td>
            </tr>
         </tbody></table>
         <p>The LISTOBJ control statement produces a listing that contains the External Symbol Dictionary, the
            Relocation Dictionary, and the text of the program containing instructions and
            data.&nbsp; The parameters are:
         </p>
         <blockquote>
            <p>TITLE=('title',position)</p>
            <blockquote>
               <p>Specifies a title, one to forty characters, to be printed below the
                  heading line on each page of the output.&nbsp; The optional position
                  specifies the number of characters from the left margin the user's title
                  is to be indented.&nbsp; There may be no commas included in the 'title'
                  text, as commas are recognized as delimiters; any characters beyond the
                  first comma encountered will be ignored.
               </p>
            </blockquote>
            <p>DDN=ddname</p>
            <blockquote>
               <p>Identifies the DD statement that defines the dataset containing the
                  input module.&nbsp; If omitted, SYSLIB is the default DD name.
               </p>
            </blockquote>
            <p>MEMBER={ membername | (membername[,membername]...)</p>
            <blockquote>
               <p>Identifies the input load module(s) by member name or alias name.&nbsp;
                  To specify more than one load module, enclose the list of names in
                  parentheses and separate the names with commas.&nbsp; If you omit the
                  MEMBER= parameter, all modules in the dataset will be printed.
               </p>
            </blockquote>
         </blockquote>
      </blockquote>
      <blockquote>
         <hr color="#808080">
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="12%">
                  <pre><a name="AMBLISTlistidr"></a>LISTIDR</pre>
               </td>
               <td width="88%">
                  <pre>[OUTPUT={IDENT | ALL}]</pre>
               </td>
            </tr>
            <tr>
               <td width="12%"></td>
               <td width="88%">
                  <pre>[,TITLE=('title',position)]</pre>
               </td>
            </tr>
            <tr>
               <td width="12%"></td>
               <td width="88%">
                  <pre>[,DDN=ddname]</pre>
               </td>
            </tr>
            <tr>
               <td width="12%"></td>
               <td width="88%">
                  <pre>[,MEMBER={membername | (membername[,membername]...)}]</pre>
               </td>
            </tr>
         </tbody></table>
         <p>The LISTIDR control statement produces a formatted listing of all information in a load module's CSECT
            identification records, including:
         </p>
         <blockquote>
            <ul>
               <li>the version and modification level of the language translator and the
                  date that each CSECT was translated,
               </li>
               <li>the version and modification level of the linkage editor that built
                  the load module and gives the date the load module was created,
               </li>
               <li>identifies by date modifications to the load module that may have been
                  performed by AMASPZAP.
               </li>
            </ul>
         </blockquote>
         <p>The parameters are:</p>
         <blockquote>
            <p>OUTPUT={IDENT | ALL }</p>
            <blockquote>
               <p>Specifies whether the listing should include all CSECT identification
                  records or only those containing AMASPZAP data and user data.&nbsp; If the
                  parameter is omitted or OUTPUT=ALL is specified, all IDRs associated with
                  the module will be printed.&nbsp; If OUTPUT=IDENT is specified, only those
                  IDRs that contain AMASPZAP data or user-supplied data will be printed.
               </p>
            </blockquote>
            <p>TITLE=('title',position)</p>
            <blockquote>
               <p>Specifies a title, one to forty characters, to be printed below the
                  heading line on each page of the output.&nbsp; The optional position
                  specifies the number of characters from the left margin the user's title
                  is to be indented.&nbsp; There may be no commas included in the 'title'
                  text, as commas are recognized as delimiters; any characters beyond the
                  first comma encountered will be ignored.
               </p>
            </blockquote>
            <p>DDN=ddname</p>
            <blockquote>
               <p>Identifies the DD statement that defines the dataset containing the
                  input module.&nbsp; If omitted, SYSLIB is the default DD name.
               </p>
            </blockquote>
            <p>MEMBER={ membername | (membername[,membername]...)</p>
            <blockquote>
               <p>Identifies the input load module(s) by member name or alias name.&nbsp;
                  To specify more than one load module, enclose the list of names in
                  parentheses and separate the names with commas.&nbsp; If you omit the
                  MEMBER= parameter, all modules in the dataset will be printed.
               </p>
            </blockquote>
         </blockquote>
      </blockquote>
      <blockquote>
         <hr color="#808080">
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="12%">
                  <pre><a name="AMBLISTlistlpa"></a>LISTLPA</pre>
               </td>
               <td width="88%">
                  <pre></pre>
               </td>
            </tr>
         </tbody></table>
         <p>The LISTLPA control statement produces a map of all modules in the reenterable load module area (the Link
            Pack area).&nbsp; There are no parameters for this control statement.
         </p>
      </blockquote>
      <h3>&nbsp;</h3>
      <h3>Examples</h3>
      <blockquote>
         <table width="75%" cellspacing="1" border="1">
            <tbody><tr>
               <td width="33%">
                  <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="AMBLISTj01"></a>List
                     Load Module
               </p></td>
            </tr>
            <tr>
               <td width="33%">
                  <pre><b>//AMBLIST  JOB (SYS),AMBLIST,CLASS=A,MSGCLASS=X 
//AMBLIST  EXEC PGM=AMBLIST                     
//SYSPRINT DD  SYSOUT=*                         
//SYSLIB   DD  DISP=SHR,DSN=SYSC.LINKLIB        
//SYSIN    DD  *                                
  LISTLOAD OUTPUT=BOTH,MEMBER=IKFCBL01          
//                     </b></pre>
               </td>
            </tr>
            <tr>
               <td width="33%">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="AMBLISTj02"></a>List
                  Object Module
               </td>
            </tr>
            <tr>
               <td width="33%">
                  <pre><b>//AMBLIST  JOB (SYS),AMBLIST,CLASS=A,MSGCLASS=X  
//AMBLIST  EXEC PGM=AMBLIST                      
//SYSPRINT DD  SYSOUT=*                          
//SYSLIB   DD  DISP=SHR,DSN=MVTSRC.COBOL.OBJECT, 
//             UNIT=SYSDA,VOL=SER=MVTSRC         
//SYSIN    DD  *                                 
  LISTOBJ  MEMBER=IKFCBL01                       
// </b></pre>
               </td>
            </tr>
            <tr>
               <td width="33%">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="AMBLISTj03"></a>List
                  Identification Records from one or more CSECTs
               </td>
            </tr>
            <tr>
               <td width="33%">
                  <pre><b>//AMBLIST  JOB (SYS),AMBLIST,CLASS=A,MSGCLASS=X 
//AMBLIST  EXEC PGM=AMBLIST                     
//SYSPRINT DD  SYSOUT=*                         
//SYSLIB   DD  DISP=SHR,DSN=SYSC.LINKLIB        
//SYSIN    DD  *                                
  LISTIDR  OUTPUT=IDENT,MEMBER=IKFCBL01         
//                                              </b></pre>
               </td>
            </tr>
            <tr>
               <td width="33%"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="AMBLISTj04"></a></b>List
                  Link Pack area
               </td>
            </tr>
            <tr>
               <td width="33%">
                  <pre><b>//AMBLIST  JOB (SYS),AMBLIST,CLASS=A,MSGCLASS=X 
//AMBLIST  EXEC PGM=AMBLIST                     
//SYSPRINT DD  SYSOUT=*                         
//SYSIN    DD  *                                
  LISTLPA                                        
//</b></pre>
               </td>
            </tr>
         </tbody></table>
      </blockquote>
      <p><font size="1">Source:&nbsp; <a href="http://bitsavers.org/pdf/ibm/370/OS_VS2/Release_3.0_1975/GC28-0683-1_OS_VS2_Supervisor_Services_and_Macro_Instructions_Rel_3_Jun75.pdf" target="_blank">GC28-0633-1 OS/VS Service AIDS</a></font></p>
      <hr size="8" noshade="noshade">
      <h2><a name="CMPRSEQ"></a>CMPRSEQ <font size="2">[written by David B. Cole, located in
         SYSC.LINKLIB]</font>
      </h2>
      <p>Used to compare two sequential datasets or members of two partitioned datasets at the
         logical record level.&nbsp; CMPRSEQ
         was written by David B. Cole and the source may be found on CBT Tape File #226
         (Version 437).
      </p>
      <p>The CMPRSEQ program compares two sequential card image files and reports
         precisely the differences between the two.&nbsp; Such differences can consist of
         insertions, deletions, and replacements (of either equal or unequal
         sizes).&nbsp; CMPRSEQ accomplishes this by reading the two input files
         alternately and comparing the card images as it goes along.&nbsp; When it
         encounters two cards that mismatch, it saves them and continues to read the two
         files alternately.&nbsp; Each time it reads a card from one file, it compares it
         to all cards that it has read from the other file since the start of the
         mismatch.&nbsp; If no match is found, then it saves that card and proceeds to
         read the next card from the other file.&nbsp; CMPRSEQ continues alternating back
         and forth in this manner until it has read a card that does match one of the
         saved cards from the other file.&nbsp; The mismatch then consists of all cards
         in the two saved stacks that are below the two matching cards.
      </p>
      <p>CMPRSEQ requires the following DD statements:</p>
      <ul>
         <li>SYSPRINT - a sequential output message dataset.</li>
         <li>OLD - sequential input: first of the input datasets to be compared.</li>
         <li>NEW - sequential input: second of the input datasets to be compared.</li>
         <li>OLDLIST - sequential output dataset where the records read from OLD are
            reproduced, along with the locations of mismatches.
         </li>
         <li>NEWLIST - sequential output dataset where the records read from NEW are
            reproduced, along with the locations of mismatches.
         </li>
         <li>IGNORE - sequential input dataset that can contain images of records that
            appear repeatedly and are to be ignored.
         </li>
      </ul>
      <blockquote>
         <blockquote>
            <p>The ignore file is optional.&nbsp; If it is available, then it is used to
               help control the possible desynchronization problems.&nbsp; The ignore file
               should contain copies of card images that appear repeated ly throughout the
               files being compared, and especially appearing in areas affected by
               insertions and deletions.&nbsp; Copies of these cards, when encountered
               during a mismatch resolution process, will not be used to resolve the
               mismatch&nbsp;
            </p>
         </blockquote>
      </blockquote>
      <ul>
         <li>SYNC - sequential input dataset that can be used to manage
            desynchronization problems.
         </li>
      </ul>
      <blockquote>
         <blockquote>
            <p>This file should contain copies of one or more cards each of which
               appears exactly once in both the old and new files.&nbsp; The cards in the
               SYNC file should appear in the same order by which they appear in the OLD
               and NEW files.&nbsp; They should represent points in the OLD and NEW files at
               which you wish to force comparison synchronization.&nbsp; Generally, such
               points will be following those area where otherwise unrecoverable
               desynchronization has occurred.
            </p>
         </blockquote>
      </blockquote>
      <h3>&nbsp;</h3>
      <h3>Completion Codes</h3>
      <blockquote>
         <p>0 - processing has completed successfully.&nbsp; No mismatches have been
            found.<br>
            4 - processing has completed successfully.&nbsp; At least one mismatch has
            been found.<br>
            12 - processing has failed.&nbsp; A memory shortage has occurred.<br>
            16 - processing has aborted.&nbsp; One of the comparison files (OLD or NEW) is
            not available.
         </p>
      </blockquote>
      <h3>&nbsp;</h3>
      <h3>Program Parameter (PARM= on EXEC statement)</h3>
      <blockquote>
         <p>By default CMPRSEQ compares the records of the two input datasets on
            columns 1 through 72.&nbsp; By specifying a PARM='FULL' on the EXEC statement,
            CMPRSEQ may be directed to perform the comparison on columns 1 through 80.
         </p>
      </blockquote>
      <h3>&nbsp;</h3>
      <h3>Control Statements</h3>
      <blockquote>
         <p>There are no control statements for CMPRSEQ.</p>
      </blockquote>
      <h3>&nbsp;</h3>
      <h3>Examples</h3>
      <blockquote>
         <table width="75%" cellspacing="1" border="1">
            <tbody><tr>
               <td width="33%">
                  <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="CMPRSEQj01"></a>Compare
                     members of two partitioned datasets
               </p></td>
            </tr>
            <tr>
               <td width="33%">
                  <pre><b>//CMPRSEQ  JOB (1),'COMPARE MEMBERS',CLASS=A,MSGCLASS=X                                         
//CMPRSEQ  EXEC PGM=CMPRSEQ,REGION=1024K PARM=FULL  DEFAULT=1,72  
//SYSPRINT DD  SYSOUT=*                                           
//OLD      DD  DISP=SHR,DSN=SYS1.MACLIB(YREGS)                      
//NEW      DD  DISP=SHR,DSN=SYSP.MACLIB(YREGS)
//OLDLIST  DD  SYSOUT=*                                           
//NEWLIST  DD  SYSOUT=*                                           
//IGNORE   DD  *                                                  
//SYNC     DD  *                                                  
//</b></pre>
               </td>
            </tr>
         </tbody></table>
      </blockquote>
      <hr size="8" noshade="noshade">
      <h2><a name="COPYMODS"></a>COPYMODS <font size="2">[written by Paul Tokheim, located in
         SYSC.LINKLIB]</font>
      </h2>
      <p>Used to copy all files of an input tape onto 1 to 16 output tapes.&nbsp; The
         original purpose of this program was for copying the SHARE MVS MODs tape, but if
         you have any need for copying (or recovering data from) a tape, you probably
         should see if COPYMODS will solve your problem.&nbsp; COPYMODS
         was written by Paul Tokheim, but has been heavily modified and is now maintained
         by Sam Golob.&nbsp; The source may be found on CBT Tape File #229.&nbsp;
         COPYMODS requires the following DD statements:
      </p>
      <ul>
         <li>SYSPRINT - defines a sequential output message dataset.</li>
         <li>SYSIN - defines a sequential input dataset that contains COPYMODS option statements.</li>
         <li>IN - defines the input tape volume.</li>
         <li>OUT1 through OUT16 - defines the output tape volume(s).</li>
         <li>LABLDUMP - (optional) defines the sequential output dataset to hold label
            sets copied from IN.
         </li>
         <li>LABADDIN - (optional) defines the sequential input dataset holding label
            sets to insert in OUT1 (through OUT16).
         </li>
         <li>PARMREPT - (optional) defines the sequential output message dataset to
            receive diagnostic output from PARMCHEK.
         </li>
      </ul>
      <h3>&nbsp;</h3>
      <h3>Program Parameter (PARM= on EXEC statement)</h3>
      <blockquote>
         <p>COPYMODS will accept many of its options as keywords in the PARM parameter, but if you
            code SYSIN as the only keyword, all options will be read from the SYSIN
            DD.&nbsp; If an option is supplied both by PARM and SYSIN, the SYSIN version takes
            precedence.
         </p>
         <p>PARM may be omitted if a SYSIN DD is provided; the presence of the SYSIN DD
            sets the PARM=SYSIN option on.
         </p>
      </blockquote>
      <p>&nbsp;</p>
      <h3>Control Statements</h3>
      <blockquote>
         <hr color="#808080">
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="13%" height="22">
                  <pre><a name="COPYMODScopyltm">COPYLTM</a> | SKIPLTM</pre>
               </td>
               <td width="87%" height="22">
                  <pre></pre>
               </td>
            </tr>
         </tbody></table>
         <p>If COPYLTM is coded, leading tape marks on the input tape are copied to the
            output tape(s).&nbsp; If SKIPLTM is coded, leading tape marks on the input tape
            are skipped.&nbsp; The default is COPYLTM.&nbsp; LTMCOPY is a synonym for
            COPYLTM.
         </p>
         <hr color="#808080">
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="13%" height="22">
                  <pre><a name="COPYMODSlblinfo"></a>LBLINFO | NOLABL</pre>
               </td>
               <td width="87%" height="22">
                  <pre></pre>
               </td>
            </tr>
         </tbody></table>
         <p>If LBLINFO is coded, information from all standard labels will be
            printed.&nbsp; If NOLABL is coded, no label information will be printed.&nbsp;
            The default is NOLABL.&nbsp; PRINTL and LABELS are synonyms for LBLINFO; NOLABEL
            is a synonym for NOLABL.
         </p>
         <hr color="#808080">
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="13%" height="22">
                  <pre><a name="COPYMODShdr1"></a>HDR1 | NOHDR1</pre>
               </td>
               <td width="87%" height="22">
                  <pre></pre>
               </td>
            </tr>
         </tbody></table>
         <p>If HDR1 is coded, HDR1 labels will be printed.&nbsp; If NOHDR1 is coded, HDR1
            labels will not be printed.
         </p>
         <hr color="#808080">
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="13%" height="22">
                  <pre><a name="COPYMODShdr2"></a>HDR2 | NOHDR2</pre>
               </td>
               <td width="87%" height="22">
                  <pre></pre>
               </td>
            </tr>
         </tbody></table>
         <p>If HDR2 is coded, HDR2 labels will be printed.&nbsp; If NOHDR2 is coded, HDR2
            labels will not be printed.
         </p>
         <hr color="#808080">
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="13%" height="22">
                  <pre><a name="COPYMODSeof1"></a>EOF1 | NOEOF1</pre>
               </td>
               <td width="87%" height="22">
                  <pre></pre>
               </td>
            </tr>
         </tbody></table>
         <p>If EOF1 is coded, EOF1 labels will be printed.&nbsp; If NOEOF1 is coded, EOF1
            labels will not be printed.
         </p>
         <hr color="#808080">
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="13%" height="22">
                  <pre><a name="COPYMODSeof2"></a>EOF2 | NOEOF2</pre>
               </td>
               <td width="87%" height="22">
                  <pre></pre>
               </td>
            </tr>
         </tbody></table>
         <p>If EOF2 is coded, EOF2 labels will be printed.&nbsp; If NOEOF2 is coded, EOF2
            labels will not be printed.
         </p>
         <hr color="#808080">
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="13%" height="22">
                  <pre><a name="COPYMODSeov1"></a>EOV1 | NOEOV1</pre>
               </td>
               <td width="87%" height="22">
                  <pre></pre>
               </td>
            </tr>
         </tbody></table>
         <p>If EOV1 is coded, EOV1 labels will be printed.&nbsp; If NOEOV1 is coded, EOV1
            labels will not be printed.
         </p>
         <hr color="#808080">
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="13%" height="22">
                  <pre><a name="COPYMODSeov2"></a>EOV2 | NOEOV2</pre>
               </td>
               <td width="87%" height="22">
                  <pre></pre>
               </td>
            </tr>
         </tbody></table>
         <p>If EOV2 is coded, EOV2 labels will be printed.&nbsp; If NOEOV2 is coded, EOV2
            labels will not be printed.
         </p>
         <hr color="#808080">
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="13%" height="22">
                  <pre><a name="COPYMODShdrs"></a>HDRS | NOHDRS</pre>
               </td>
               <td width="87%" height="22">
                  <pre></pre>
               </td>
            </tr>
         </tbody></table>
         <p>If HDRS is coded, all HDR labels will be printed.&nbsp; If NOHDRS1 is coded,
            HDR labels will not be printed.
         </p>
         <hr color="#808080">
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="13%" height="22">
                  <pre><a name="COPYMODSeofs"></a>EOFS | NOEOFS</pre>
               </td>
               <td width="87%" height="22">
                  <pre></pre>
               </td>
            </tr>
         </tbody></table>
         <p>If EOFS is coded, all EOF labels will be printed.&nbsp; If NOEOFS1 is coded,
            EOF labels will not be printed.
         </p>
         <hr color="#808080">
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="13%" height="22">
                  <pre><a name="COPYMODSeovs"></a>EOVS | NOEOVS</pre>
               </td>
               <td width="87%" height="22">
                  <pre></pre>
               </td>
            </tr>
         </tbody></table>
         <p>If EOVS is coded, all EOV labels will be printed.&nbsp; If NOEOVS1 is coded,
            EOV labels will not be printed.
         </p>
         <hr color="#808080">
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="13%" height="22">
                  <pre><a name="COPYMODSchgvol"></a>CHGVOL | NOCHGVOL</pre>
               </td>
               <td width="87%" height="22">
                  <pre></pre>
               </td>
            </tr>
         </tbody></table>
         <p>If CHGVOL is coded, the VOLSER on the output tape(s) will be changed to the
            serial coded in JCL.&nbsp; If NOCHGVOL is coded, the VOLSER on the output tape(s)
            will not be changed.&nbsp; JCLVOL and NEWVOL are synonyms for CHGVOL; NOJCLVOL
            and NONEWVOL are synonyms for NOCHGVOL.
         </p>
         <hr color="#808080">
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="13%" height="22">
                  <pre><a name="COPYMODSvollbl"></a>VOLLBL | NOVOLLBL</pre>
               </td>
               <td width="87%" height="22">
                  <pre></pre>
               </td>
            </tr>
         </tbody></table>
         <p>If VOLLBL is coded, the VOL1 label will be printed.&nbsp; If NOVOLLBL is
            coded, the VOL1 label will not be printed.&nbsp; The default is NOVOLLBL.
         </p>
         <hr color="#808080">
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="13%" height="22">
                  <pre><a name="COPYMODSeov2eof"></a>EOV2EOF | NOEOVCHG</pre>
               </td>
               <td width="87%" height="22">
                  <pre></pre>
               </td>
            </tr>
         </tbody></table>
         <p>If EOV2EOF is coded, the EOV label will be changed to EOF.&nbsp; If NOEOVCHG
            is coded, the EOV label is not converted.&nbsp; The default is NOEOVCHG.&nbsp;
            EOVTOEOF and EOVCHG are synonyms for EOV2EOF.
         </p>
         <hr color="#808080">
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="13%" height="22">
                  <pre><a name="COPYMODSread"></a>READ | WRITE</pre>
               </td>
               <td width="87%" height="22">
                  <pre></pre>
               </td>
            </tr>
         </tbody></table>
         <p>If READ is coded, the input tape will be read, but no output tape(s) will be
            written.&nbsp; If WRITE is coded, the output tape(s) will be written.&nbsp; The
            default is WRITE.&nbsp; READONLY and NOWRITE are synonyms for READ.
         </p>
         <hr color="#808080">
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="13%" height="22">
                  <pre><a name="COPYMODSlabldump"></a>LABLDUMP | NOLABELD</pre>
               </td>
               <td width="87%" height="22">
                  <pre></pre>
               </td>
            </tr>
         </tbody></table>
         <p>If LABLDUMP is coded, all standard labels will be written to LABLDUMP
            DD.&nbsp; If NOLABELD is coded, standard labels will not be written to LABLDUMP.&nbsp;
            The default is NOLABELD.
         </p>
         <hr color="#808080">
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="13%" height="22">
                  <pre><a name="COPYMODSsysin"></a>SYSIN | NOSYSIN</pre>
               </td>
               <td width="87%" height="22">
                  <pre></pre>
               </td>
            </tr>
         </tbody></table>
         <p>If SYSIN is coded, other options will be read from SYSIN DD.&nbsp; If NOSYSIN
            is coded, options are not read from SYSIN.&nbsp; The default is NOSYSIN, except
            if a SYSIN DD card is supplied, SYSIN becomes the default.
         </p>
         <hr color="#808080">
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="13%" height="22">
                  <pre><a name="COPYMODSoutvolall"></a>OUTVOLALL=volser</pre>
               </td>
               <td width="87%" height="22">
                  <pre></pre>
               </td>
            </tr>
         </tbody></table>
         <p>If OUTVOLALL is coded, the VOLSER on the output tape(s) will be changed to
            volser.
         </p>
         <hr color="#808080">
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="13%" height="22">
                  <pre><a name="COPYMODStapeowner"></a>TAPEOWNER=ownerid</pre>
               </td>
               <td width="87%" height="22">
                  <pre></pre>
               </td>
            </tr>
         </tbody></table>
         <p>If TAPEOWNER is coded, the owner field on the output tape(s) will be changed
            to ownerid.
         </p>
         <hr color="#808080">
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="13%" height="22">
                  <pre><a name="COPYMODSlabaddin"></a>LABADDIN</pre>
               </td>
               <td width="87%" height="22">
                  <pre></pre>
               </td>
            </tr>
         </tbody></table>
         <p>If LABADDIN is coded, label sets will be read from LABADDIN DD and merged
            with the data files read from an unlabeled input tape to create standard labels
            on the output tape(s).
         </p>
         <hr color="#808080">
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="13%" height="22">
                  <pre><a name="COPYMODSblkcnt"></a>BLKCNT | NOBLKCNT</pre>
               </td>
               <td width="87%" height="22">
                  <pre></pre>
               </td>
            </tr>
         </tbody></table>
         <p>If BLKCNT is coded with LABADDIN, EOF1/EOV1 block counts will be corrected on
            the output tape(s).&nbsp; If NOBLKCNT is coded, block counts in EOF1/EOV1 labels
            will not be changed.&nbsp; The default is BLKCNT.
         </p>
         <hr color="#808080">
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="13%" height="22">
                  <pre><a name="COPYMODSpraddlbl"></a>PRADDLBL | NOPRADDL</pre>
               </td>
               <td width="87%" height="22">
                  <pre></pre>
               </td>
            </tr>
         </tbody></table>
         <p>If PRADDLBL is coded, labels created with LABADDIN will be printed.&nbsp; If
            NOPRADDL is coded, labels created with LABADDIN will not be printed.&nbsp;
         </p>
         <hr color="#808080">
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="13%" height="22">
                  <pre><a name="COPYMODScorrblks"></a>CORRBLKS</pre>
               </td>
               <td width="87%" height="22">
                  <pre></pre>
               </td>
            </tr>
         </tbody></table>
         <p>If CORRBLKS is coded, EOF1/EOV1 block counts will be corrected on the output
            tape(s).&nbsp;
         </p>
         <hr color="#808080">
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="13%" height="22">
                  <pre><a name="COPYMODSexnull"></a>EXNULL | NOEXNULL</pre>
               </td>
               <td width="87%" height="22">
                  <pre></pre>
               </td>
            </tr>
         </tbody></table>
         <p>If EXNULL is coded, with LABADDIN, null standard labels sets will be added at
            end of tape if the input unlabeled tape runs out of files.&nbsp; If NOEXNULL is
            coded, adding labels will stop at end of the input tape.&nbsp; SLNULL is a synonum for EXNULL.&nbsp;
            NOSLNULL is a synonum for NOEXNULL.&nbsp;
         </p>
         <hr color="#808080">
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="13%" height="22">
                  <pre><a name="COPYMODSlblfix"></a>LBLFIX | NOLBLFIX</pre>
               </td>
               <td width="87%" height="22">
                  <pre></pre>
               </td>
            </tr>
         </tbody></table>
         <p>If LBLFIX is coded, with LABADDIN, fix missing EOF labels.&nbsp; If NOLBLFIX
            is coded, missing EOF labels will not be fixed.&nbsp;
         </p>
         <hr color="#808080">
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="13%" height="22">
                  <pre><a name="COPYMODSinitvols"></a>INITVOLS</pre>
               </td>
               <td width="87%" height="22">
                  <pre></pre>
               </td>
            </tr>
         </tbody></table>
         <p>If INITVOLS is coded, the output tape volumes will be initialized without an
            input tape volume.&nbsp; Code OUTVOLALL=serial and TAPEOWNER=owner and all
            output tapes will be initialized identically.&nbsp;
         </p>
         <hr color="#808080">
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="13%" height="22">
                  <pre><a name="COPYMODSbytes"></a>BYTES</pre>
               </td>
               <td width="87%" height="22">
                  <pre></pre>
               </td>
            </tr>
         </tbody></table>
         <p>If BYTES is coded, bytes read from all the files on the input tape will be
            counted.
         </p>
         <hr color="#808080">
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="13%" height="22">
                  <pre><a name="COPYMODScumtot"></a>CUMTOT | CUMSEP</pre>
               </td>
               <td width="87%" height="22">
                  <pre></pre>
               </td>
            </tr>
         </tbody></table>
         <p>If CUMTOT is coded, a running total of bytes counted and reported for all the
            files read from the input tape.&nbsp; At the end of the input tape, total bytes
            are broken into:&nbsp; grand total, bytes read from labels, and bytes from
            files.&nbsp; If you code CUMSEP the total label bytes are cumulatively reported
            separately from the cumulative data bytes.
         </p>
         <hr color="#808080">
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="13%" height="22">
                  <pre><a name="COPYMODSfilelimit"></a>FILELIMIT=nnn</pre>
               </td>
               <td width="87%" height="22">
                  <pre></pre>
               </td>
            </tr>
         </tbody></table>
         <p>If FILELIMIT is coded, the number of files copied from the input tape is
            limited to the number specified in nnn.&nbsp; For a standard label input tape,
            the number entered for nnn will be multiplied by 3 to compensate for the
            labels.&nbsp; The adjustment of nnn may be forced by coding option SLLIM for
            standard label volumes and NLLIM for unlabled volumes.
         </p>
         <hr color="#808080">
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="13%" height="22">
                  <pre><u><a name="COPYMODSlabelimit"></a>LABELIMIT</u>=nnn</pre>
               </td>
               <td width="87%" height="22">
                  <pre></pre>
               </td>
            </tr>
         </tbody></table>
         <p>If LABELIMIT is coded, the number of label sets copied from the LABADDIN DD
            is limited to the number specified in nnn.
         </p>
         <hr color="#808080">
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="13%" height="22">
                  <pre><a name="COPYMODSrecsize"></a>RECSIZE</pre>
               </td>
               <td width="87%" height="22">
                  <pre></pre>
               </td>
            </tr>
         </tbody></table>
         <p>If RECSIZE is coded, the detailed block size of every block in every file
            read from the input tape volume will be displayed.&nbsp; Coding RECSIZE
            automatically produces the MINMAX option.
         </p>
         <hr color="#808080">
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="13%" height="22">
                  <pre><a name="COPYMODSminmax"></a>MINMAX | NOMINMAX</pre>
               </td>
               <td width="87%" height="22">
                  <pre></pre>
               </td>
            </tr>
         </tbody></table>
         <p>If MINMAX is coded, the minimum and maximum block size of every file read
            from the input tape volume will be displayed.&nbsp; Coding NOMINMAX turns off
            this display.
         </p>
         <hr color="#808080">
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="13%" height="22">
                  <pre><a name="COPYMODSprintrcds"></a>PRINTRCDS=nnn</pre>
               </td>
               <td width="87%" height="22">
                  <pre></pre>
               </td>
            </tr>
         </tbody></table>
         <p>If PRINTRCDS is coded, the number of records to print at the beginning of
            each tape file, turned on by the HEXPRT option, is specified by nnn.&nbsp; The default for n is 4.
         </p>
         <hr color="#808080">
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="13%" height="22">
                  <pre><a name="COPYMODShexprt"></a>HEXPRT</pre>
               </td>
               <td width="87%" height="22">
                  <pre></pre>
               </td>
            </tr>
         </tbody></table>
         <p>If HEXPRT is coded, the first 132 bytes of the first n records in each file
            are printed in HEX and EBCDIC.&nbsp; The value of n is set by the PRINTRCDS
            option and the default value is 4.
         </p>
         <hr color="#808080">
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="13%" height="22">
                  <pre><a name="COPYMODSstrip"></a>STRIP</pre>
               </td>
               <td width="87%" height="22">
                  <pre></pre>
               </td>
            </tr>
         </tbody></table>
         <p>If STRIP is coded, standard labels are not copied from the input tape file
            onto the output tape(s); the output tape(s) are unlabeled.
         </p>
         <hr color="#808080">
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="13%" height="22">
                  <pre><a name="COPYMODSidrcoff"></a>IDRCOFF</pre>
               </td>
               <td width="87%" height="22">
                  <pre></pre>
               </td>
            </tr>
         </tbody></table>
         <p>If IDRCOFF is coded, a virtual device on AWS format tapes is handled as
            non-compressed.
         </p>
         <hr color="#808080">
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="13%" height="22">
                  <pre><a name="COPYMODSsecoff"></a>SECOFF</pre>
               </td>
               <td width="87%" height="22">
                  <pre></pre>
               </td>
            </tr>
         </tbody></table>
         <p>If SECOFF is coded, the security indicators in tape labels for the output
            tape(s) are turned off.
         </p>
         <hr color="#808080">
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="13%" height="22">
                  <pre><a name="COPYVOLSfootage"></a>FOOTAGE</pre>
               </td>
               <td width="87%" height="22">
                  <pre></pre>
               </td>
            </tr>
         </tbody></table>
         <p>If FOOTAGE is coded, the estimate tape size, at 6250 BPI, is calculated and
            reported.
         </p>
         <hr color="#808080">
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="13%" height="22">
                  <pre><a name="COPYMODSkeepvol"></a>KEEPVOL</pre>
               </td>
               <td width="87%" height="22">
                  <pre></pre>
               </td>
            </tr>
         </tbody></table>
         <p>If KEEPVOL is coded, an existing VOL1 label on an output tape will be
            retained.
         </p>
         <hr color="#808080">
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="13%" height="22">
                  <pre><a name="COPYMODSshoovl"></a>SHOOVL</pre>
               </td>
               <td width="87%" height="22">
                  <pre></pre>
               </td>
            </tr>
         </tbody></table>
         <p>If SHOOVL is coded, in combination with READ, COPYMODS will do a dry run to
            show you the results of a future copy.
         </p>
         <p>&nbsp;</p>
      </blockquote>
      <h3>Examples</h3>
      <blockquote>
         <table width="75%" cellspacing="1" border="1">
            <tbody><tr>
               <td width="33%">
                  <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="COPYMODSj01"></a>Copy
                     tape to 3 output tapes, SL output, change VOL1s
               </p></td>
            </tr>
            <tr>
               <td width="33%">
                  <pre><b>//COPYMODS JOB (001),'COPYMODS-1',CLASS=A,MSGCLASS=X                 
//COPYMODS EXEC PGM=COPYMODS,REGION=4096K,PARM='SYSIN'               
//SYSPRINT DD  SYSOUT=*                                              
//IN    DD VOL=SER=157806,DISP=SHR,UNIT=TAPE,LABEL=(,BLP,EXPDT=98000)
//OUT1  DD VOL=SER=022101,DISP=OLD,UNIT=TAPE,LABEL=(,SL,EXPDT=98000) 
//OUT2  DD VOL=SER=022102,DISP=OLD,UNIT=TAPE,LABEL=(,SL,EXPDT=98000) 
//OUT3  DD VOL=SER=022103,DISP=OLD,UNIT=TAPE,LABEL=(,SL,EXPDT=98000) 
//SYSIN DD *                                                         
CHGVOL                                                               
CUMTOT                                                               
LABELS                                                               
TAPEOWNER=HERCULES                                                   
BYTES                                                                
MINMAX                                                               
SHOOVL                                                               
FOOTAGE                                                              
//                                                                   </b></pre>
               </td>
            </tr>
            <tr>
               <td width="33%">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="COPYMODSj02"></a>Simulate
                  copy, print input tape information
               </td>
            </tr>
            <tr>
               <td width="33%">
                  <pre><b>//COPYMODS JOB (001),'COPYMODS-1',CLASS=A,MSGCLASS=X                  
//COPYMODS EXEC PGM=COPYMODS,REGION=4096K,PARM='SYSIN'                
//SYSPRINT DD  SYSOUT=*                                               
//IN    DD VOL=SER=22013C,DISP=SHR,UNIT=TAPE,LABEL=(,BLP,EXPDT=98000) 
//OUT1  DD VOL=SER=022301,DISP=OLD,UNIT=TAPE,LABEL=(,SL,EXPDT=98000)  
//SYSIN DD *                                                          
CHGVOL                                                                
CUMTOT                                                                
LABELS                                                                
TAPEOWNER=HERCULES                                                    
BYTES                                                                 
MINMAX                                                                
READ                                                                  
FOOTAGE                                                               
//                                                                    </b></pre>
               </td>
            </tr>
         </tbody></table>
      </blockquote>
      <hr size="8" noshade="noshade">
      <h2><a name="DSSDUMP"></a>DSSDUMP <font size="2">[written by Gerhard Postpischil, located in SYSC.LINKLIB]</font></h2>
      <p>Used for creating a backup sequential dataset containing the contents of one
         or more DASD datasets.&nbsp; The output dataset may be written to a tape image
         or to a DASD dataset.&nbsp; DSSDUMP backup datasets are equivalent to those
         produced by ADRDSSU, which is a licensed program used under z/OS.&nbsp; DSSDUMP
         was written by Gerhard Postpischil and the source may be found on CBT Tape File
         #860.&nbsp; DSSDUMP requires the following DD statements:
      </p>
      <ul>
         <li>SYSPRINT - defines a sequential output message dataset.</li>
         <li>SYSIN - defines a sequential input dataset that contains DSSDUMP control
            statements.
         </li>
         <li>TAPE - defines the sequential output dataset that will contain the backup
            set, in DSS format, uncompressed.
         </li>
      </ul>
      <blockquote>
         <p>RECFM=U<br>
            For tape device output: 65520 is the default BLKSIZE; 7892&lt;block size&lt;65520 is
            supported, RECFM=V  is supported, with blocks 7900&lt;block size&lt;32760.<br>
            For DASD device output: the default BLKSIZE=track size, if &gt;=7892 or the
            half-track size for modulo devices; the supported range is 7892&lt;data
            size&lt;32760.
         </p>
      </blockquote>
      <h3>&nbsp;</h3>
      <h3>Control Statements</h3>
      <blockquote>
         <hr color="#808080">
         <table width="50%" height="113" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="13%" height="22">
                  <pre><a name="DSSDUMPoptions"></a>OPTIONS</pre>
               </td>
               <td width="87%" height="22">
                  <pre>[{ENQ | NOENQ}]</pre>
               </td>
            </tr>
            <tr>
               <td width="13%" height="22">
                  <pre></pre>
               </td>
               <td width="87%" height="22">
                  <pre>[,TEST]</pre>
               </td>
            </tr>
            <tr>
               <td width="13%" height="25">
                  <pre></pre>
               </td>
               <td width="87%" height="25">
                  <pre>[,{ALLDATA | ALLEXCP}]</pre>
               </td>
            </tr>
            <tr>
               <td width="13%" height="22">
                  <pre></pre>
               </td>
               <td width="87%" height="22">
                  <pre>[,EXPORT]</pre>
               </td>
            </tr>
            <tr>
               <td width="13%" height="22">
                  <pre></pre>
               </td>
               <td width="87%" height="22">
                  <pre>[,{LIST | SHOW}]</pre>
               </td>
            </tr>
         </tbody></table>
         <p>The OPTIONS control statement specifies one or more options, separated by commas.&nbsp; The OPTIONS
            statement may appear anywhere in the stream of control statements.&nbsp; The
            parameters are:
         </p>
         <blockquote>
            <p>ENQ | NOENQ</p>
            <blockquote>
               <p>If ENQ is specified, DSSDUMP issues an exclusive ENQ TEST for each dataset.&nbsp;
                  Dump continues if the dataset is not available, and issues RC=4.&nbsp; Applies from prior DUMP
                  until end-of-job.&nbsp; If NOENQ is specified, which is the default if neither
                  ENQ or NOENQ is specified, each dataset is written to the output dataset as is.
               </p>
            </blockquote>
            <p>TEST</p>
            <blockquote>
               <p>If TEST is specified, DSSDUMP bypasses all TAPE output.&nbsp; Note that file has
                  been opened already, and will be empty.&nbsp;
               </p>
            </blockquote>
            <p>ALLDATA | ALLEXCP</p>
            <blockquote>
               <p>If ALLDATA or ALLEXCP, which are synonyms, is 
specified, DSSDUMP writes
                  all tracks, including unused ones, to be written to 
the output dataset.&nbsp;
                  This option may be needed to recover from invalid, 
non-zero LSTAR.&nbsp; This option also preserves LABEL=SUL data.&nbsp;
               </p>
            </blockquote>
            <p>EXPORT</p>
            <blockquote>
               <p>If EXPORT is specified, DSSDUMP modifies the output DSCB1 by removing any expiration date and password flags.&nbsp;</p>
            </blockquote>
            <p>LIST | SHOW</p>
            <blockquote>
               <p>If LIST or SHOW, which are synonyms, is specified, DSSDUMP will write the current OPTION settings
                  to the message dataset.
               </p>
            </blockquote>
         </blockquote>
         <hr color="#808080">
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="21%" height="22">
                  <pre><a name="DSSDUMPinclude"></a>INCLUDE | DUMP</pre>
               </td>
               <td width="79%" height="22">
                  <pre>mask</pre>
               </td>
            </tr>
            <tr>
               <td width="21%" height="22">
                  <pre></pre>
               </td>
               <td width="79%" height="22">
                  <pre>[VOLUME(serial)]</pre>
               </td>
            </tr>
         </tbody></table>
         <p>The INCLUDE or DUMP control statement - DUMP and INCLUDE are synonyms -&nbsp;
            specifies which datasets are selected to
            be written to the backup set.&nbsp; The INCLUDE or DUMP control statement occurs
            one or more times for each execution of DSSDUMP.&nbsp; The parameters are:
         </p>
         <blockquote>
            <p>mask</p>
            <blockquote>
               <p>Specifies either a single dataset name, unquoted, or provides a mask which
                  may match one or more datasets.&nbsp; A mask ending in a period (.) is treated
                  as a mask followed by an implied double asterisk (**).&nbsp; In MVS (VSAM catalog), the first index level
                  may not contain a mask character.&nbsp; Also note that VSAM catalog processing does not support
                  detection or processing of alias entries.&nbsp;&nbsp;
               </p>
               <p>
                  A percent sign (%) is treated as a positional mask (one to one correspondence of characters/mask to
                  dataset name).&nbsp; Any number of DUMP cards may be used in a run but only about 700 datasets will fit in the
                  name table (which is an assembly time option).
               </p>
               <p> Masking bytes are
                  valid in any position in the mask.&nbsp;
               </p>
            </blockquote>
            <p>VOLUME(serial)</p>
            <blockquote>
               <p>Specifies inclusion of matching datasets on the specified VOLUME SERIAL only.&nbsp;
                  If this results in duplicate dataset names, a .D#nnnnnn is appended to duplicates on higher volume
                  serials (i.e., the cataloged entry may be the  one that gets renamed).&nbsp;&nbsp;
               </p>
            </blockquote>
         </blockquote>
         <hr color="#808080">
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="13%" height="22">
                  <pre><a name="DSSDUMPexclude"></a>EXCLUDE</pre>
               </td>
               <td width="87%" height="22">
                  <pre>mask</pre>
               </td>
            </tr>
         </tbody></table>
         <p>The EXCLUDE control statement allows for excluding matching datasets which have been selected by a
            preceding DUMP or INCLUDE control statement.&nbsp; The parameter is:
         </p>
         <blockquote>
            <p>mask</p>
            <blockquote>
               <p>Specifies either a single dataset name, unquoted, or provides a mask which
                  may match one or more datasets.&nbsp; A mask ending in a period (.) is treated
                  as a mask followed by an implied double asterisk (**).&nbsp; In MVS (VSAM catalog), the first index level
                  may not contain a mask character.&nbsp; Also note that VSAM catalog processing does not support
                  detection or processing of alias entries.&nbsp;&nbsp;
               </p>
               <p>
                  A percent sign (%) is treated as a positional mask (one to one correspondence of characters/mask to
                  dataset name).&nbsp; Any number of DUMP cards may be used in a run but only about 700 datasets will fit in the
                  name table (which is an assembly time option).
               </p>
               <p> Masking bytes are
                  valid in any position in the mask.&nbsp;
               </p>
            </blockquote>
         </blockquote>
         <hr color="#808080">
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="11%" height="22">
                  <pre><a name="DSSDUMPprefix"></a>PREFIX</pre>
               </td>
               <td width="89%" height="22">
                  <pre>string</pre>
               </td>
            </tr>
         </tbody></table>
         <p>The PREFIX control statement causes all dataset names to be 
prefixed by the specified text string. It is not required
            to be an index level (e.g., SYS9.), but if not, generated 
names may be syntactically
            invalid.&nbsp; Result names are truncated to 
44&nbsp;characters, and a trailing period is blanked.&nbsp; Only one 
PREFIX card may be used per
            execution, and it is mutually exclusive of RENAME and STRIP 
options.&nbsp;
         </p>
         <hr color="#808080">
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="11%" height="22">
                  <pre><a name="DSSDUMPstrip"></a>STRIP</pre>
               </td>
               <td width="89%" height="22">
                  <pre>string</pre>
               </td>
            </tr>
         </tbody></table>
         <p>The STRIP control statement specifies that the specified string is removed from any dataset name where it is found.&nbsp;
            Multiple STRIP and RENAME requests are supported (up to 16; which is an assembly
            time option).
         </p>
         <hr color="#808080">
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="11%" height="22">
                  <pre><a name="DSSDUMPrename"></a>RENAME</pre>
               </td>
               <td width="89%" height="22">
                  <pre>oldname</pre>
               </td>
            </tr>
            <tr>
               <td width="11%" height="22">
                  <pre></pre>
               </td>
               <td width="89%" height="22">
                  <pre>newname</pre>
               </td>
            </tr>
         </tbody></table>
         <p>The RENAME control statement specifies that wherever oldname is found in a
            selected dataset name it is to be replaced by
            newname.&nbsp; Up to 16 combined RENAME and STRIP requests are legal.&nbsp; All strings in PREFIX/RENAME/STRIP are
            limited to 23 characters (which is an assembly time option).&nbsp;
         </p>
      </blockquote>
      <h3>&nbsp;</h3>
      <h3>Examples</h3>
      <blockquote>
         <table width="75%" cellspacing="1" border="1">
            <tbody><tr>
               <td width="33%">
                  <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="DSSDUMPj01"></a>Run
                     a test (simulation) dump
               </p></td>
            </tr>
            <tr>
               <td width="33%">
                  <pre><b>//DSSDUMP  JOB (SYS),'DSSDUMP',CLASS=S,MSGCLASS=X                   
//DSSDUMP  EXEC PGM=DSSDUMP,REGION=4096K                            
//SYSPRINT  DD SYSOUT=*                                             
//SYSIN     DD *   
  OPTIONS TEST                                                 
  DUMP HMVS01.**  
  DUMP HMVS02.CNTL                    
//TAPE      DD DSN='DUMP.HMVS.USERS.DATA',
//             UNIT=(TAPE,,DEFER),DISP=(NEW,KEEP),
//             DCB=(LRECL=18448,BLKSIZE=18452,RECFM=V)
//</b></pre>
               </td>
            </tr>
            <tr>
               <td width="33%">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="DSSDUMPj02"></a>Dump
                  a dataset, substituting new HLQ on backup set
               </td>
            </tr>
            <tr>
               <td width="33%">
                  <pre><b>//DSSDUMP  JOB (SYS),'DSSDUMP',CLASS=S,MSGCLASS=X
//DSSDUMP  EXEC PGM=DSSDUMP,REGION=4096K
//STEPLIB   DD DSN=SYSC.LINKLIB,DISP=SHR
//SYSPRINT  DD SYSOUT=*
//SYSIN     DD *
  DUMP HMVS01.STUDENT.DATA 
  RENAME HMVS01 HMVS02 
//TAPE      DD DSN='DUMP.HMVS.USERS.DATA',
//             UNIT=(TAPE,,DEFER),DISP=(NEW,KEEP),
//             DCB=(LRECL=18448,BLKSIZE=18452,RECFM=V)
//</b></pre>
               </td>
            </tr>
            <tr>
               <td width="33%">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="DSSDUMPj03"></a>Dump
                  two groups of datasets contained on one volume
               </td>
            </tr>
            <tr>
               <td width="33%">
                  <pre><b>//DSSDUMP  JOB (SYS),'DSSDUMP',CLASS=S,MSGCLASS=X    
//DSSDUMP  EXEC PGM=DSSDUMP,REGION=4096K             
//SYSPRINT  DD SYSOUT=*                              
//SYSIN     DD *                                     
  DUMP GCC.** VOLUME(SYSCPK)                         
  DUMP PDPCLIB.** VOLUME(SYSCPK)                     
//TAPE      DD DSN='DUMP.GCCMVS',                    
//             UNIT=(TAPE,,DEFER),DISP=(NEW,KEEP)    </b><b>
//                                              </b></pre>
               </td>
            </tr>
         </tbody></table>
      </blockquote>
      <hr size="8" noshade="noshade">
      <h2><a name="DSSREST"></a>DSSREST <font size="2">[written by Charlie Brint,
         located in SYSC.LINKLIB]</font>
      </h2>
      <p>Used for restoring one or more datasets from a backup set created by DFDSS (ADRDSSU)
         or DSSDUMP.&nbsp; DSSREST
         was written by Charlie Brint and the source may be found on CBT Tape File
         #860.&nbsp; DSSREST requires the following DD statements:
      </p>
      <ul>
         <li>SYSPRINT - defines a sequential output message dataset.</li>
         <li>SYSUT1 - defines a sequential input dataset that contains a backup set in DSS format, uncompressed.</li>
         <li>REPORT - defines a sequental output dataset that will contain the details
            of the contents of the backup set.
         </li>
         <li>JCLOUT - defines a sequential output dataset that will contain skeleton JCL that,
            after customization, may be used to restore one or more datasets from the
            backup set.&nbsp; This DD is optional and, if omitted, a message will be
            written to the output message dataset and the skeleton JCL will not be
            produced.
         </li>
         <li>SYSUT2 - defines a model DD that will be used for each dataset restored.</li>
      </ul>
      <h3>&nbsp;</h3>
      <h3>Control Statements</h3>
      <blockquote>
         <p>There are no control statements for DSSREST.</p>
      </blockquote>
      <h3>&nbsp;</h3>
      <h3>Program Parameter (PARM= on EXEC statement)</h3>
      <blockquote>
         <p>If no PARM is specified, DSSREST will read the backup set and produce a
            report of the datasets contained in the backup set, and, if the JCLOUT DD is
            supplied, will write to the JCLOUT DD a set of skeleton JCL that may be used to
            restore one or more of the datasets contentained in the backup set.&nbsp; The
            parameters allowed are:&nbsp;
         </p>
         <p>DYNALLOC | DYNALLOC,prefix</p>
         <blockquote>
            <p>If DYNALLOC is specified alone, DSSREST will attempt to dynamically restore
               all datasets from the backup set.&nbsp; If DYNALLOC is specified with a prefix,
               DSSREST will attempt to dynamically restore all datasets from the backup set,
               but substitute the supplied prefix for the high level qualifier of each dataset
               in the backup set.
            </p>
         </blockquote>
         <p>* | single dataset name</p>
         <blockquote>
            <p>If the parameter supplied is a single asterisk (*) or a single dataset
               name, the JCL is expected to include the set of model SYSUT2 DDs generated
               by DSSREST executed with no PARM.
            </p>
            <p>If the parameter is an asterisk (*), DSSREST will attempt to restore all
               datasets from the backup set.&nbsp; There should be a SYSUT2 included for
               each dataset in the backup set, which DSSREST will use, in sequence, to
               allocate the output dataset to restore.&nbsp; Because the SYSUT2 DD
               statements are expected to be in the same sequence as the datasets contained
               in the backup set, it is recommended that you always use the generated
               skeleton JCL to restore an entire backup set.&nbsp; If you wish to restore
               only some of the datasets contained in the backup set, you should edit the
               skeleton JCL and comment out the SYSUT2 statements that correspond to the
               datasets in the backup set that you <b>do not wish to be restored</b>.
            </p>
            <p>If the parameter is the name of a single dataset in the backup set,
               DSSREST will use the model SYSUT2 DD to restore only the single dataset from
               the backup set.
            </p>
         </blockquote>
      </blockquote>
      <h3>&nbsp;</h3>
      <h3>Examples</h3>
      <blockquote>
         <table width="75%" cellspacing="1" border="1">
            <tbody><tr>
               <td width="33%">
                  <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="DSSRESTj01"></a>Read
                     backup set, generate report and restore JCL
               </p></td>
            </tr>
            <tr>
               <td width="33%">
                  <pre><b>//DSSREST  JOB (SYS),'DSSREST',CLASS=S,MSGCLASS=X  
//DSSREST  EXEC PGM=DSSREST,REGION=2048K,PARM=''   
//SYSPRINT  DD SYSOUT=*                            
//REPORT    DD SYSOUT=*                            
//JCLOUT    DD SYSOUT=*                            
//SYSUT1    DD DSN='DUMP.JAY01',                   
//             UNIT=TAPE,VOL=SER=21121A,DISP=OLD   </b><b>
//                     </b></pre>
               </td>
            </tr>
            <tr>
               <td width="33%">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="DSSRESTj02"></a>Restore
                  a single dataset from backup set
               </td>
            </tr>
            <tr>
               <td width="33%">
                  <pre><b>//DSSREST  JOB (SYS),'DSSREST',CLASS=S,MSGCLASS=X                       
//RESTORE EXEC PGM=DSSREST,REGION=8000K,TIME=1440,                      
//             PARM='JAY01.CNTL'                                        
//SYSPRINT DD  SYSOUT=*                                                 
//REPORT   DD  SYSOUT=*                                                 
//SYSUT1   DD  DISP=OLD,DSN=DUMP.JAY01,                                 
//             UNIT=TAPE,VOL=SER=(21121A),                              
//             LABEL=(1,SL)                                             
//*                                                                     
//SYSUT2 DD DSN=JAY01.CLIST,                                   /*50*/   
//          DISP=(,CATLG,DELETE),FREE=CLOSE,DCB=(DSORG=PO,              
//          RECFM=FB,LRECL=80,BLKSIZE=19040),                           
//          SPACE=(CYL,(1,1,1)),                                        
//          UNIT=3380 VOL=SER=PUB000                                    
//SYSUT2 DD DSN=JAY01.CNTL,                                    /*51*/   
//          DISP=(,CATLG,DELETE),FREE=CLOSE,DCB=(DSORG=PO,              
//          RECFM=FB,LRECL=80,BLKSIZE=23440),                           
//          SPACE=(CYL,(12,1,1)),                                       
//          UNIT=3380,VOL=SER=PUB000                                    
//SYSUT2 DD DSN=JAY01.EXEC,                                    /*52*/   
//          DISP=(,CATLG,DELETE),FREE=CLOSE,DCB=(DSORG=PO,              
//          RECFM=VB,LRECL=255,BLKSIZE=23460),                          
//          SPACE=(CYL,(3,1,1)),                                        
//          UNIT=3380 VOL=SER=PUB000                                    
//SYSUT2 DD DSN=JAY01.LOAD,                                    /*54*/   
//          DISP=(,CATLG,DELETE),FREE=CLOSE,DCB=(DSORG=PO,              
//          RECFM=U,BLKSIZE=19069),                                     
//          SPACE=(CYL,(3,1,1)),                                        
//          UNIT=3380 VOL=SER=PUB000                                    
//SYSUT2 DD DSN=JAY01.SOURCE,                                  /*59*/   
//          DISP=(,CATLG,DELETE),FREE=CLOSE,DCB=(DSORG=PO,              
//          RECFM=FB,LRECL=80,BLKSIZE=19040),                           
//          SPACE=(CYL,(6,1,1)),                                        
//          UNIT=3380 VOL=SER=PUB000                                    </b><b>
// </b></pre>
               </td>
            </tr>
            <tr>
               <td width="33%">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="DSSRESTj03"></a>Restore
                  more than one, but not all, datasets from backup set
               </td>
            </tr>
            <tr>
               <td width="33%">
                  <pre><b>//DSSREST  JOB (SYS),'DSSREST',CLASS=S,MSGCLASS=X                       
//RESTORE EXEC PGM=DSSREST,REGION=8000K,TIME=1440,                      
//             PARM='*'                                        
//SYSPRINT DD  SYSOUT=*                                                 
//REPORT   DD  SYSOUT=*                                                 
//SYSUT1   DD  DISP=OLD,DSN=DUMP.JAY01,                                 
//             UNIT=TAPE,VOL=SER=(21121A),                              
//             LABEL=(1,SL)                                             
//*                                                                     
//*SYSUT2 DD DSN=JAY01.CLIST,                                  /*50*/   
//          DISP=(,CATLG,DELETE),FREE=CLOSE,DCB=(DSORG=PO,              
//          RECFM=FB,LRECL=80,BLKSIZE=19040),                           
//          SPACE=(CYL,(1,1,1)),                                        
//          UNIT=3380,VOL=SER=PUB000                                    
//SYSUT2 DD DSN=JAY01.CNTL,                                    /*51*/   
//          DISP=(,CATLG,DELETE),FREE=CLOSE,DCB=(DSORG=PO,              
//          RECFM=FB,LRECL=80,BLKSIZE=23440),                           
//          SPACE=(CYL,(12,1,1)),                                       
//          UNIT=3380,VOL=SER=PUB000                                    
//*SYSUT2 DD DSN=JAY01.EXEC,                                   /*52*/   
//          DISP=(,CATLG,DELETE),FREE=CLOSE,DCB=(DSORG=PO,              
//          RECFM=VB,LRECL=255,BLKSIZE=23460),                          
//          SPACE=(CYL,(3,1,1)),                                        
//          UNIT=3380,VOL=SER=PUB000                                    
//*SYSUT2 DD DSN=JAY01.LOAD,                                   /*54*/   
//          DISP=(,CATLG,DELETE),FREE=CLOSE,DCB=(DSORG=PO,              
//          RECFM=U,BLKSIZE=19069),                                     
//          SPACE=(CYL,(3,1,1)),                                        
//          UNIT=3380,VOL=SER=PUB000                                    
//SYSUT2 DD DSN=JAY01.SOURCE,                                  /*59*/   
//          DISP=(,CATLG,DELETE),FREE=CLOSE,DCB=(DSORG=PO,              
//          RECFM=FB,LRECL=80,BLKSIZE=19040),                           
//          SPACE=(CYL,(6,1,1)),                                        
//          UNIT=3380,VOL=SER=PUB000                                    </b><b>
//                                              </b></pre>
               </td>
            </tr>
         </tbody></table>
      </blockquote>
      <hr size="8" noshade="noshade">
      <h2><a name="FIXDSCB"></a>FIXDSCB <font size="2">[written by David Alan Weaver, located in SYSC.LINKLIB]</font></h2>
      <p>Used for modification and repair of dataset control blocks (DSCBs).&nbsp;
         FIXDSCB
         was written by David Alan Weaver and the source may be found on CBT Tape File
         #566.&nbsp; FIXDSCB requires the following DD statements:
      </p>
      <ul>
         <li>SYSPRINT - defines a sequential output message dataset.</li>
         <li>SYSIN - defines a dataset input that contains FIXDSCB control
            statements.
         </li>
         <li>any DD name - defines the volume on which to find the dataset(s) for which
            the control blocks are to be modified.
         </li>
      </ul>
      <h3>&nbsp;</h3>
      <h3>Control Statements</h3>
      <blockquote>
         <hr color="#808080">
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="12%">
                  <pre><a name="FIXDSCBrename"></a>RENAME</pre>
               </td>
               <td width="88%">
                  <pre>VOLUME=volid</pre>
               </td>
            </tr>
            <tr>
               <td width="12%">
                  <pre></pre>
               </td>
               <td width="88%">
                  <pre>,DSNAME=current</pre>
               </td>
            </tr>
            <tr>
               <td width="12%">
                  <pre></pre>
               </td>
               <td width="88%">
                  <pre>,NEWNAME=new</pre>
               </td>
            </tr>
         </tbody></table>
         <p>The RENAME control statement alters the dataset name to the specified new name.&nbsp; The parameters are:</p>
         <blockquote>
            <p>VOLUME=volid</p>
            <blockquote>
               <p>Identifies the DASD Volume Serial number on which the dataset to be renamed
                  exists.&nbsp; VOLUME may be abbreviated VOL.
               </p>
            </blockquote>
            <p>DSNAME=current</p>
            <blockquote>
               <p>Specifies the one to forty-four character name of the dataset to be
                  modified.&nbsp; DSNAME may be abbreviated DSN.
               </p>
            </blockquote>
            <p>NEWNAME=new</p>
            <blockquote>
               <p>Specifies the one to forty-four character name which will be the new name of
                  the dataset.
               </p>
            </blockquote>
         </blockquote>
         <p>Note:&nbsp; When using this command, I have found that the resulting dataset
            is no longer catalogued.&nbsp; There are other methods available to rename a
            dataset, <b><font color="#0000FF">see IEHPROGM and PDSPROGM</font></b>.
         </p>
         <hr color="#808080">
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="12%">
                  <pre><a name="FIXDSCBprotect"></a>PROTECT</pre>
               </td>
               <td width="88%">
                  <pre>VOLUME=volid</pre>
               </td>
            </tr>
            <tr>
               <td width="12%">
                  <pre></pre>
               </td>
               <td width="88%">
                  <pre>,DSNAME=name</pre>
               </td>
            </tr>
         </tbody></table>
         <p>The PROTECT control statement sets the dataset's password bits ON.&nbsp; The parameters are:</p>
         <blockquote>
            <p>VOLUME=volid</p>
            <blockquote>
               <p>Identifies the DASD Volume Serial number on which the dataset exists.&nbsp;
                  VOLUME may be abbreviated VOL.
               </p>
            </blockquote>
            <p>DSNAME=name</p>
            <blockquote>
               <p>Specifies the one to forty-four character name of the dataset to be
                  modified.&nbsp; DSNAME may be abbreviated DSN.
               </p>
            </blockquote>
         </blockquote>
         <hr color="#808080">
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="14%">
                  <pre><a name="FIXDSCBsetnopwr"></a> SETNOPWR</pre>
               </td>
               <td width="86%">
                  <pre>VOLUME=volid</pre>
               </td>
            </tr>
            <tr>
               <td width="14%">
                  <pre></pre>
               </td>
               <td width="86%">
                  <pre>,DSNAME=name</pre>
               </td>
            </tr>
         </tbody></table>
         <p>The SETHOPWR control statement sets the dataset's no password read enable bits ON.&nbsp; The parameters
            are:
         </p>
         <blockquote>
            <p>VOLUME=volid</p>
            <blockquote>
               <p>Identifies the DASD Volume Serial number on which the dataset exists.&nbsp;
                  VOLUME may be abbreviated VOL.
               </p>
            </blockquote>
            <p>DSNAME=name</p>
            <blockquote>
               <p>Specifies the one to forty-four character name of the dataset to be
                  modified.&nbsp; DSNAME may be abbreviated DSN.
               </p>
            </blockquote>
         </blockquote>
         <hr color="#808080">
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="13%">
                  <pre><a name="FIXDSCBunlock"></a>UNLOCK</pre>
               </td>
               <td width="87%">
                  <pre>VOLUME=volid</pre>
               </td>
            </tr>
            <tr>
               <td width="13%">
                  <pre></pre>
               </td>
               <td width="87%">
                  <pre>,DSNAME=name</pre>
               </td>
            </tr>
         </tbody></table>
         <p>The UNLOCK control statement sets the dataset's password bits OFF.&nbsp; The parameters are:</p>
         <blockquote>
            <p>VOLUME=volid</p>
            <blockquote>
               <p>Identifies the DASD Volume Serial number on which the dataset
                  exists.&nbsp; VOLUME may be abbreviated VOL.
               </p>
            </blockquote>
            <p>DSNAME=name</p>
            <blockquote>
               <p>Specifies the one to forty-four character name of the dataset to be
                  modified.&nbsp; DSNAME may be abbreviated DSN.
               </p>
            </blockquote>
         </blockquote>
         <hr color="#808080">
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="9%">
                  <pre><a name="FIXDSCBrenew"></a>RENEW</pre>
               </td>
               <td width="91%">
                  <pre>VOLUME=volid</pre>
               </td>
            </tr>
            <tr>
               <td width="9%">
                  <pre></pre>
               </td>
               <td width="91%">
                  <pre>,DSNAME=name</pre>
               </td>
            </tr>
         </tbody></table>
         <p>The RENEW control statement resets the creation date for the specified dataset to the current date.&nbsp;
            The parameters are:
         </p>
         <blockquote>
            <p>VOLUME=volid</p>
            <blockquote>
               <p>Identifies the DASD Volume Serial number on which the dataset exists.&nbsp;
                  VOLUME may be abbreviated VOL.
               </p>
            </blockquote>
            <p>DSNAME=name</p>
            <blockquote>
               <p>Specifies the one to forty-four character name of the dataset to be
                  modified.&nbsp; DSNAME may be abbreviated DSN.
               </p>
            </blockquote>
         </blockquote>
         <hr color="#808080">
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="11%">
                  <pre><a name="FIXDSCBexpire"></a>EXPIRE</pre>
               </td>
               <td width="89%">
                  <pre>VOLUME=volid</pre>
               </td>
            </tr>
            <tr>
               <td width="11%">
                  <pre></pre>
               </td>
               <td width="89%">
                  <pre>,DSNAME=name</pre>
               </td>
            </tr>
         </tbody></table>
         <p>The EXPIRE control statement swaps creation date and expiration date for the specified dataset.&nbsp; The
            parameters are:
         </p>
         <blockquote>
            <p>VOLUME=volid</p>
            <blockquote>
               <p>Identifies the DASD Volume Serial number on which the dataset exists.&nbsp;
                  VOLUME may be abbreviated VOL.
               </p>
            </blockquote>
            <p>DSNAME=name</p>
            <blockquote>
               <p>Specifies the one to forty-four character name of the dataset to be
                  modified.&nbsp; DSNAME may be abbreviated DSN.
               </p>
            </blockquote>
         </blockquote>
         <hr color="#808080">
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="11%">
                  <pre><a name="FIXDSCBextend"></a>EXTEND</pre>
               </td>
               <td width="89%">
                  <pre>VOLUME=volid</pre>
               </td>
            </tr>
            <tr>
               <td width="11%">
                  <pre></pre>
               </td>
               <td width="89%">
                  <pre>,DSNAME=name</pre>
               </td>
            </tr>
         </tbody></table>
         <p>The EXTEND control statement set the expiration date to 99:365 for the specified dataset.&nbsp; The parameters
            are:
         </p>
         <blockquote>
            <p>VOLUME=volid</p>
            <blockquote>
               <p>Identifies the DASD Volume Serial number on which the dataset exists.&nbsp;
                  VOLUME may be abbreviated VOL.
               </p>
            </blockquote>
            <p>DSNAME=name</p>
            <blockquote>
               <p>Specifies the one to forty-four character name of the dataset to be
                  modified.&nbsp; DSNAME may be abbreviated DSN.
               </p>
            </blockquote>
         </blockquote>
         <hr color="#808080">
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="13%">
                  <pre><a name="FIXDSCBzeroexpd"></a>ZEROEXPD</pre>
               </td>
               <td width="87%">
                  <pre>VOLUME=volid</pre>
               </td>
            </tr>
            <tr>
               <td width="13%">
                  <pre></pre>
               </td>
               <td width="87%">
                  <pre>,DSNAME=name</pre>
               </td>
            </tr>
         </tbody></table>
         <p>The ZEROEXPD control stateement sets the expiration date to 00:000 for the specified dataset.&nbsp; The parameters
            are:
         </p>
         <blockquote>
            <p>VOLUME=volid</p>
            <blockquote>
               <p>Identifies the DASD Volume Serial number on which the dataset exists.&nbsp;
                  VOLUME may be abbreviated VOL.
               </p>
            </blockquote>
            <p>DSNAME=name</p>
            <blockquote>
               <p>Specifies the one to forty-four character name of the dataset to be
                  modified.&nbsp; DSNAME may be abbreviated DSN.
               </p>
            </blockquote>
         </blockquote>
         <hr color="#808080">
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="12%">
                  <pre><a name="FIXDSCBscratch"></a>SCRATCH</pre>
               </td>
               <td width="88%">
                  <pre>VOLUME=volid</pre>
               </td>
            </tr>
            <tr>
               <td width="12%">
                  <pre></pre>
               </td>
               <td width="88%">
                  <pre>,DSNAME=name</pre>
               </td>
            </tr>
         </tbody></table>
         <p>The SCRATCH control statement deletes the specified dataset.&nbsp; The parameters are:</p>
         <blockquote>
            <p>VOLUME=volid</p>
            <blockquote>
               <p>Identifies the DASD Volume Serial number on which the dataset exists.&nbsp;
                  VOLUME may be abbreviated VOL.
               </p>
            </blockquote>
            <p>DSNAME=name</p>
            <blockquote>
               <p>Specifies the one to forty-four character name of the dataset to be
                  deleted.&nbsp; DSNAME may be abbreviated DSN.
               </p>
            </blockquote>
         </blockquote>
         <p>Note:&nbsp; When using this command, I have found that the scratched dataset
            remains in the catalog. There are other methods available to scratch a dataset, <b><font color="#0000FF">see
            IEHPROGM and PDSPROGM</font></b>.
         </p>
         <hr color="#808080">
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="9%">
                  <pre><a name="FIXDSCBname"></a>NAME</pre>
               </td>
               <td width="91%">
                  <pre>VOLUME=volid</pre>
               </td>
            </tr>
            <tr>
               <td width="9%">
                  <pre></pre>
               </td>
               <td width="91%">
                  <pre>,DSNAME=name</pre>
               </td>
            </tr>
         </tbody></table>
         <p>The NAME control statement provides the dataset information for immediately following subcommand(s).&nbsp;
            The parameters are:
         </p>
         <blockquote>
            <p>VOLUME=volid</p>
            <blockquote>
               <p>Identifies the DASD Volume Serial number on which the dataset exists.&nbsp;
                  VOLUME may be abbreviated VOL.
               </p>
            </blockquote>
            <p>DSNAME=name</p>
            <blockquote>
               <p>Specifies the one to forty-four character name of the dataset to be
                  modified.&nbsp; DSNAME may be abbreviated DSN.
               </p>
            </blockquote>
            <hr color="#808080">
            <p><a name="FIXDSCBrecfm"></a>RECFM=xxxxx</p>
            <blockquote>
               <p>The RECFM subcommand sets the RECFM to the value specified as xxxxx.&nbsp; The value specified
                  must be one of:&nbsp; UT, UA, UM, UTA, UTM, F,  FB, FS, FT,  FBS, FBT, FBST, FA, FBA, FSA,
                  FTA, FBSA, FBTA, FBSTA, FM, FBM,  FSM, FTM,  FBSM, FBTM, FBSTM, V, VB, VS, VT, VBS, VBT, VBST, VA,
                  VBA,  VSA, VTA, VBSA, VBTA, VBSTA, VM, VBM, VSM, VTM,  VBSM, VBTM, or
                  VBSTM.
               </p>
            </blockquote>
            <hr color="#808080">
            <p><a name="FIXDSCBlrecl"></a>LRECL=xxxxx</p>
            <blockquote>
               <p>The LRECL subcommand sets the LRECL to the value specified as xxxxx.</p>
            </blockquote>
            <hr color="#808080">
            <p><a name="FIXDSCBblksize"></a>BLKSIZE=xxxxx</p>
            <blockquote>
               <p>The BLKSIZE subcommand sets the BLKSIZE to the value specified as xxxxx.</p>
            </blockquote>
            <hr color="#808080">
            <p><a name="FIXDSCBdsorg"></a>DSORG=xxx</p>
            <blockquote>
               <p>The DSORG subcommand sets the DSORG to the value specified as xxx.&nbsp; The value specified
                  must be one of:&nbsp; PSU, DA, DAU, IS, ISU, PO, or POU.
               </p>
            </blockquote>
            <hr color="#808080">
            <p><a name="FIXDSCBkeyl"></a>KEYL=xxx</p>
            <blockquote>
               <p>The KEYL subcommand sets the key length to the value specified as xxx.</p>
            </blockquote>
            <hr color="#808080">
            <p><a name="FIXDSCBrkp"></a>RKP=xxx</p>
            <blockquote>
               <p>The RKP subcommand sets the relative key position to the value specified as xxx.</p>
            </blockquote>
            <hr color="#808080">
            <p><a name="FIXDSCBoptcode"></a>OPTCODE=x</p>
            <blockquote>
               <p>The OPTCODE subcommand sets the OPTCODE to the value specified as x.&nbsp; Consult JCL manual for
                  possible values.
               </p>
            </blockquote>
         </blockquote>
         <p>If a particular subcommand is entered more than once, the last occurrence of
            the subcommand will be the one used.&nbsp; If an error occurs during processing
            of any subcommand, the entire subcommand set for the current NAME command will
            be discarded.
         </p>
      </blockquote>
      <h3>&nbsp;</h3>
      <h3>Examples</h3>
      <blockquote>
         <table width="75%" cellspacing="1" border="1">
            <tbody><tr>
               <td width="33%">
                  <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="FIXDSCBj01"></a>Extend
                     expiration date for dataset
               </p></td>
            </tr>
            <tr>
               <td width="33%">
                  <pre><b>//FIXDSCB  JOB (1),'FIXDSCB',CLASS=A,MSGCLASS=X  
//FIXDSCB  EXEC PGM=FIXDSCB                      
//DD01     DD  UNIT=SYSDA,VOL=SER=MVS381,DISP=OLD
//SYSPRINT DD  SYSOUT=*                          
//SYSIN    DD  *                                 
  EXTEND VOL=MVS381,DSN=HMVS01.SOURCE.COBOL      
</b><b>//</b></pre>
               </td>
            </tr>
            <tr>
               <td width="33%">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="FIXDSCBj02"></a>Modify
                  RECFM, LRECL, BLKSIZE
               </td>
            </tr>
            <tr>
               <td width="33%">
                  <pre><b>//FIXDSCB  JOB (1),'FIXDSCB',CLASS=A,MSGCLASS=X  
//FIXDSCB  EXEC PGM=FIXDSCB                      
//DD01     DD  UNIT=SYSDA,VOL=SER=MVS381,DISP=OLD
//SYSPRINT DD  SYSOUT=*                          
//SYSIN    DD  *                                 
  NAME VOL=MVS381,DSN=HMVS01.COBOL.LISTINGS      
    RECFM=FBA                                    
    LRECL=121                                    
    BLKSIZE=23474                                </b><b>
//</b></pre>
               </td>
            </tr>
         </tbody></table>
      </blockquote>
      <hr size="8" noshade="noshade">
      <h2><a name="ICKDSF"></a>ICKDSF <font size="2">[supplied by IBM, located in
         SYS1.LINKLIB]</font>
      </h2>
      <p>Used to perform various operations on direct-access storage devices.&nbsp;
         For the scope of this page, I will only be covering the use of ICKDSF to initialize an
         offline direct-access storage
         volume so that it can be used in an MVS system.
      </p>
      <p>Note that on MVS 3.8j systems built following my instructions/tutorial, there
         are two versions of ICKDSF installed and available for use.&nbsp; The version installed
         with the base Operating System resides in SYS1.LINKLIB and is Version
         6.&nbsp; The version installed in SYS2.LINKLIB is Version 13.&nbsp; ICKDSF requires
         the following DD statements:
      </p>
      <ul>
         <li>SYSPRINT - defines a sequential output message dataset.</li>
         <li>SYSIN - defines a sequential input dataset that contains ICKDSF control
            statements.
         </li>
         <li>any DD name - defines the input dataset containing IPL text records;
            required only when the IPLDD parameter is used.
         </li>
      </ul>
      <h3>&nbsp;</h3>
      <h3>Control Statements</h3>
      <blockquote>
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="9%">
                  <pre><a name="ICKDSFinit"></a>INIT</pre>
               </td>
               <td width="91%">
                  <pre>UNITADDRESS(address) -</pre>
               </td>
            </tr>
            <tr>
               <td width="9%">
                  <pre></pre>
               </td>
               <td width="91%">
                  <pre>{VERIFY(volser) | NOVERIFY} -</pre>
               </td>
            </tr>
            <tr>
               <td width="9%">
                  <pre></pre>
               </td>
               <td width="91%">
                  <pre>{PURGE | NOPURGE} -</pre>
               </td>
            </tr>
            <tr>
               <td width="9%">
                  <pre></pre>
               </td>
               <td width="91%">
                  <pre>[OWNERID(owner)] -</pre>
               </td>
            </tr>
            <tr>
               <td width="9%">
                  <pre></pre>
               </td>
               <td width="91%">
                  <pre>VOLID(volser) -</pre>
               </td>
            </tr>
            <tr>
               <td width="9%">
                  <pre></pre>
               </td>
               <td width="91%">
                  <pre>VTOC(cylinder,track[,extent]) -</pre>
               </td>
            </tr>
            <tr>
               <td width="9%">
                  <pre></pre>
               </td>
               <td width="91%">
                  <pre>[IPLDD(ddname)]</pre>
               </td>
            </tr>
         </tbody></table>
         <p>The INIT control statement prepares a DASD volume for use by examining the mounted
            (offline) volume to
            determine available space, optionally writes IPL bootstrap records as records 1
            and 2, writes a volume label as record 3, and reserves tracks for the Volume
            Table of Contents at the location specified by the user and for the number of
            tracks specified.&nbsp; If no location is specified, tracks are reserved at the
            default location.&nbsp; Alternate tracks are checked for defective-track
            flags.&nbsp; The parameters are:
         </p>
         <blockquote>
            <p>UNITADDRESS(address)</p>
            <blockquote>
               <p>Specifies the physical device address of the DASD to be initialized.&nbsp;
                  The keyword UNITADDRESS may be abbreviated to UNIT.&nbsp; The device must be on
                  a channel that is online; if the channel is offline the program may enter a
                  nonterminating wait state.&nbsp; The address may be specified as either a three
                  or four digit hexadecimal address.
               </p>
            </blockquote>
            <p>VERIFY(volser) | NOVERIFY</p>
            <blockquote>
               <p>VERIFY specifies the current Volume Serial number of the DASD mounted
                  at the address specified, which will be verified before ICKDSF
                  proceeds.&nbsp; NOVERIFY specifies that no checking will be
                  performed.&nbsp; The keyword VERIFY may be abbreviated to VFY; NOVERIFY
                  may be abbreviated to NVFY.
               </p>
               <p>Note:&nbsp; It is a sound practice to create new DASD volumes with the
                  Hercules' dasdinit utility giving a new volume a known Volume Serial
                  number, such as 111111, which may be specified in the VERIFY parameter to
                  ensure that the proper address has been given for ICKDSF to initialize.
               </p>
            </blockquote>
            <p>PURGE | NOPURGE</p>
            <blockquote>
               <p>PURGE specifies that unexpired, or VSAM, or password-protected, or RACF-protected
                  datasets found on the volume are to be written over.&nbsp; NOPURGE
                  specifies that if these types of datasets exist on the volume, you do not
                  want them written over.&nbsp; The keyword PURGE may be abbreviated to PRG;
                  NOPURGE may be abbreviated to NPRG.
               </p>
            </blockquote>
            <p>OWNERID(owner)</p>
            <blockquote>
               <p>Specifies an optional one to fourteen character string that will be
                  written in the volume label.&nbsp; The keyword OWNERID may be abbreviated
                  OWNER.
               </p>
            </blockquote>
            <p>VOLID(volser)</p>
            <blockquote>
               <p>Specifies the volume serial number to be written in the volume
                  label.&nbsp; For volser, substitute one to six alphameric characters for
                  the volume serial number.&nbsp; If fewer than six characters are
                  specified, the serial is left-justified, and the remainder of the field is
                  padded with blanks (X'40').&nbsp; The VOLID of each DASD placed online for
                  MVS to access must be unique.
               </p>
            </blockquote>
            <p>VTOC(cylinder,track[,extent])</p>
            <blockquote>
               <p align="LEFT">Specifies the location and size for the Volume Table of
                  Contents.&nbsp; For cylinder,track, specify one to four decimal (n) or
                  hexadecimal (X'n') numbers to identify the cylinder and one to four
                  decimal (n) or hexadecimal (X'n') numbers to identify the track where the
                  volume table of contents is to be placed.&nbsp; For extent, specify one to
                  five decimal (n) or hexadecimal (X'n') numbers for the number of tracks
                  that are to be reserved the volume table of contents.
               </p>
               <p align="LEFT">Defaults:&nbsp; The default for cylinder,track is
                  0,1.&nbsp; The default for extent is one track.&nbsp; A VTOC cannot be
                  placed at cylinder 0, track 0.
               </p>
            </blockquote>
            <p>IPLDD(ddname)</p>
            <blockquote>
               <p align="LEFT">An optional parameter which allows you to supply an IPL
                  program to be written on the volume during initialization.&nbsp; ICKDSF
                  supplies an IPL bootstrap which is written on the volume during
                  initialization together with the IPL text you supply.
               </p>
            </blockquote>
         </blockquote>
      </blockquote>
      <h3>&nbsp;</h3>
      <h3>Examples</h3>
      <blockquote>
         <table width="75%" cellspacing="1" border="1">
            <tbody><tr>
               <td width="33%">
                  <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="ICKDSFj01"></a>Initialize
                     2314, 3330, 3340, 3350 DASD
               </p></td>
            </tr>
            <tr>
               <td width="33%">
                  <pre><b>//ICKDSF   JOB 1,ICKDSF,CLASS=A,MSGCLASS=X                             
//* ***************************************************************** *
//* * USE FOR 3350 | 3330 | 3340 | 2314                               *
//* ***************************************************************** *
//*                                                                    
//ICKDSF   EXEC PGM=ICKDSF,REGION=4096K                                  
//SYSPRINT DD  SYSOUT=*                                                
//SYSIN    DD  *                                                       
  INIT UNITADDRESS(254) VERIFY(111111) -                               
       VOLID(134134) OWNER(HERCULES) -                         
       VTOC(0,1,15)                                            
//                                                                     </b></pre>
               </td>
            </tr>
            <tr>
               <td width="33%">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="ICKDSFj02"></a>Initialize
                  3375, 3380, 3390 DASD
               </td>
            </tr>
            <tr>
               <td width="33%">
                  <pre><b>////ICKDSF13 JOB 1,ICKDSF,CLASS=S,MSGCLASS=X                             
//* ***************************************************************** *
//* * USE FOR 3390 | 3380 | 3375                                      *
//* ***************************************************************** *
//ICKDSF13 EXEC PGM=ICKDSF13,REGION=4096K                                
//SYSPRINT DD  SYSOUT=*                                                
//SYSIN    DD  *                                                       
  INIT UNIT(187) -                                                     
       VERIFY(SVD001) -                                        
       OWNER(HERCULES) -                                       
       VOLID(SVD001) -                                         
       VTOC(0,1,15)                                            
//                                                                     </b></pre>
               </td>
            </tr>
         </tbody></table>
      </blockquote>
      <p><font size="1">Source:&nbsp; <a href="http://bitsavers.org/pdf/ibm/370/DSF/GC35-0033-5_Device_Support_Facilities_Users_Guide_and_Reference_4.0_May81.pdf" target="_blank">GC35-0033-5 Device Support Facilities User's Guide and Reference
         4.0</a></font>
      </p>
      <hr size="8" noshade="noshade">
      <h2><a name="IEBCOMPR"></a>IEBCOMPR <font size="2">[supplied by IBM, located in
         SYS1.LINKLIB]</font>
      </h2>
      <p>Used to compare two sequential datasets or two partitioned 
datasets at the
         logical record level to verify a backup copy.&nbsp; Fixed, 
variable, or undefined records from blocked or unblocked datasets or 
members can also be<br>
         compared.&nbsp; <b>Note:&nbsp; This is a very old utility and of limited
         functionality.&nbsp; <font color="#0000FF">I
         would suggest taking a look at CMPRSEQ and PDSMATCH.</font></b>
      </p>
      <p>Two sequential datasets are considered to be identical, 
if:&nbsp; 1) the datasets contain the same number of records, and,
         2) corresponding records and keys are identical.&nbsp; If these
 conditions are not met, an unequal comparison results.&nbsp;
         If records are unequal, the record and block numbers, the names
 of the DD statements that
         define the datasets, and the unequal records are listed in a 
message dataset.&nbsp;
         Ten successive unequal comparisons terminate the job step 
unless a user routine is
         provided to handle error conditions.
      </p>
      <p>Two partitioned datasets are considered to be identical 
if:&nbsp; 1) corresponding members contain the same number of
         records, 2) note lists are in the same position within 
corresponding members,
         and 3) corresponding records and keys are identical.&nbsp; If 
these conditions are not met, an unequal comparison results.&nbsp;
         If records are unequal, the record and block numbers, the names
 of the DD statements that
         define the datasets, and the unequal records are listed in a 
message dataset.&nbsp;
         After ten successive unequal comparisons, processing continues 
with the next member
         unless a user routine is provided to handle error 
conditions.&nbsp; Partitioned datasets can be compared only if all the 
names in one or both of the
         directories have counterpart entries in the other directory. 
The comparison is made
         on members identified by these entries and corresponding user 
data.
      </p>
      <p>IEBCOMPR requires the following DD statements:</p>
      <ul>
         <li>SYSPRINT - defines a sequential output message dataset.</li>
         <li>SYSIN - defines a sequential input dataset that contains IEBCOMPR control
            statements.
         </li>
         <li>SYSUT1 - defines the first of the input datasets to be compared</li>
         <li>SYSUT2 - defines the second of the input datasets to be compared</li>
      </ul>
      <h3>&nbsp;</h3>
      <h3>Control Statements</h3>
      <blockquote>
         <hr color="#808080">
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="13%">
                  <pre><a name="IEBCOMPRtypeorg"></a>COMPARE</pre>
               </td>
               <td width="87%">
                  <pre>TYPEORG={PS | PO}</pre>
               </td>
            </tr>
         </tbody></table>
         <p>The COMPARE control statement specifies the organization of 
the two datasets to be compared.&nbsp; The COMPARE
            control statement, if included, must be the first utility 
control statement.&nbsp;
            A COMPARE control statement is required if the EXITS or 
LABELS statement is used or if the input datasets are partitioned
            datasets.&nbsp;
            The values that may be specified are:
         </p>
         <ul>
            <li>PS - specifies that the input datasets to be compared are Physical
               Sequential organization.
            </li>
            <li> PO - specifies that the input datasets to be
               compared are Partitioned organization.
            </li>
         </ul>
         <hr color="#808080">
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="11%">
                  <pre><a name="IEBCOMPRlabels"></a>LABELS</pre>
               </td>
               <td width="89%">
                  <pre>DATA={YES | NO | ALL | ONLY}</pre>
               </td>
            </tr>
         </tbody></table>
         <p>The LABELS control statement specifies whether user labels are to be treated as data by IEBCOMPR.&nbsp;
            Note:&nbsp; LABELS DATA=NO must be specified to make standard user label (SUL)
            exits inactive when input/output datasets with nonstandard labels (NSL) are the
            be processed.&nbsp; If more than one valid LABELS statement is included, all but
            the last LABEL statement are ignored.&nbsp; The values that may be specified
            are:
         </p>
         <ul>
            <li>YES - specifies that any user labels that are not rejected by a user's label processing routine are to be treated as data.&nbsp;
               Processing of labels as data stops in compliance with standard return codes.
            </li>
            <li>NO - specifies that user labels are not to be treated as data.</li>
            <li>ALL - specifies that user labels are to be treated as 
data regardless of any return
               code.&nbsp; A return code of 16 causes IEBCOMPR to 
complete processing of the remainder of the group of user labels and to 
terminate the job step.
            </li>
            <li>ONLY - specifies that only user header labels are to be 
treated as data.&nbsp; User
               header labels are processed as data regardless of any 
return code.&nbsp; The job terminates upon return from the OPEN routine.
            </li>
         </ul>
         <hr color="#808080">
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="9%">
                  <pre><a name="IEBCOMPRexits"></a>EXITS</pre>
               </td>
               <td width="91%">
                  <pre>[INHDR=routinename]</pre>
               </td>
            </tr>
            <tr>
               <td width="9%">
                  <pre></pre>
               </td>
               <td width="91%">
                  <pre>[,INTLR=routinename]</pre>
               </td>
            </tr>
            <tr>
               <td width="9%">
                  <pre></pre>
               </td>
               <td width="91%">
                  <pre>[,ERROR=routinename]</pre>
               </td>
            </tr>
            <tr>
               <td width="9%">
                  <pre></pre>
               </td>
               <td width="91%">
                  <pre>[,PRECOMP=PCRTN]</pre>
               </td>
            </tr>
         </tbody></table>
         <p>The EXITS control statement specifies the name of the routine to receive control after each error
            condition.&nbsp; The parameters are:
         </p>
         <blockquote>
            <p>ERROR=routinename</p>
            <blockquote>
               <p>Specifies the symbolic name of a routine that is to 
receive control after each unequal comparison for error handling.&nbsp;
                  If this parameter is omitted and ten consecutive 
unequal comparisons occur while IEBCOMPR is
                  comparing sequential datasets, processing is 
terminated; if the input datasets are partitioned, processing continues 
with the next member.
               </p>
            </blockquote>
            <p>INHDR=routinename</p>
            <blockquote>
               <p>Specifies the symbolic name of a routine that processes user input header labels.</p>
            </blockquote>
            <p>INTLR=routinename</p>
            <blockquote>
               <p>Specifies the symbolic name of a routine that processes user input trailer labels.</p>
            </blockquote>
            <p>PRECOMP=routinename</p>
            <blockquote>
               <p>Specifies the symbolic name of a routine that 
processes logical records (physical blocks in the case of VS or VBS 
records longer than 32K
                  bytes) from either or both of the input datasets 
before they are<br>
                  compared.
               </p>
            </blockquote>
         </blockquote>
      </blockquote>
      <h3>&nbsp;</h3>
      <h3>Examples</h3>
      <blockquote>
         <table width="75%" cellspacing="1" border="1">
            <tbody><tr>
               <td width="33%">
                  <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="IEBCOMPRj01"></a>Compare
                     two sequential datasets
               </p></td>
            </tr>
            <tr>
               <td width="33%">
                  <pre><b>//IEBCOMPR JOB (1),IEBCOMPR,CLASS=A,MSGCLASS=X
//IEBCOMPR EXEC PGM=IEBCOMPR
//SYSPRINT DD SYSOUT=*
//SYSUT1   DD DSN=DATASET1,UNIT=3330,VOL=SER=D10040,
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DISP=SHR
//SYSUT2   DD DSN=DATASET2,UNIT=3330,VOL=SER=D10040,
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  DISP=SHR
//SYSIN    DD *
&nbsp;&nbsp;COMPARE TYPORG=PS
/*
//</b></pre>
               </td>
            </tr>
            <tr>
               <td width="33%">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="IEBCOMPRj02"></a>Compare
                  two partitioned datasets
               </td>
            </tr>
            <tr>
               <td width="33%">
                  <pre><b>//IEBCOMPR JOB (1),IEBCOMPR,CLASS=A,MSGCLASS=X
//IEBCOMPR EXEC PGM=IEBCOMPR
//SYSPRINT DD SYSOUT=*
//SYSUTl   DD DSN=PDSSET1,UNIT=DISK,DISP=SHR,
//            DCB=(RECFM=FB,LRECL=80,BLKSIZE=2000),
//            VOLUME=SER=111112
//SYSUT2   DD DSN=PDSSET2,UNIT=DISK,DISP=SHR,
//            DCB=(RECFM=FB,LRECL=80,BLKSIZE=2000),
//            VOLUME=SER=111113
//SYSIN    DD *
  COMPARE TYPORG=PO
/*
//</b></pre>
               </td>
            </tr>
         </tbody></table>
      </blockquote>
      <p><font size="1">Source:&nbsp; <a href="http://bitsavers.trailing-edge.com/pdf/ibm/370/OS_VS2/Release_3.8_1978/GC26-3902-1_OS_VS2_MVS_Utilities_Rel_3.8_Sep83.pdf" target="_blank">GC26-3902-1 OS/VS2 MVS Utilities Release 3.8</a></font></p>
      <hr size="8" noshade="noshade">
      <h2><a name="IEBCOPY"></a>IEBCOPY <font size="2">[supplied by IBM, located in
         SYS1.LINKLIB]</font>
      </h2>
      <p align="LEFT">Used to copy one or more partitioned datasets or to merge
         partitioned datasets.&nbsp; A partitioned dataset which is copied to a
         sequential dataset is said to be unloaded.<font lang="JA">&nbsp; </font>The
         sequential dataset created by an unload operation can be copied to any direct
         access device.&nbsp; When one or more datasets created by an unload operation
         are used to re-create a partitioned dataset, this is called a load
         operation.&nbsp; An individual member, or members, of a partitioned or unloaded dataset can be
         selected for, or excluded from, a copy, unload, or load process.
      </p>
      <p align="LEFT">IEBCOPY can be used to:</p>
      <ul>
         <li>
            <p align="LEFT">Create a backup copy of a partitioned dataset.
         </p></li>
         <li>
            <p align="LEFT">Copy one or more datasets per copy operation.
         </p></li>
         <li>
            <p align="LEFT">Copy one partitioned dataset to a sequential dataset (unload).
         </p></li>
         <li>
            <p align="LEFT">Copy one or more datasets created by an unload operation to
               any direct access device (load).
         </p></li>
         <li>
            <p align="LEFT">Select members from a dataset to be copied, unloaded, or
               loaded.
         </p></li>
         <li>
            <p align="LEFT">Replace identically named members on datasets (except when
               unloading).
         </p></li>
         <li>
            <p align="LEFT">Replace selected dataset members.
         </p></li>
         <li>
            <p align="LEFT">Rename selected members.
         </p></li>
         <li>
            <p align="LEFT">Exclude members from a dataset to be copied, unloaded, or
               loaded.
         </p></li>
         <li>
            <p align="LEFT">Compress partitioned datasets in place (except when the dataset
               is an unloaded dataset).
         </p></li>
         <li>
            <p align="LEFT">Merge datasets (except when unloading).
         </p></li>
         <li>
            <p align="LEFT">Re-create a dataset that has exhausted its primary,
               secondary, or directory space allocation.
         </p></li>
      </ul>
      <p align="LEFT">A compressed dataset is one that does not contain embedded,
         unused space.&nbsp; After copying or loading one or more input partitioned
         datasets to a new output partitioned dataset (by means of a selective,
         exclusive, or full copy or load that does not involve replacing members), the
         output partitioned dataset contains no embedded, unused space.&nbsp; To make
         unused space available, either the entire dataset must be scratched or it must
         be compressed in place.&nbsp; A compressed version can be created by specifying
         the same dataset for both the input and the output parameters in a full copy
         step.&nbsp; <b>A backup copy of the partitioned dataset to be compressed in
         place should be kept until successful completion of an in-place compression is indicated
         (by an end-of-job message and a return code of 00).</b>&nbsp; An in-place
         compression does not release extents assigned to the dataset.&nbsp; Selection,
         exclusion, or renaming of selected members cannot be done during the compression
         of a partitioned dataset.
      </p>
      <p align="LEFT">In addition, IEBCOPY automatically lists the number of unused
         directory blocks and the number of unused tracks available for member records in
         the output partitioned dataset.&nbsp; If LIST=NO is coded the names of copied,
         unloaded, or loaded members listed by the input dataset are suppressed.
      </p>
      <p>IEBCOPY requires the following DD statements:</p>
      <ul>
         <li>SYSPRINT - defines a sequential output message dataset.</li>
         <li>SYSIN - defines a sequential input dataset that contains IEBCOPY control
            statements.
         </li>
         <li>SYSUT1 - defines the first of the input datasets to be compared</li>
         <li>SYSUT2 - defines the second of the input datasets to be compared</li>
         <li>SYSUT3 - defines a temporary work file</li>
         <li>SYSUT4 - defines a temporary work file</li>
      </ul>
      <h3>&nbsp;</h3>
      <h3>Control Statements</h3>
      <blockquote>
         <p>All keywords on the control statements may be abbreviated to a single
            letter:&nbsp; COPY to C; INDD to I; OUTDD to O; SELECT to S; EXCLUDE to E.&nbsp;
         </p>
         <hr color="#808080">
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="9%">
                  <pre><a name="IEBCOPYcopy"></a>COPY</pre>
               </td>
               <td width="91%">
                  <pre>OUTDD=ddname</pre>
               </td>
            </tr>
            <tr>
               <td width="9%">
                  <pre></pre>
               </td>
               <td width="91%">
                  <pre>,INDD={ddname | (ddname1[,ddname2]...)}</pre>
               </td>
            </tr>
            <tr>
               <td width="9%">
                  <pre></pre>
               </td>
               <td width="91%">
                  <pre>[,LIST=NO]</pre>
               </td>
            </tr>
         </tbody></table>
         <p>The COPY control statement specifies the DD names to be used for a copy operation and allows suppression
            of list.&nbsp; The parameters are:
         </p>
         <blockquote>
            <p>OUTDD=ddname,</p>
            <blockquote>
               <p>Specifies the DD name for the output dataset.</p>
            </blockquote>
            <p>INDD=ddname | INDD=(ddname1[,ddname2]...</p>
            <blockquote>
               <p>Specifies one or more DD names for the input dataset(s).&nbsp; If more
                  than one ddname is specified, they must be enclosed in parentheses and
                  separated by commas; the input datasets specified in the list are
                  processed in the order specified in the list.
               </p>
               <p>In the case of multiple input datasets, there can arise the event of
                  duplicate member names.&nbsp; If this happens, a subsequent member
                  encountered with the same name as a member already copied to the output
                  dataset will not replace the member that has already been copied to the
                  output dataset, unless the replace option is specified.&nbsp; To replace
                  any duplicate members encountered, enclose the ddname for which the
                  replace option is to be used in an additional pair of parentheses and
                  follow the ddname with a comma followed by R:
               </p>
               <blockquote>
                  <p>INDD=(ddname1,(ddname2,R),ddname3)</p>
                  <blockquote>
                     <p>will result in any members in ddname2 that have duplicates in
                        ddname1 to replace the members already copied from ddname1 in the
                        output dataset.
                     </p>
                  </blockquote>
               </blockquote>
               <p>[,LIST=NO]</p>
               <blockquote>
                  <p>Specifies that the list of copied members, as well as unused tracks and
                     directory blocks in the output dataset, is to be suppressed.
                  </p>
               </blockquote>
            </blockquote>
         </blockquote>
         <hr color="#808080">
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="10%">
                  <pre><a name="IEBCOPYselect"></a>SELECT</pre>
               </td>
               <td width="90%">
                  <pre>MEMBER={name | (name1[,name2]...) | ((name,newname)[,(name2,newname2)...)}</pre>
               </td>
            </tr>
         </tbody></table>
         <p>The SELECT control statement specifies specific members to be copied from the input dataset(s).&nbsp; If
            more than one member name is specified, they must be enclosed in parentheses
            and separated by commas.&nbsp; Multiple SELECT statements may be specified, in
            which case the subsequent statements are processed as a continuation of the
            first.&nbsp; If the optional newname is specified for a member, the original
            member is copied to the output dataset using the newname supplied.
         </p>
         <p>A selected member will not replace an identically named member already
            copied into the output dataset unless the replace option is specified.&nbsp;
            To cause any selected member to replace an identically named member, enclose
            the member name in an additional pair of parentheses and follow the member
            name with two commas followed by R:
         </p>
         <blockquote>
            <p>SELECT MEMBER=(name1,(name2,,R),name3,(name4,newname4,R))</p>
            <blockquote>
               <p>will result in name2, and name4 after renaming to newname4, replacing
                  any duplicate already copied into the output dataset.
               </p>
            </blockquote>
         </blockquote>
         <hr color="#808080">
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="12%">
                  <pre><a name="IEBCOPYexclude"></a>EXCLUDE</pre>
               </td>
               <td width="88%">
                  <pre>MEMBER={name | (name1[,name2]...)}</pre>
               </td>
            </tr>
         </tbody></table>
         <p>The EXCLUDE control statement specifies specific members to be excluded from being copied to the output
            dataset.
         </p>
         <p><b>Note:&nbsp; SELECT and EXCLUDE statements may not appear together in the
            same COPY operation.</b>
         </p>
      </blockquote>
      <h3>&nbsp;</h3>
      <h3>Examples</h3>
      <blockquote>
         <table width="75%" cellspacing="1" border="1">
            <tbody><tr>
               <td width="33%">
                  <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="IEBCOPYj01"></a>Copy
                     partitioned dataset from one DASD to another DASD, including all members
               </p></td>
            </tr>
            <tr>
               <td width="33%">
                  <pre><b>//IEBCOPY JOB (1),IEBCOPY,CLASS=A,MSGCLASS=X
//IEBCOPY EXEC PGM=IEBCOPY
//SYSPRINT DD SYSOUT=*
//FROM     DD DSN=FROMLIB,UNIT=3330,VOL=SER=D10040,
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DISP=OLD
//TO       DD DSN=TOLIB,UNIT=3330,VOL=SER=D10080,
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DISP=(NEW,KEEP),SPACE=(TRK,(400,,50))
//SYSUT3   DD UNIT=3330,SPACE=(TRK,5)
//SYSUT4   DD UNIT=3330,SPACE=(TRK,5)
//SYSIN    DD *
&nbsp;&nbsp;COPY INDD=FROM,OUTDD=TO
/*
//</b></pre>
               </td>
            </tr>
            <tr>
               <td width="33%">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="IEBCOPYj02"></a>Copy
                  partitioned dataset from one DASD to another DASD, selecting specific
                  members
               </td>
            </tr>
            <tr>
               <td width="33%">
                  <pre><b>//IEBCOPY JOB (1),IEBCOPY,CLASS=A,MSGCLASS=X
//IEBCOPY EXEC PGM=IEBCOPY
//SYSPRINT DD SYSOUT=*
//FROM     DD DSN=FROMLIB,UNIT=3330,VOL=SER=D10040,
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DISP=OLD
//TO       DD DSN=TOLIB,UNIT=3330,VOL=SER=D10080,
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DISP=(NEW,KEEP),SPACE=(TRK,(400,,50))
//SYSUT3   DD UNIT=3330,SPACE=(TRK,5)
//SYSUT4   DD UNIT=3330,SPACE=(TRK,5)
//SYSIN    DD *
&nbsp;&nbsp;COPY INDD=FROM,OUTDD=TO
  SELECT MEMBER=(PROGA,PROGB) 
/*
//</b></pre>
               </td>
            </tr>
            <tr>
               <td width="33%">
                  <b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="IEBCOPYj03"></a></b>Copy
                  members from two partitioned datasets, creating a new partitioned dataset,
                  replacing any members with the same name from dataset 2
               </td>
            </tr>
            <tr>
               <td width="33%">
                  <pre><b>//IEBCOPY JOB (1),IEBCOPY,CLASS=A,MSGCLASS=X
//IEBCOPY EXEC PGM=IEBCOPY
//SYSPRINT DD SYSOUT=*
//FROM1    DD DSN=FROMLIB1,UNIT=3330,VOL=SER=D10040,
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DISP=OLD
//FROM2    DD DSN=FROMLIB2,UNIT=3330,VOL=SER=D10041,
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DISP=OLD
//TO       DD DSN=TOLIB,UNIT=3330,VOL=SER=D10080,
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DISP=(NEW,KEEP),SPACE=(TRK,(400,,50))
//SYSUT3   DD UNIT=3330,SPACE=(TRK,5)
//SYSUT4   DD UNIT=3330,SPACE=(TRK,5)
//SYSIN    DD *
&nbsp;&nbsp;COPY INDD=(FROM1,(FROM2,R)),OUTDD=TO
/*
//</b></pre>
               </td>
            </tr>
            <tr>
               <td width="33%">
                  <b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="IEBCOPYj04"></a></b>Compress
                  partitioned dataset
               </td>
            </tr>
            <tr>
               <td width="33%">
                  <pre><b>//COMPRESS JOB (1),COMPRESS,CLASS=A,MSGCLASS=X
//IEBCOPY  EXEC PGM=IEBCOPY,REGION=4M
//SYSPRINT  DD SYSOUT=*
//LIB       DD DSN=LIBFILE,UNIT=3330,VOL=SER=D10040
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DISP=OLD
//SYSUT3    DD UNIT=3330,SPACE=(TRK,5)
//SYSUT4    DD UNIT=3330,SPACE=(TRK,5)
//SYSIN     DD *
&nbsp;&nbsp;COPY INDD=LIB,OUTDD=LIB
/*
//</b></pre>
               </td>
            </tr>
            <tr>
               <td width="33%">
                  <b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="IEBCOPYj05"></a></b>Unload
                  a partitioned dataset to tape
               </td>
            </tr>
            <tr>
               <td width="33%">
                  <pre><b>//UNLOAD   JOB (1),UNLOAD,CLASS=A,MSGCLASS=X
//IEBCOPY  EXEC PGM=IEBCOPY
//SYSPRINT  DD SYSOUT=*
//LIB       DD DSN=LIBFILE,UNIT=3330,VOL=SER=D10040
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DISP=OLD
//TAPE      DD DSN=LIBFILE.BACKUP,UNIT=TAPE,VOL=SER=T10002,
//             LABEL=(1,SL),DISP=(NEW,KEEP)
//SYSUT3    DD UNIT=3330,SPACE=(TRK,5)
//SYSUT4    DD UNIT=3330,SPACE=(TRK,5)
//SYSIN     DD *
&nbsp;&nbsp;COPY INDD=LIB,OUTDD=TAPE
/*
//</b></pre>
               </td>
            </tr>
            <tr>
               <td width="33%">
                  <b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="IEBCOPYj06"></a></b>Reload
                  some members of an unloaded partitioned dataset
               </td>
            </tr>
            <tr>
               <td width="33%">
                  <pre><b>//RELOAD   JOB (1),RELOAD,CLASS=A,MSGCLASS=X                                              
//IEBCOPY  EXEC PGM=IEBCOPY,REGION=1M                          
//SYSPRINT  DD SYSOUT=*                                        
//TAPE      DD DISP=(OLD,KEEP),UNIT=TAPE,LABEL=(1,SL), 
//             VOL=SER=T10002,DSN=LIBFILE.BACKUP              
//LIB       DD DISP=(,CATLG,DELETE),DSN=SYSP.SOURCE.COBOL, 
//             UNIT=SYSDA,VOL=SER=SYSP01,                       
//             SPACE=(TRK,(15,15,5))                        
</b><b>//SYSUT3    DD UNIT=3330,SPACE=(TRK,5)
//SYSUT4    DD UNIT=3330,SPACE=(TRK,5)
</b><b>//SYSIN    DD  *                                               
  COPY INDD=TAPE,OUTDD=LIB
  SELECT MEMBER=(PROGV,PROGL)
/*
//                                                             </b></pre>
               </td>
            </tr>
         </tbody></table>
      </blockquote>
      <p><font size="1">Source:&nbsp; <a href="http://bitsavers.trailing-edge.com/pdf/ibm/370/OS_VS2/Release_3.8_1978/GC26-3902-1_OS_VS2_MVS_Utilities_Rel_3.8_Sep83.pdf" target="_blank">GC26-3902-1 OS/VS2 MVS Utilities Release 3.8</a></font></p>
      <hr size="8" noshade="noshade">
      <h2><a name="IEBGENER"></a>IEBGENER <font size="2">[supplied by IBM, located in
         SYS1.LINKLIB]</font>
      </h2>
      <p align="LEFT">Used to copy a sequential dataset, or a member of a partitioned
         dataset, to a sequential dataset or a member of a partitioned dataset.&nbsp;&nbsp;
      </p>
      <blockquote>
         <p align="LEFT">Note:&nbsp; At the January 2022 rewrite, for this utility, as
            with several others, I was using IBM manual GC26-3092-1 OS/VS2 MVS Utilities
            Release 3.8 for the primary source.&nbsp; That manual includes the definitions
            of control statements for using IEBGENER for much more advanced dataset
            manipulation than simply copying.&nbsp; However, in many decades of using
            IEBGENER, I have only once seen the use of SYSIN control statements to do any
            manipulation of the data moved between datasets.&nbsp; The vast majority of
            cases where I have seen IEBGENER used was simply for copying a dataset or member
            from one location to another, with the SYSIN DD provided as DUMMY.&nbsp;
            IEBGENER is excellent at performing that task.&nbsp; <b><font color="#0000FF">I
            would also suggest taking a look at SYSREPRO.</font></b>
         </p>
      </blockquote>
      <p>IEBGENER requires the following DD statements:</p>
      <ul>
         <li>SYSPRINT - defines a sequential output message dataset.</li>
         <li>SYSIN - defines an optional sequential input dataset that may contains IEBGENER control
            statements.
         </li>
         <li>SYSUT1 - defines the input dataset to be copied</li>
         <li>SYSUT2 - defines the output dataset</li>
      </ul>
      <h3>&nbsp;</h3>
      <h3>Control Statements</h3>
      <blockquote>
         <hr color="#808080">
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="14%">
                  <pre><a name="IEBGENERgenerate"></a>GENERATE</pre>
               </td>
               <td width="86%">
                  <pre>[MAXNAME=n]</pre>
               </td>
            </tr>
            <tr>
               <td width="14%">
                  <pre></pre>
               </td>
               <td width="86%">
                  <pre>[,MAXFLDS=n]</pre>
               </td>
            </tr>
            <tr>
               <td width="14%">
                  <pre></pre>
               </td>
               <td width="86%">
                  <pre>[,MAXGPS=n]</pre>
               </td>
            </tr>
            <tr>
               <td width="14%">
                  <pre></pre>
               </td>
               <td width="86%">
                  <pre>[,MAXLITS=n]</pre>
               </td>
            </tr>
         </tbody></table>
         <p>The GENERATE control statement specifies the number of member names and alias names, record identifiers,
            literals, and editing information contained in the control dataset.&nbsp; The
            parameters are:
         </p>
         <blockquote>
            <p>MAXNAME=n</p>
            <blockquote>
               <p>Specifies a number that is no less than the total number of member names as aliases appearing in subsequent
                  MEMBER statements.&nbsp; MAXNAME is required if there are one or more MEMBER statements.
               </p>
            </blockquote>
            <p>MAXFLDS=n</p>
            <blockquote>
               <p>Specifies a number that is no less than the total number of FIELD parameter appearing in subsequent RECORD
                  statements.&nbsp; MAXFLDS is required if there are any FIELD parameters in subsequent RECORD
                  statements.
               </p>
            </blockquote>
            <p>MAXGPS=n</p>
            <blockquote>
               <p>Specifies a number that is no less than the total number of IDENT parameters appearing in subsequent RECORD
                  statements.&nbsp; MAXGPS is required if there are any IDENT parameters in subsequent RECORD
                  statements.
               </p>
            </blockquote>
            <p>MAXLITS=n</p>
            <blockquote>
               <p>Specifies a number that is no less than the total number of characters contained in the FIELD literals of subsequent
                  RECORD statements.&nbsp; MAXLITS is required if the FIELD parameters of subsequent
                  RECORD statements contain literals.&nbsp; MAXLITS does not pertain to literals used in
                  IDENT parameters.
               </p>
            </blockquote>
         </blockquote>
         <hr color="#808080">
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="9%">
                  <pre><a name="IEBGENERexits"></a>EXITS</pre>
               </td>
               <td width="91%">
                  <pre>[INHDR=routinename]</pre>
               </td>
            </tr>
            <tr>
               <td width="9%">
                  <pre></pre>
               </td>
               <td width="91%">
                  <pre>[,OUTHDR=routinename]</pre>
               </td>
            </tr>
            <tr>
               <td width="9%">
                  <pre></pre>
               </td>
               <td width="91%">
                  <pre>[,INTLR=routinename]</pre>
               </td>
            </tr>
            <tr>
               <td width="9%">
                  <pre></pre>
               </td>
               <td width="91%">
                  <pre>[,OUTTLR=routinename]</pre>
               </td>
            </tr>
            <tr>
               <td width="9%">
                  <pre></pre>
               </td>
               <td width="91%">
                  <pre>[,KEY=routinename]</pre>
               </td>
            </tr>
            <tr>
               <td width="9%">
                  <pre></pre>
               </td>
               <td width="91%">
                  <pre>[,DATA=routinename]</pre>
               </td>
            </tr>
            <tr>
               <td width="9%">
                  <pre></pre>
               </td>
               <td width="91%">
                  <pre>[,IOERROR=routinename]</pre>
               </td>
            </tr>
            <tr>
               <td width="9%">
                  <pre></pre>
               </td>
               <td width="91%">
                  <pre>[,TOTAL=(routinename, size)]</pre>
               </td>
            </tr>
         </tbody></table>
         <p>The EXITS control statement specifies that user routines are provided.&nbsp; The parameters are:</p>
         <blockquote>
            <p>INHDR=routinename</p>
            <blockquote>
               <p>Specifies the symbolic name of a routine that processes user input header labels.</p>
            </blockquote>
            <p>OUTHDR=routinename</p>
            <blockquote>
               <p>Specifies the symbolic name of a routine that creates user output header labels.&nbsp;
                  OUTHDR is ignored if the output dataset is partitioned.
               </p>
            </blockquote>
            <p>INTLR=routinename</p>
            <blockquote>
               <p>Specifies the symbolic name of a routine that processes user input trailer labels.</p>
            </blockquote>
            <p>OUTTLR=routinename</p>
            <blockquote>
               <p>Specifies the symbolic name of a routine that processes user output trailer labels.&nbsp;
                  OUTTLR is ignored if the output dataset is partitioned.
               </p>
            </blockquote>
            <p>KEY=routinename</p>
            <blockquote>
               <p>Specifies the symbolic name of a routine that creates the output record key.&nbsp;
                  (This routine does not receive control when a dataset consisting of VS or VBS type records is
                  processed because no processing of keys is permitted for this type of data.)
               </p>
            </blockquote>
            <p>DATA=routinename</p>
            <blockquote>
               <p>Specifies the symbolic name of a routine that modifies the physical record (logical record for VS or
                  VBS type records) before its processed by IEBGENER.
               </p>
            </blockquote>
            <p>IOERROR=routinename</p>
            <blockquote>
               <p>Specifies the symbolic name of a routine that handles permanent input/output error conditions.</p>
            </blockquote>
            <p>TOTAL=(routinename,size)</p>
            <blockquote>
               <p>Specifies that exits to a user's routine are to be provided prior to writing each record.&nbsp;
                  The keyword OPTCD=T must be specified for the SYSUT2 DD statement.&nbsp; TOTAL
                  is valid only when the utility is used to process sequential datasets.&nbsp;
                  These values must be coded:
               </p>
               <ul>
                  <li>routinename - Specifies the name of a user-supplied totaling routine.</li>
                  <li>size - Specifies the number of bytes needed to contain totals, counters, pointers, etc.</li>
               </ul>
            </blockquote>
         </blockquote>
         <hr color="#808080">
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="11%">
                  <pre><a name="IEBGENERlabels"></a>LABELS</pre>
               </td>
               <td width="89%">
                  <pre>[DATA={YES | NO | ALL | ONLY | INPUT}]</pre>
               </td>
            </tr>
         </tbody></table>
         <p>The LABELS control statement specifies whether user labels are to be treated as data.&nbsp; The
            values that may be specified for the DATA operand are:
         </p>
         <ul>
            <li>YES - Specifies that any user labels that are not rejected by a user's label processing routine are to be treated as data.&nbsp;
               Processing of labels as data ends in compliance with standard return codes.
            </li>
            <li>NO - Specifies that user labels are not to be treated as data.</li>
            <li>ALL - Specifies that user labels in the group currently being processed are to be treated as data regardless of any
               return code.&nbsp; A return code of 16 causes IEBGENER to complete processing the
               remainder of the group of user labels and to terminate the job step.
            </li>
            <li>ONLY - Specifies that only user header labels are to be treated as data.&nbsp;
               User header labels are processed as data regardless of any return code.&nbsp;
               The job terminates upon return from the OPEN routine.
            </li>
            <li>INPUT - Specifies that user labels for the output dataset are supplied as 80-byte input records in the data portion of
               SYSIN.&nbsp; The number of input records that should be treated as user labels must be
               identified by a RECORD statement.
            </li>
         </ul>
         <hr color="#808080">
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="11%">
                  <pre><a name="IEBGENERmember"></a>MEMBER</pre>
               </td>
               <td width="89%">
                  <pre>NAME={(name[,alias]...)}</pre>
               </td>
            </tr>
         </tbody></table>
         <p>The MEMBER control statement specifies the member name and alias(es) of a member of a partitioned dataset
            to be created.&nbsp; The parameter is:
         </p>
         <blockquote>
            <p>NAME=(name[,alias]...)</p>
            <blockquote>
               <p>Specifies a member name followed by a list of its aliases.&nbsp; If only one name appears in the statement, it need not be
                  enclosed in parentheses.
               </p>
            </blockquote>
         </blockquote>
         <hr color="#808080">
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="10%">
                  <pre><a name="IEBGENERrecord"></a>RECORD</pre>
               </td>
               <td width="90%">
                  <pre>[IDENT=(length,'name',input-location)]</pre>
               </td>
            </tr>
            <tr>
               <td width="10%">
                  <pre></pre>
               </td>
               <td width="90%">
                  <pre>[,FIELD=([length],[{input-location | 'literal'}]</pre>
               </td>
            </tr>
            <tr>
               <td width="10%">
                  <pre></pre>
               </td>
               <td width="90%">
                  <pre>,[conversion]</pre>
               </td>
            </tr>
            <tr>
               <td width="10%">
                  <pre></pre>
               </td>
               <td width="90%">
                  <pre>[,output-location])</pre>
               </td>
            </tr>
            <tr>
               <td width="10%">
                  <pre></pre>
               </td>
               <td width="90%">
                  <pre>[,FIELD=...]]</pre>
               </td>
            </tr>
            <tr>
               <td width="10%">
                  <pre></pre>
               </td>
               <td width="90%">
                  <pre>[,LABELS=n]</pre>
               </td>
            </tr>
         </tbody></table>
         <p>The RECORD control statement defines a record group to be processed and supplies editing
            information.&nbsp; The parameters are:
         </p>
         <blockquote>
            <p>IDENT=(length,'name',input-location)</p>
            <p>Identifies that last record of the input group to which the FIELD parameters of MEMBER statement applies.&nbsp;
               If the RECORD control statement is not followed by additional RECORD or MEMBER
               control statements, IDENT also
               defines the last record to be processed.&nbsp; These values can be coded:
            </p>
            <ul>
               <li>length - Specifies the length (in bytes) of the identifying name.&nbsp; The length cannot exceed eight characters.</li>
               <li>'name' - Specifies the exact literal that identifies the last input record of a record group.&nbsp;
                  Default: If no match for name is found, the remainder of the input data considered to be in one record group;
                  subsequent RECORD and MEMBER statements are ignored.
               </li>
               <li>input-location - Specifies the starting location of the field that contains the identifying name in the input records.</li>
            </ul>
            <p>Default: If IDENT is omitted, the remainder of the input data is considered to be in one record group; subsequent
               RECORD and MEMBER control statements are ignored.
            </p>
            <p>FIELD=([length],[{input-location | 'literal'}],[conversion],[output-location])[,FIELD=...]</p>
            <p>Specifies field-processing and editing information.&nbsp; Only the contents of specified fields in the input record is copied to
               the output record, that is, any field in the output record that is not specified will
               contain meaningless information.&nbsp; The values that can be coded are:
            </p>
            <ul>
               <li>length - Specifies the length (in bytes) of the input field or literal to be processed.&nbsp;
                  If length is not specified, a length of 80 bytes is assumed.&nbsp; If a literal is to be processed, a length
                  of 40 bytes or&nbsp; less must be specified.
               </li>
               <li>input-location - Specifies the starting byte of the field to be processed.&nbsp; Default:&nbsp;
                  Byte 1 is assumed.
               </li>
               <li>'literal' - Specifies a literal (maximum length of 40 bytes) to be placed in the specified output location.&nbsp;
                  If a literal contains apostrophes, each apostrophe must be written as two consecutive
                  apostrophes.
               </li>
               <li>
                  conversion - Specifies a two-byte code that indicates 
the type of conversion to be performed on this field.&nbsp;
                  If no conversion is specified, the field is moved to 
the output area without change.&nbsp;
                  The values that can be coded are:
                  <ul>
                     <li>PZ - Specifies that data (packed decimal) is to be converted to unpacked decimal data.</li>
                     <li>ZP - Specifies that data (unpacked decimal) is to be converted to packed decimal data.</li>
                     <li>HE - Specifies that data (H-set BCD) is to be converted to EBCDIC.</li>
                  </ul>
               </li><li>output-location - Specifies the starting location of this field in the output records.&nbsp;
                  If conversion is specified in FIELD, the following restrictions apply:
               </li>
               <blockquote>
                  <p>For PZ-type (packed-to-unpacked) conversion is impossible for packed decimal records longer than
                     16K bytes.
                  </p>
                  <p>For ZP-type (unpacked-to-packed) conversion, the normal 32K-type maximum applies.</p>
                  <p>When the ZP parameter is specified, the conversion is performed in place.&nbsp;
                     The original unpacked field is replaced by the new packed field.&nbsp; Therefore, the ZP
                     parameter must be omitted from subsequent references to that field. If&nbsp;
                     the field is needed in its original unpacked form, it must be referenced prior to
                     the use of the ZP parameter.&nbsp;&nbsp;
                  </p>
                  <p>If conversion is specified in the FIELD parameter, 
the length of the output record can be calculated for each
                     conversion specification.&nbsp; When L is equal to 
the length of the input record, the calculation is made, as&nbsp;
                     follows:
                  </p>
                  <blockquote>
                     <p>For a PZ (packed-to-unpacked) specification, 2L-1.</p>
                     <p>For a ZP (unpacked-to-packed) specification, (L/2) + C.&nbsp; If L is an odd number, C is 1/2; if L is an even number, C is 1.</p>
                     <p>For an HE (H-set BCDIC to EBCDIC) specification, L.</p>
                  </blockquote>
               </blockquote>
            </ul>
            <blockquote>
               <p>Default: Byte 1 is assumed.</p>
            </blockquote>
            <p>If both output header labels and output trailer labels are to be contained in the SYSIN
               dataset, the user must
               include one RECORD statement (including the LABELS parameter), indicating the number of input
               records to be treated as user labels, for header labels and one for trailer labels.&nbsp;
               The first such RECORD statement indicates the number of user header labels;
               the second indicates the number of user trailer labels. If only output trailer labels
               are included in the SYSIN dataset, a RECORD statement must be included to indicate
               that there are no output header labels in the SYSIN dataset (LABELS=O). This statement must precede the
               RECORD LABELS=n statement&nbsp; which signals the start of trailer label input records.
            </p>
            <p>LABELS=n</p>
            <p>An optional parameter that indicates the number of records in the SYSIN dataset
               to be treated as user labels.&nbsp;
               The number n, which is a number from 1 to 8, must specify the exact number of label records that
               follow the RECORD statement.&nbsp; If this parameter is included, DATA=INPUT must be coded on a LABELS statement
               before it in the input stream.
            </p>
         </blockquote>
      </blockquote>
         <h3>&nbsp;</h3>

         <h3>Examples</h3>
         <blockquote>
            <table width="75%" cellspacing="1" border="1">
               <tbody><tr>
                  <td width="33%">
                     <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="IEBGENERj01"></a>Copying tape to
                        tape
                  </p></td>
               </tr>
               <tr>
                  <td width="33%">
                     <pre><b>//DUPTAPE JOB (1),DUPTAPE,CLASS=A,MSGCLASS=X
//DUPTAPE EXEC PGM=IEBGENER
//SYSPRINT DD SYSOUT=*
//SYSUT1   DD UNIT=TAPE,DSN=TAPE.FILE,
//            VOL=SER=004000,DISP=OLD,LABEL=(1,SL)
//SYSUT2   DD UNIT=TAPE,DSN=TAPE.FILE,
//            DISP=(NEW,KEEP),LABEL=(1,SL),
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DCB=BLKSIZE=80
//SYSIN DD DUMMY
//</b></pre>
                  </td>
               </tr>
               <tr>
                  <td width="33%">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="IEBGENERj02"></a>Tape to print</td>
               </tr>
               <tr>
                  <td width="33%">
                     <pre><b>//PRNTTAPE JOB (1),PRNTTAPE,CLASS=A,MSGCLASS=X
//PRNTTAPE EXEC PGM=IEBGENER
//SYSPRINT  DD SYSOUT=*
//SYSUT1    DD UNIT=TAPE,DSN=TAPE.FILE,
//             VOL=SER=004000,LABEL=(1,SL),DISP=OLD
//SYSUT2 DD SYSOUT=A,DCB=BLKSIZE=80
//SYSIN DD DUMMY
//</b></pre>
                  </td>
               </tr>
               <tr>
                  <td width="33%">
                     <b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="IEBGENERj03"></a></b>Card to tape
                  </td>
               </tr>
               <tr>
                  <td width="33%">
                     <pre><b>//CARDTAPE JOB (1),CARDTAPE,CLASS=A,MSGCLASS=X
//CARDTAPE EXEC PGM=IEBGENER
//SYSPRINT  DD SYSOUT=*
//SYSUT1    DD *</b>

&nbsp;&nbsp;&nbsp; <font color="#0000FF">[<i>card file to be put on tape goes here</i>]</font>

<b>/*
//SYSUT2    DD UNIT=TAPE,DSN=TAPE.FILE,
//             DISP=(NEW,KEEP),LABEL=(1,SL),
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DCB=BLKSIZE=80
//SYSIN DD DUMMY
//</b></pre>
                  </td>
               </tr>
            </tbody></table>
         </blockquote>
         <p><font size="1">Source:&nbsp; <a href="http://bitsavers.trailing-edge.com/pdf/ibm/370/OS_VS2/Release_3.8_1978/GC26-3902-1_OS_VS2_MVS_Utilities_Rel_3.8_Sep83.pdf" target="_blank">GC26-3902-1 OS/VS2 MVS Utilities Release 3.8</a></font></p>
         <hr size="8" noshade="noshade">
         <h2><a name="IEBISAM"></a>IEBISAM <font size="2">[supplied by IBM, located in
            SYS1.LINKLIB]</font>
         </h2>
         <p align="LEFT">Used to:&nbsp;</p>
         <ul>
            <li>
               <p align="LEFT"> copy an indexed sequential (ISAM) dataset from one DASD
                  volume to another,&nbsp;&nbsp;
            </p></li>
            <li>
               <p align="LEFT">copy an ISAM dataset into a sequential dataset on DASD or
                  tape image (unloading),
            </p></li>
            <li>
               <p align="LEFT">create an ISAM dataset from an unloaded dataset,
            </p></li>
            <li>
               <p align="LEFT">print an ISAM dataset.
            </p></li>
         </ul>
         <p>IEBISAM requires the following DD statements:</p>
         <ul>
            <li>SYSPRINT - defines a sequential output message dataset.</li>
            <li>SYSUT1 - defines the input dataset</li>
            <li>SYSUT2 - defines the output dataset</li>
         </ul>
         <h3>&nbsp;</h3>
         <h3>Control Statements</h3>
         <blockquote>
            <p>There are no control statements.</p>
         </blockquote>
         <h3>&nbsp;</h3>
         <h3>Program Parameter (PARM= on EXEC statement)</h3>
         <blockquote>
            <p>The PARM parameter on the EXEC statement is used to control the execution of
               IEBISAM.&nbsp; The parameters are:
            </p>
            <p><a name="IEBISAMcopy"></a>COPY</p>
            <p>Specifies the input (ISAM) dataset is to be copied, 
creating an ISAM
               dataset.&nbsp; The SYSUT2 DD statement must include a 
primary space allocation that is sufficient to accommodate records that 
were contained in
               overflow areas in the original indexed sequential 
dataset. New overflow areas can
               be specified when the dataset is copied.
            </p>
            <p><a name="IEBISAMunload"></a>UNLOAD</p>
            <p>Specifies the input (ISAM) dataset is to be copied to a sequential dataset,
               creating a portable copy of the data records that may subsequently be reloaded
               to recreate the ISAM dataset.&nbsp; Regardless of the data record size in the
               ISAM dataset, the LRECL of the output dataset is always 80 bytes.&nbsp; If a
               block size is specified for the output dataset, it must be a multiple of 80
               bytes.
            </p>
            <p><a name="IEBISAMload"></a>LOAD</p>
            <p>Specifies the input dataset (created by IEBISAM with the 
UNLOAD function) is
               to be used to recreate an ISAM dataset.&nbsp; The input 
dataset, defined by the
               SYSUT1 DD statement, must have a record size of 80 bytes 
and the block size must
               be a multiple of 80 bytes.&nbsp; The SYSUT2 DD statement 
must include a primary space
               allocation that is sufficient to accommodate records that
 were contained in overflow areas in the original indexed sequential
               dataset.&nbsp;
               If new overflow areas are desired, they must be specified
 when the dataset is loaded.
            </p>
            <p><a name="IEBISAMprintl"></a>PRINTL [,N]</p>
            <p>Specifies the records of the input ISAM dataset are to be printed.&nbsp; If the device defined by the SYSUT2 DD statement is a
               printer, the specified BLKSIZE must be equal to or less than the physical printer
               size; that is 121, 133, or 145 bytes.&nbsp; If BLKSIZE is not specified, 121 bytes is
               assumed. LRECL (or BLKSIZE when no LRECL was specified) must be between 55 and 255 bytes.&nbsp;
               PRINTL specifies a print operation in which each record is converted to hexadecimal before printing.&nbsp;
               The N is an optional value that specifies that records are not to be converted to hexadecimal before printing.
            </p>
            <p><a name="IEBISAMexit"></a>EXIT=routinename</p>
            <p>Optionally specifies the name of an exit routine that is to receive control
               before each record is printed.&nbsp; If a user routine is supplied for a PRINTL operation, IEBISAM issues a LOAD
               macro instruction to make the user routine available.&nbsp; A BALR 14,15 instruction is
               subsequently used to give control to the routine.&nbsp; When the user routine receives
               control, register 0 contains a pointer to a record heading buffer; register 1 contains<br>
               a pointer to an input record buffer.
            </p>
         </blockquote>
         <h3>&nbsp;</h3>
         <h3>Examples</h3>
         <blockquote>
            <table width="75%" cellspacing="1" border="1">
               <tbody><tr>
                  <td width="33%">
                     <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="IEBISAMj01"></a>Copy
                        ISAM dataset blocking data records
                  </p></td>
               </tr>
               <tr>
                  <td width="33%">
                     <pre><b>//IEBISAMC JOB (1),'IEBISAM-COPY',                               
//             CLASS=A,MSGCLASS=X,REGION=2M,NOTIFY=&amp;SYSUID         
//IEBISAM EXEC PGM=IEBISAM,PARM='COPY'                           
//SYSPRINT DD SYSOUT=*                                             
//SYSUT1   DD DISP=OLD,DSN=JAY01.ISAM.MASTER,DCB=DSORG=IS          
//SYSUT2   DD DISP=(NEW,CATLG,DELETE),UNIT=SYSDA,VOL=SER=PUB000,   
//            DSN=JAY01.ISAM.MASTER.TWO,SPACE=(CYL,(5,5)), 
//            DCB=(DSORG=IS,RECFM=FB,LRECL=200,BLKSIZE=23400,
//            KEYLEN=7,RKP=1,CYLOFL=2,NTM=4,OPTCD=LMY)                
//</b></pre>
                  </td>
               </tr>
               <tr>
                  <td width="33%">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="IEBISAMj02"></a>Copy
                     ISAM dataset to portable copy (unloaded)
                  </td>
               </tr>
               <tr>
                  <td width="33%">
                     <pre><b>//IEBISAMU JOB (1),'IEBISAM-UNLOAD',                              
//             CLASS=A,MSGCLASS=X,REGION=2M,NOTIFY=&amp;SYSUID        
//IEBISAM EXEC PGM=IEBISAM,PARM='UNLOAD'                          
//SYSPRINT DD SYSOUT=*                                            
//SYSUT1   DD DISP=SHR,DSN=JAY01.ISAM.MASTER,DCB=DSORG=IS         
//SYSUT2   DD DISP=(NEW,KEEP),UNIT=TAPE,VOL=SER=21305B,  
//            DSN=JAY01.ISAM.MASTER.BACKUP,LABEL=(1,SL),
//            DCB=(RECFM=FB,LRECL=80,BLKSIZE=23440)               
//</b></pre>
                  </td>
               </tr>
               <tr>
                  <td width="33%">
                     <b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="IEBISAMj03"></a></b>Reload
                     ISAM dataset from unloaded copy
                  </td>
               </tr>
               <tr>
                  <td width="33%">
                     <pre><b>//IEBISAML JOB (1),'IEBISAM-RELOAD',                          
//             CLASS=A,MSGCLASS=X,REGION=2M,NOTIFY=&amp;SYSUID    
//IEBISAM EXEC PGM=IEBISAM,PARM='LOAD'                        
//SYSPRINT DD SYSOUT=*                                        
//SYSUT1   DD DISP=OLD,DSN=JAY01.ISAM.MASTER.BACKUP           
//SYSUT2   DD DISP=(NEW,CATLG,DELETE),DSN=JAY01.ISAM.MASTER,  
//            UNIT=SYSDA,VOL=SER=PUB000,SPACE=(CYL,(5,1)),    
//            DCB=(DSORG=IS,RECFM=FB,LRECL=200,BLKSIZE=23400, 
//            KEYLEN=7,RKP=1,CYLOFL=2,NTM=4,OPTCD=LMY)        
//</b></pre>
                  </td>
               </tr>
               <tr>
                  <td width="33%">
                     <b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="IEBISAMj04"></a></b>Print
                     ISAM data records
                  </td>
               </tr>
               <tr>
                  <td width="33%">
                     <pre><b>//IEBISAMP JOB (1),'IEBISAM-RELOAD',                          
//             CLASS=A,MSGCLASS=X,REGION=2M,NOTIFY=&amp;SYSUID    
//IEBISAM EXEC PGM=IEBISAM,PARM='PRINTL,N'
//SYSPRINT DD SYSOUT=*
//SYSUT1   DD DSN=JAY01.ISAM.MASTER,DISP=OLD,DCB=DSORG=IS 
//SYSUT2   DD SYSOUT=* 
// </b></pre>
                  </td>
               </tr>
            </tbody></table>
         </blockquote>
         <p><font size="1">Source:&nbsp; <a href="http://bitsavers.trailing-edge.com/pdf/ibm/370/OS_VS2/Release_3.8_1978/GC26-3902-1_OS_VS2_MVS_Utilities_Rel_3.8_Sep83.pdf" target="_blank">GC26-3902-1 OS/VS2 MVS Utilities Release 3.8</a></font></p>
         <hr size="8" noshade="noshade">
         <h2><a name="IEBPTPCH"></a>IEBPTPCH <font size="2">[supplied by IBM, located in
            SYS1.LINKLIB]</font>
         </h2>
         <p align="LEFT">Used to:&nbsp;</p>
         <ul>
            <li>
               <p align="LEFT">Print or punch a sequential or partitioned dataset in its
                  entirety.
            </p></li>
            <li>
               <p align="LEFT">Print or punch selected members from a partitioned dataset.
            </p></li>
            <li>
               <p align="LEFT">Print or punch selected records from a sequential or partitioned
                  dataset.
            </p></li>
            <li>
               <p align="LEFT">Print or punch the directory of a partitioned dataset.
            </p></li>
            <li>
               <p align="LEFT">Print or punch an edited version of a sequential or partitioned
                  dataset.
            </p></li>
         </ul>
         <p>IEBPTPCH requires the following DD statements:</p>
         <ul>
            <li>SYSPRINT - defines a sequential output message dataset.</li>
            <li>SYSIN - defines a sequential input dataset that contains IEBPTPCH control
               statements.
            </li>
            <li>SYSUT1 - defines the input dataset</li>
            <li>SYSUT2 - defines the output dataset&nbsp;</li>
         </ul>
         <p><b><font color="#0000FF">I would also suggest taking a look at LISTPDS and
            PDSPRINT.</font></b>
         </p>
         <h3>&nbsp;</h3>
         <h3>Control Statements</h3>
         <blockquote>
            <table width="50%" cellspacing="0" cellpadding="0" border="0">
               <tbody><tr>
                  <td width="10%">
                     <pre><a name="IEBPTPCHprint"></a>PRINT</pre>
                  </td>
                  <td width="90%">
                     <pre>[PREFORM={A | M}]</pre>
                  </td>
               </tr>
               <tr>
                  <td width="10%">
                     <pre></pre>
                  </td>
                  <td width="90%">
                     <pre>[,TYPORG={PS | PO}]</pre>
                  </td>
               </tr>
               <tr>
                  <td width="10%">
                     <pre></pre>
                  </td>
                  <td width="90%">
                     <pre>[,TOTCONV={XE | PZ}]</pre>
                  </td>
               </tr>
               <tr>
                  <td width="10%">
                     <pre></pre>
                  </td>
                  <td width="90%">
                     <pre>[,CNTRL={n | 1}]</pre>
                  </td>
               </tr>
               <tr>
                  <td width="10%">
                     <pre></pre>
                  </td>
                  <td width="90%">
                     <pre>[,STRTAFT=n]</pre>
                  </td>
               </tr>
               <tr>
                  <td width="10%">
                     <pre></pre>
                  </td>
                  <td width="90%">
                     <pre>[,STOPAFT=n]</pre>
                  </td>
               </tr>
               <tr>
                  <td width="10%">
                     <pre></pre>
                  </td>
                  <td width="90%">
                     <pre>[,SKIP=n]</pre>
                  </td>
               </tr>
               <tr>
                  <td width="10%">
                     <pre></pre>
                  </td>
                  <td width="90%">
                     <pre>[,MAXNAME=n]</pre>
                  </td>
               </tr>
               <tr>
                  <td width="10%">
                     <pre></pre>
                  </td>
                  <td width="90%">
                     <pre>[,MAXFLDS=n]</pre>
                  </td>
               </tr>
               <tr>
                  <td width="10%">
                     <pre></pre>
                  </td>
                  <td width="90%">
                     <pre>[,MAXGPS=n]</pre>
                  </td>
               </tr>
               <tr>
                  <td width="10%">
                     <pre></pre>
                  </td>
                  <td width="90%">
                     <pre>[,MAXLITS=n]</pre>
                  </td>
               </tr>
               <tr>
                  <td width="10%">
                     <pre></pre>
                  </td>
                  <td width="90%">
                     <pre>[,INITPG=n]</pre>
                  </td>
               </tr>
               <tr>
                  <td width="10%">
                     <pre></pre>
                  </td>
                  <td width="90%">
                     <pre>[,MAXLINE=n]</pre>
                  </td>
               </tr>
            </tbody></table>
            <p>The PRINT control statement specifies that the data is to be printed.&nbsp; If this is a print operation,
               the PRINT statement must be the first statement in the control statements.&nbsp;
               The parameters are:
            </p>
            <blockquote>
               <p>PREFORM = {A | M}</p>
               <blockquote>
                  <p>Specifies that a control character is provided as 
the first character of each
                     record to be printed.&nbsp; The control characters 
are used to control the spacing, number of lines per page,
                     and page ejection.&nbsp; That is, the output has 
been previously formatted, and the "standard specifications" are 
superseded.&nbsp; If an error occurs, the
                     print operation is terminated.&nbsp; If PREFORM is 
coded, any additional PRINT operands other than
                     TYPORG, and all other control statements except for
 LABELS, are ignored.&nbsp; Any ignored statement or operands are 
checked for correct syntax, however.&nbsp; PREFORM must not be used for 
printing datasets with VS or VBS records longer than 32K bytes.&nbsp; 
These values can be coded:
                  </p>
                  <ul>
                     <li>A - Specifies that an ASA control character is 
provided as the first character of each record to be printed.&nbsp; If 
the input record
                        length exceeds the output record length, the 
utility uses the ASA character for printing the first line, with a 
single space character on all
                        subsequent lines of the record.
                     </li>
                     <li>M - Specifies that a machine-code control 
character is provided as the first character of each record to be 
printed.&nbsp; If the input record
                        length exceeds the output record length, the 
utility prints all lines of the record with a print-skip-one-line 
character until the last line of the
                        record, which will contain the actual character 
provided as input.
                     </li>
                  </ul>
               </blockquote>
               <p>TYPORG={PS | PO}</p>
               <blockquote>
                  <p>Specifies the organization of the input dataset.&nbsp; These values can be coded:</p>
                  <ul>
                     <li>PS - Specifies that the input dataset is organized sequentially.</li>
                     <li>PO - Specifies that the input dataset is partitioned.</li>
                  </ul>
               </blockquote>
               <p>TOTCONV = {XE | PZ}</p>
               <blockquote>
                  <p>Specifies the representation of data to be printed 
or punched.&nbsp; TOTCONV can be overridden by any user specifications 
(RECORD
                     statements) that pertain to the same data.&nbsp; 
These values can be coded:
                  </p>
                  <ul>
                     <li>XE - Specifies that data is to be punched in 2-character-per-byte hexadecimal representation (for example, C3 40 F4 F6).&nbsp;
                        If XE is not specified, data is punched in 1-character per byte alphameric
                        representation.&nbsp; The above example would appear as C 46.
                     </li>
                     <li>PZ - Specifies that data (packed decimal mode) is to be converted to unpacked decimal mode.&nbsp;
                        IEBPTPCH does not check for packed decimal mode.&nbsp; The output is unpredictable when the input is
                        other than packed decimal.
                     </li>
                  </ul>
               </blockquote>
               <p>Default:&nbsp; If TOTCONV is omitted, data is not converted.</p>
               <p>CNTRL={n | 1}</p>
               <blockquote>
                  <p>Specifies a control character for the output device that indicates line spacing, as follows:</p>
                  <ul>
                     <li>1 indicates single spacing;</li>
                     <li>2 indicates double spacing; and</li>
                     <li>3 indicates triple spacing.</li>
                  </ul>
               </blockquote>
               <p>STRTAFT=n</p>
               <blockquote>
                  <p>Specifies, for sequential datasets, the number of 
logical records (physical blocks in the case of VS or VBS type records 
longer than 32K bytes) to
                     be skipped before printing begins.&nbsp; For 
partitioned datasets, STRTAFT=n specifies the number of logical records 
to be skipped in
                     each member before printing begins.&nbsp; The n 
value must not exceed 32,767.&nbsp; If STRTAFT is specified and RECORD
                     control statements are
                     present, the first RECORD control statement of a 
member describes the format of the first logical record to be printed.
                  </p>
               </blockquote>
               <p>STOPAFT=n</p>
               <blockquote>
                  <p>Specifies, for sequential datasets, the number of 
logical records (or physical blocks in the case of VS or VBS records 
longer than 32K bytes)
                     to be printed.&nbsp; For partitioned datasets, this
 specifies the number of logical records (or physical blocks in the case
 of VS or VBS
                     records longer than 32K bytes) to be printed in 
each member to be processed.&nbsp;
                     The n value must not exceed 32,767.&nbsp; If 
STOPAFT is specified and RECORD
                     control statements are present, the operation is
                     terminated when the STOPAFT count is satisfied or 
at the end of the first record group, whichever occurs first.
                  </p>
               </blockquote>
               <p>SKIP=n</p>
               <blockquote>
                  <p>Specifies that every nth record (or physical block 
in the case of VS or VBS records longer than 32K bytes) is to be 
printed.&nbsp;
                     Default:&nbsp; Successive logical records are 
printed.
                  </p>
               </blockquote>
               <p>MAXNAME=n</p>
               <blockquote>
                  <p>Specifies a number no less than the total number of
 subsequent MEMBER
                     control statements.&nbsp;
                     The value must not exceed 32,767.&nbsp; 
Default:&nbsp; If MAXNAME is omitted when there is a MEMBER statement
                     present, the print or punch request is terminated.
                  </p>
               </blockquote>
               <p>MAXFLDS=n</p>
               <blockquote>
                  <p>Specifies a number no less than the total number of FIELD parameters appearing in subsequent RECORD
                     control statements.&nbsp;
                     The value must not exceed 32,767.&nbsp; Default:&nbsp; If MAXFLDS is omitted when there is a
                     FIELD parameter present, the print or punch request is terminated.
                  </p>
               </blockquote>
               <p>MAXGPS=n</p>
               <blockquote>
                  <p>Specifies a number no less than the total number of IDENT parameters appearing in subsequent RECORD
                     control statements.&nbsp;
                     The value must not exceed 32,767.&nbsp; Default:&nbsp; If MAXGPS is omitted when there is an
                     IDENT parameter present, the print request is terminated.
                  </p>
               </blockquote>
               <p>MAXLITS=n</p>
               <blockquote>
                  <p>Specifies a number no less than the total number of characters contained in the IDENT literals of subsequent RECORD
                     control statements.&nbsp;
                     The value must not exceed 32,767.&nbsp; Default:&nbsp; If MAXLITS is omitted when
                     there is a literal present, the print request is terminated.
                  </p>
               </blockquote>
               <p>INITPG=n</p>
               <blockquote>
                  <p>Specifies the initial page number; the pages are numbered sequentially thereafter.&nbsp;
                     The INITPG parameter must not exceed a value of 9999.&nbsp; Default: 1
                  </p>
               </blockquote>
               <p>MAXLINE=n</p>
               <blockquote>
                  <p>Specifies the maximum number of lines to a printed page.&nbsp; Spaces, titles,
                     and subtitles are included in this number.&nbsp; Default: 60
                  </p>
               </blockquote>
            </blockquote>
            <hr color="#808080">
            <table width="50%" cellspacing="0" cellpadding="0" border="0">
               <tbody><tr>
                  <td width="10%">
                     <pre><a name="IEBPTPCHpunch"></a>PUNCH</pre>
                  </td>
                  <td width="90%">
                     <pre>[PREFORM={A | M}]</pre>
                  </td>
               </tr>
               <tr>
                  <td width="10%">
                     <pre></pre>
                  </td>
                  <td width="90%">
                     <pre>[,TYPORG={PS | PO}]</pre>
                  </td>
               </tr>
               <tr>
                  <td width="10%">
                     <pre></pre>
                  </td>
                  <td width="90%">
                     <pre>[,TOTCONV={XE | PZ}]</pre>
                  </td>
               </tr>
               <tr>
                  <td width="10%">
                     <pre></pre>
                  </td>
                  <td width="90%">
                     <pre>[,CNTRL={n | 1}]</pre>
                  </td>
               </tr>
               <tr>
                  <td width="10%">
                     <pre></pre>
                  </td>
                  <td width="90%">
                     <pre>[,STRTAFT=n]</pre>
                  </td>
               </tr>
               <tr>
                  <td width="10%">
                     <pre></pre>
                  </td>
                  <td width="90%">
                     <pre>[,STOPAFT=n]</pre>
                  </td>
               </tr>
               <tr>
                  <td width="10%">
                     <pre></pre>
                  </td>
                  <td width="90%">
                     <pre>[,SKIP=n]</pre>
                  </td>
               </tr>
               <tr>
                  <td width="10%">
                     <pre></pre>
                  </td>
                  <td width="90%">
                     <pre>[,MAXNAME=n]</pre>
                  </td>
               </tr>
               <tr>
                  <td width="10%">
                     <pre></pre>
                  </td>
                  <td width="90%">
                     <pre>[,MAXFLDS=n]</pre>
                  </td>
               </tr>
               <tr>
                  <td width="10%">
                     <pre></pre>
                  </td>
                  <td width="90%">
                     <pre>[,MAXGPS=n]</pre>
                  </td>
               </tr>
               <tr>
                  <td width="10%">
                     <pre></pre>
                  </td>
                  <td width="90%">
                     <pre>[,MAXLITS=n]</pre>
                  </td>
               </tr>
               <tr>
                  <td width="10%">
                     <pre></pre>
                  </td>
                  <td width="90%">
                     <pre>[,CDSEQ=n]</pre>
                  </td>
               </tr>
               <tr>
                  <td width="10%">
                     <pre></pre>
                  </td>
                  <td width="90%">
                     <pre>[,CDINCR=n]</pre>
                  </td>
               </tr>
            </tbody></table>
            <p> The PUNCH control statement specifies that the data is to be punched.&nbsp; If this is a punch
               operation, the PUNCH statement must be the first statement in the control
               statements.&nbsp; The parameters are:
            </p>
            <blockquote>
               <p>PREFORM={A | M}</p>
               <blockquote>
                  <p>Specifies that a control character is provided as 
the first character of each
                     record to be punched.&nbsp; The control characters 
are used to control selecting a stacker.&nbsp; That is, the output has 
been previously formatted,
                     and the "standard specifications" are 
superseded.&nbsp; If an error occurs, the
                     punch operation is terminated.&nbsp;
                     If PREFORM is coded, any additional PUNCH operands 
other than TYPORG, and all other control statements except for LABELS, 
are ignored.&nbsp;
                     Any ignored statement or operands are checked for 
correct syntax, however.&nbsp;
                     PREFORM must not be used for punching datasets with
 VS or VBS records longer than 32K bytes.&nbsp;
                     These values can be coded:
                  </p>
                  <ul>
                     <li>A - Specifies that an ASA control character is provided as the first character of each record to be punched.&nbsp;
                        If the input record length exceeds the output record length, the utility uses the ASA
                        character for punching first record, and duplicates the ASA
                        character on each output card of the record.
                     </li>
                     <li>M - Specifies that a machine-code control 
character is provided as the first character of each record to be 
punched.&nbsp;
                        If the input record length exceeds the output 
record length, the utility duplicates the machine control character on 
each output card of the record.
                     </li>
                  </ul>
               </blockquote>
               <p>TYPORG={PS | PO}</p>
               <blockquote>
                  <p>Specifies the organization of the input dataset.&nbsp; These values can be coded:</p>
                  <ul>
                     <li>PS - Specifies that the input dataset is organized sequentially.</li>
                     <li>PO - Specifies that the input dataset is partitioned.</li>
                  </ul>
               </blockquote>
               <p>TOTCONV = {XE | PZ}</p>
               <blockquote>
                  <p>Specifies the representation of data to be printed 
or punched.&nbsp; TOTCONV can be overridden by any user specifications 
(RECORD
                     statements) that pertain to the same data.&nbsp; 
These values can be coded:
                  </p>
                  <ul>
                     <li>XE - Specifies that data is to be punched in 
2-character-per-byte hexadecimal representation (for example, C3 40 F4 
F6).&nbsp; If XE is not
                        specified, data is punched in 1-character per 
byte alphameric representation.&nbsp; The above example would appear as C
 46.
                     </li>
                     <li>PZ - Specifies that data (packed decimal mode) 
is to be converted to unpacked decimal mode.&nbsp; IEBPTPCH does not 
check for packed
                        decimal mode.&nbsp; The output is unpredictable 
when the input is other than packed decimal.
                     </li>
                  </ul>
               </blockquote>
               <p>Default:&nbsp; If TOTCONV is omitted, data is not converted.</p>
               <p>CNTRL={n | 1}</p>
               <blockquote>
                  <p>Specifies a control character for the output device that is used to select the stacker, as follows:&nbsp;</p>
                  <ul>
                     <li>1 indicates the first stacker and&nbsp;</li>
                     <li> 2 indicates the second stacker.</li>
                  </ul>
               </blockquote>
               <p>STRTAFT=n</p>
               <blockquote>
                  <p>Specifies, for sequential datasets, the number of 
logical records (physical blocks in the case of VS or VBS type records 
longer than 32K bytes) to
                     be skipped before punching begins.&nbsp; For 
partitioned datasets,
                     STRTAFT=n specifies the number of logical records 
to be skipped in
                     each member before punching begins.&nbsp; The n 
value must not exceed 32,767.&nbsp;
                     If STRTAFT is specified and RECORD control 
statements are present, the first RECORD
                     control statement of a member describes the format
                     of the first logical record to be punched.
                  </p>
               </blockquote>
               <p>STOPAFT=n</p>
               <blockquote>
                  <p>Specifies, for sequential datasets, the number of 
logical records (or physical blocks in the case of VS or VBS records 
longer than 32K bytes)
                     to be punched.&nbsp; For partitioned datasets, this
 specifies the number of logical records (or physical blocks in the case
 of VS or VBS
                     records longer than 32K bytes) to be punched in 
each member to be processed.&nbsp; The n value must not exceed 
32,767.&nbsp; If STOPAFT is
                     specified and RECORD control statements are 
present, the operation is terminated when the STOPAFT count is satisfied
 or at the end of the
                     first record group, whichever occurs first.
                  </p>
               </blockquote>
               <p>SKIP=n</p>
               <blockquote>
                  <p>Specifies that every nth record (or physical block in the case of VS or
                     VBS records longer than 32K bytes) is to be punched.&nbsp; Default:&nbsp; Successive logical
                     records are punched.
                  </p>
               </blockquote>
               <p>MAXNAME=n</p>
               <blockquote>
                  <p>Specifies a number no less than the total number of
 subsequent MEMBER
                     control statements.&nbsp; The value must not exceed
 32,767.&nbsp;
                     Default:&nbsp; If MAXNAME is omitted when there is a
 MEMBER control statement present, the punch request is terminated.
                  </p>
               </blockquote>
               <p>MAXFLDS=n</p>
               <blockquote>
                  <p>Specifies a number no less than the total number of FIELD parameters appearing in subsequent RECORD
                     control statements.&nbsp; The value must not
                     exceed 32,767.&nbsp; Default:&nbsp; If MAXFLDS is omitted when there is a FIELD parameter
                     present, the punch request is terminated.
                  </p>
               </blockquote>
               <p>MAXGPS=n</p>
               <blockquote>
                  <p>Specifies a number no less than the total number of IDENT parameters appearing in subsequent RECORD
                     control statements.&nbsp; The value must not
                     exceed 32,767.&nbsp; Default:&nbsp; If MAXGPS is omitted when there is an IDENT parameter
                     present, the punch request is terminated.
                  </p>
               </blockquote>
               <p>MAXLITS=n</p>
               <blockquote>
                  <p>Specifies a number no less than the total number of
 characters contained in the IDENT literals of subsequent RECORD
                     control statements.&nbsp; The value
                     must not exceed 32,767.&nbsp; Default:&nbsp; If 
MAXLITS is omitted when there is a literal present, the punch request is
 terminated.
                  </p>
               </blockquote>
               <p>CDSEQ=n</p>
               <blockquote>
                  <p>Specifies the initial sequence number of a deck of 
punched cards.&nbsp;
                     This value must be contained in columns 73 through 
80.&nbsp; Sequence numbering is initialized for each member of a
                     partitioned dataset.&nbsp; If the value of n is 
zero, 00000000 is assumed as a starting sequence number.&nbsp;
                     Default:&nbsp; Cards are not numbered.
                  </p>
               </blockquote>
               <p>CDINCR=n</p>
               <blockquote>
                  <p>Specifies the increment to be used in generating sequence numbers.&nbsp; Default:&nbsp;
                     10 is the increment value.
                  </p>
               </blockquote>
            </blockquote>
            <hr color="#808080">
            <table width="50%" cellspacing="0" cellpadding="0" border="0">
               <tbody><tr>
                  <td width="10%">
                     <pre><a name="IEBPTPCHtitle"></a>TITLE</pre>
                  </td>
                  <td width="90%">
                     <pre> ITEM=('title'[,output-location])[,ITEM...]</pre>
                  </td>
               </tr>
            </tbody></table>
            <p> The TITLE control statement specifies that a title is to precede the printed or punched data.&nbsp; The TITLE
               control statement, if
               included, follows the PRINT or PUNCH control statement in the control dataset.&nbsp;
               The parameter is:
            </p>
            <blockquote>
               <p>ITEM=('title'[,output-location])[,ITEM...]</p>
               <blockquote>
                  <p>Specifies title or subtitle information.&nbsp; The values that can be coded are:</p>
                  <ul>
                     <li>'title' - Specifies the title or subtitle literal (maximum length of 40 bytes), enclosed in apostrophes.&nbsp;
                        If the literal contains apostrophes, each apostrophe must be written as two consecutive apostrophes.
                     </li>
                     <li>output-location - Specifies the starting position at which the literal for this item is to be placed in the output record.&nbsp;
                        The specified title may not exceed the output logical record length minus one.&nbsp;
                        Default: 1
                     </li>
                  </ul>
               </blockquote>
            </blockquote>
            <hr color="#808080">
            <table width="50%" cellspacing="0" cellpadding="0" border="0">
               <tbody><tr>
                  <td width="10%">
                     <pre><a name="IEBPTPCHexits"></a>EXITS</pre>
                  </td>
                  <td width="90%">
                     <pre>[INHDR=routinename]</pre>
                  </td>
               </tr>
               <tr>
                  <td width="10%">
                     <pre></pre>
                  </td>
                  <td width="90%">
                     <pre>[,INTLR=routinename]</pre>
                  </td>
               </tr>
               <tr>
                  <td width="10%">
                     <pre></pre>
                  </td>
                  <td width="90%">
                     <pre>[,INREC=routinename]</pre>
                  </td>
               </tr>
               <tr>
                  <td width="10%">
                     <pre></pre>
                  </td>
                  <td width="90%">
                     <pre>[OUTREC=routinename]</pre>
                  </td>
               </tr>
            </tbody></table>
            <p> The EXITS control statement specifies that user routines
 are provided.&nbsp; Exits to label processing routines are ignored if 
the input
               dataset is partitioned.&nbsp;
               The EXITS control statement statement, if included, must 
immediately follow any TITLE
               control statement or follow the PRINT or PUNCH control 
statement.&nbsp; The parameters are:
            </p>
            <ul>
               <li>INHDR=routinename - Specifies the symbolic name of a routine that processes user input header labels.</li>
               <li>INTLR=routinename - Specifies the symbolic name of a routine that processes user input trailer
                  labels.
               </li>
               <li>INREC=routinename - Specifies the symbolic name of a 
routine that manipulates each logical record (or physical block in the 
case of VS or VBS records longer than
                  32K bytes) before it is processed.
               </li>
               <li>OUTREC=routinename - Specifies the symbolic name of a
 routine that manipulates each logical record (or physical block in the 
case of VS or VBS records longer than
                  32K bytes) before it is printed or punched.
               </li>
            </ul>
            <hr color="#808080">
            <table width="50%" cellspacing="0" cellpadding="0" border="0">
               <tbody><tr>
                  <td width="10%">
                     <pre><a name="IEBPTPCHmember"></a>MEMBER</pre>
                  </td>
                  <td width="90%">
                     <pre>NAME={membername | aliasname}</pre>
                  </td>
               </tr>
            </tbody></table>
            <p> The MEMBER control statement specifies that the input is a partitioned dataset and that a selected member is
               to be printed or punched.&nbsp; The parameter is:
            </p>
            <blockquote>
               <p>NAME={membemame | aliasname}</p>
               <blockquote>
                  <p>Specifies a member to be printed or punched.&nbsp; These values can be coded:</p>
                  <ul>
                     <li>membername - Specifies a member by its member name.</li>
                     <li>aliasname - Specifies a member by its alias.</li>
                  </ul>
               </blockquote>
            </blockquote>
            <hr color="#808080">
            <table width="50%" cellspacing="0" cellpadding="0" border="0">
               <tbody><tr>
                  <td width="10%">
                     <pre><a name="IEBPTPCHrecord"></a>RECORD</pre>
                  </td>
                  <td width="90%">
                     <pre>[IDENT=(length,'name',input-location)]</pre>
                  </td>
               </tr>
               <tr>
                  <td width="10%">
                     <pre></pre>
                  </td>
                  <td width="90%">
                     <pre>[,FIELD=(length,[input-location],[conversion]</pre>
                  </td>
               </tr>
               <tr>
                  <td width="10%">
                     <pre></pre>
                  </td>
                  <td width="90%">
                     <pre>,[output-location])[,FIELD=...]</pre>
                  </td>
               </tr>
            </tbody></table>
            <p> The RECORD control statement specifies whether editing is to be performed, that is, records are to be printed
               or punched to nonstandard specifications.&nbsp; The parameters are:
            </p>
            <blockquote>
               <p>IDENT=(length,'name',input-location)</p>
               <blockquote>
                  <p>Identifies the last record of the record group to which the FIELD parameters apply.&nbsp;
                     The values that can be coded are:
                  </p>
                  <ul>
                     <li>length - Specifies the length (in bytes) of the field that contains the identifying
                        name in the input records.&nbsp; The length cannot exceed eight bytes.
                     </li>
                     <li>'name' - Specifies the exact literal that identifies the last record of a record
                        group.&nbsp; If the literal contains apostrophes, each must be written as two
                        consecutive apostrophes.
                     </li>
                     <li>input-location - Specifies the starting location of the field that contains the identifying
                        name in the input records.
                     </li>
                  </ul>
               </blockquote>
               <p>Note:&nbsp; The sum of the length and the input 
location must be equal to
                  or less than the input LRECL plus one.&nbsp; 
Default:&nbsp; If IDENT is omitted and STOPAFT is not included with the
                  PRINT or PUNCH control statement, record processing 
halts after the last record in the
                  dataset.&nbsp;
                  If IDENT is omitted and STOPAFT is included with the 
PRINT or PUNCH control statement, record processing halts when the
                  STOPAFT count is satisfied or after the last record of
 the dataset is processed, whichever occurs first.
               </p>
               <p>FIELD=(length,[input-location],[conversion],[output-location])</p>
               <blockquote>
                  <p>Specifies field-processing and editing information.&nbsp; These values can be
                     coded:
                  </p>
                  <ul>
                     <li>length - Specifies the length (in bytes) of the
 input field to be processed.&nbsp; Note: The length must be equal to or
 less than the initial input
                        LRECL.
                     </li>
                     <li>input-location - Specifies the starting byte of the input field to be processed.&nbsp;
                        Default: 1&nbsp; Note: The sum of the length and the input location must be equal to or
                        less than the input LRECL plus one.
                     </li>
                     <li>
                        conversion - Specifies a two-byte code that indicates the type of conversion to be
                        performed on this field before it is printed or punched.&nbsp; The values that
                        can be coded are:
                        <ul>
                           <li>PZ - Specifies that data (packed decimal) is to be converted to unpacked decimal data.&nbsp;
                              The converted portion of the input record (length L) occupies 2L - 1 output characters
                              when punching, and 2L output characters when printing.
                           </li>
                           <li>XE - Specifies that data (alphameric) is to be converted to hexadecimal data.&nbsp;
                              The converted portion of the input record (length L) occupies 2L output characters.
                           </li>
                        </ul>
                        <p>Default: The field is moved to the output area without change.</p>
                     </li><li>output-location - Specifies the starting 
location of this field in the output records.
                        Unspecified fields in the output records appear 
as blanks in the printed
                        or punched output.&nbsp; Data that exceeds the 
SYSUT2 printer or punch size is not printed or punched.&nbsp;
                        The specified fields may not exceed the logical 
output record length minus one.&nbsp;
                        When specifying one or more FIELDs, the sum of 
all lengths and all extra characters needed for
                        conversions must be equal to or less than the 
output LRECL minus one.
                     </li>
                     <p>Default: 1</p>
                  </ul>
               </blockquote>
            </blockquote>
            <hr color="#808080">
            <table width="50%" cellspacing="0" cellpadding="0" border="0">
               <tbody><tr>
                  <td width="10%">
                     <pre><a name="IEBPTPCHlabels"></a>LABELS</pre>
                  </td>
                  <td width="90%">
                     <pre>[CONV={PZ | XE}]</pre>
                  </td>
               </tr>
               <tr>
                  <td width="10%">
                     <pre></pre>
                  </td>
                  <td width="90%">
                     <pre>[,DATA={YES | NO | ALL | ONLY}]</pre>
                  </td>
               </tr>
            </tbody></table>
            <p>The LABELS control statement specifies whether user labels are to be treated as data.&nbsp; The parameters
               are:
            </p>
            <blockquote>
               <p>CONV={PZ I XE}</p>
               <blockquote>
                  <p>Specifies a two-byte code that indicates the type of conversion to be performed on this field before it is printed
                     or punched.&nbsp; The values that can be coded are:
                  </p>
                  <ul>
                     <li>PZ - Specifies that data (packed decimal) is to be converted to unpacked decimal data.&nbsp;
                        The converted portion of the input record (length L) occupies 2L - 1 output
                        characters.
                     </li>
                     <li>XE - Specifies that data (alphameric) is to be converted to hexadecimal data.&nbsp;
                        The converted portion of the input record (length L) occupies 2L output characters.
                     </li>
                  </ul>
               </blockquote>
               <p>Default:&nbsp; The field is moved to the output area without change.</p>
               <p>DATA={YES | NO | ALL | ONLY}</p>
               <blockquote>
                  <p>Specifies whether user labels are to be treated as data.&nbsp; The values that can be coded are:</p>
                  <ul>
                     <li>YES - Specifies that any user labels that are not rejected by a user's label processing routine are to be treated as data.&nbsp;
                        Processing of labels as data stops in compliance with standard return codes.
                     </li>
                     <li>NO - Specifies that user labels are not to be treated as data.</li>
                     <li>ALL - Specifies that user labels are to be treated as data regardless of any return code.&nbsp;
                        A return code of 16 causes the utility to complete the processing of the
                        remainder of the group of user labels and to terminate the job step.
                     </li>
                     <li>ONLY - Specifies that only user header labels are to be treated as data.&nbsp;
                        User header labels are processed as data regardless of any return code.&nbsp;
                        The job terminates upon return from the&nbsp; OPEN routine.&nbsp;
                     </li>
                  </ul>
               </blockquote>
            </blockquote>
         </blockquote>
         <h3>&nbsp;</h3>
         <h3>Examples</h3>
         <blockquote>
            <table width="75%" cellspacing="1" border="1">
               <tbody><tr>
                  <td width="33%">
                     <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="IEBPTPCHj01"></a>Print
                        sequential dataset with conversion to hex
                  </p></td>
               </tr>
               <tr>
                  <td width="33%">
                     <pre><b>//IEBPTPCH JOB (001),'PRINT SEQ DS   ',CLASS=A,MSGCLASS=X    
//IEBPTPCH EXEC PGM=IEBPTPCH,REGION=1M                       
//SYSPRINT  DD  SYSOUT=*                                     
//SYSUT1    DD  DISP=SHR,DSN=JAY01.ISAMVSAM.DATA             
//SYSUT2    DD  SYSOUT=*                                     
//SYSIN     DD  *                                            
  PRINT TOTCONV=XE                                           
  TITLE ITEM=('PRINT SEQ DATASET WITH CONV TO HEX',10)       
//</b></pre>
                  </td>
               </tr>
               <tr>
                  <td width="33%">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="IEBPTPCHj02"></a>Print
                     partitioned dataset, 10 records from each member
                  </td>
               </tr>
               <tr>
                  <td width="33%">
                     <pre><b>//IEBPTPCH JOB (001),'PRINT PDS 10 EA',CLASS=A,MSGCLASS=X 
//IEBPTPCH EXEC PGM=IEBPTPCH,REGION=1M                    
//SYSPRINT  DD  SYSOUT=*                                  
//SYSUT1    DD  DISP=SHR,DSN=JAY01.ALL.PTFS               
//SYSUT2    DD  SYSOUT=*                                  
//SYSIN     DD  *                                         
  PRINT TYPORG=PO,STOPAFT=10                              
  TITLE ITEM=('PRINT PDS - 10 RECORDS EACH MEM',10)       
//</b></pre>
                  </td>
               </tr>
               <tr>
                  <td width="33%">
                     <b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="IEBPTPCHj03"></a></b>Copy
                     all members from PDS onto single file on tape
                  </td>
               </tr>
               <tr>
                  <td width="33%">
                     <pre><b>//IEBPTPCH JOB (001),'COPY PDS TO TAPE',CLASS=A,MSGCLASS=X      
//IEBPTPCH EXEC PGM=IEBPTPCH,REGION=2M                         
//SYSPRINT  DD  SYSOUT=*                                        
//SYSUT1    DD  DISP=SHR,DSN=JAY01.ALL.PTFS                     
//SYSUT2    DD  UNIT=TAPE,VOL=SER=PTFS21,DISP=(,KEEP,DELETE),   
//              DSN=PTFS,DCB=(RECFM=FB,LRECL=80,BLKSIZE=7200)   
//SYSIN     DD  *                                               
  PUNCH TYPORG=PO,MAXFLDS=1                                    
//                                                             
//</b></pre>
                  </td>
               </tr>
               <tr>
                  <td width="33%">
                     <b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="IEBPTPCHj04"></a></b>Print
                     two members of PDS
                  </td>
               </tr>
               <tr>
                  <td width="33%">
                     <pre><b>//IEBPTPCH JOB (001),'PRINT 2 PDS MEMBERS',CLASS=A,MSGCLASS=X   
//IEBPTPCH EXEC PGM=IEBPTPCH,REGION=2M                      
//SYSPRINT DD  SYSOUT=*                                     
//SYSUT1   DD  DISP=SHR,DSN=JAY01.ISAM.COBOL                
//SYSUT2   DD  SYSOUT=*              <font color="#0000FF">change to SYSOUT=B to produce cards</font>                       
//SYSIN    DD  *                                            
  PUNCH TYPORG=PO,MAXFLDS=1,MAXNAME=2                       
  MEMBER NAME=ISREPT1                                       
  MEMBER NAME=ISREPT2                                       
//                                                          
//</b></pre>
                  </td>
               </tr>
               <tr>
                  <td width="33%">
                     <b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="IEBPTPCHj05"></a></b>Resequence
                     card deck
                  </td>
               </tr>
               <tr>
                  <td width="33%">
                     <pre><b>//SEQCARDS JOB (001),SEQCARDS,CLASS=A,MSGCLASS=X
//IEBPTPCH EXEC PGM=IEBPTPCH
//SYSPRINT DD SYSOUT=*
//SYSUT1   DD *
</b>
&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">[<i>card deck to be resequenced goes here</i>]</font>

<b>/*
//SYSUT2   DD SYSOUT=B
//SYSIN    DD *
&nbsp;&nbsp; PUNCH MAXFIELDS=1,CDSEQ=0,CDINCR=100
&nbsp;&nbsp; RECORD FIELD=(72)
/*
//</b></pre>
                  </td>
               </tr>
            </tbody></table>
         </blockquote>
         <p><font size="1">Source:&nbsp; <a href="http://bitsavers.trailing-edge.com/pdf/ibm/370/OS_VS2/Release_3.8_1978/GC26-3902-1_OS_VS2_MVS_Utilities_Rel_3.8_Sep83.pdf" target="_blank">GC26-3902-1 OS/VS2 MVS Utilities Release 3.8</a></font></p>
         <hr size="8" noshade="noshade">
         <h2><a name="IEBUPDTE"></a>IEBUPDTE <font size="2">[supplied by IBM, located in
            SYS1.LINKLIB]</font>
         </h2>
         <p align="LEFT">Used to incorporate IBM and user-generated source
         language modifications into sequential or partitioned datasets.&nbsp;
            Exits are provided for user routines that process user header and trailer labels.
         </p>
         <p align="LEFT">IEBUPDTE can be used to:</p>
         <ul>
            <li>
               <p align="LEFT">Create and update symbolic libraries.
            </p></li>
            <li>
               <p align="LEFT">Incorporate changes to partitioned members or sequential datasets.
            </p></li>
            <li>
               <p align="LEFT">Change the organization of a dataset from sequential to partitioned or vice
                  versa.
            </p></li>
         </ul>
         <p>IEBUPDTE requires the following DD statements:</p>
         <ul>
            <li>SYSPRINT - defines a sequential output message dataset.</li>
            <li>SYSIN - defines a sequential input control dataset.</li>
            <li>SYSUT1 - defines the input dataset</li>
            <li>SYSUT2 - defines the output dataset</li>
         </ul>
         <p><b><font color="#0000FF">IEBUPDTE originated in an age that preceded full
            screen editing, so much of its functionality is devoted to applying updates to
            partitioned datasets in a batch job.&nbsp; In the current era, IEBUPDTE is
            mainly used to reload or add members to partitioned datasets.&nbsp; I would suggest taking a look at OFFLOAD,
            PDSLOAD, UPDTE, UNUPDTE, PDSPRINT and REVLMOD, which were written to efficiently
            perform load, unload, and reload functions on partitioned datasets.</font></b>
         </p>
         <h3>&nbsp;</h3>
         <h3>Control Statements</h3>
         <blockquote>
            <p>All control statements are read from the SYSIN DD with data statements
               interspersed.&nbsp; In order for IEBUPDTE to recognize the control statements,
               each control statement must contain a period in column 1, followed by a slash in
               column 2, followed by a space in column 3.&nbsp; An optional label may appear
               next on the control statement, followed by a blank, then the action word.
            </p>
            <table width="50%" cellspacing="0" cellpadding="0" border="0">
               <tbody><tr>
                  <td width="4%">
                     <pre>./</pre>
                  </td>
                  <td width="96%">
                     <pre><a name="IEBUPDTEadd"></a>ADD | <a name="IEBUPDTEchange"></a>CHANGE | <a name="IEBUPDTErepl"></a>REPL | <a name="IEBUPDTErepro"></a>REPRO</pre>
                  </td>
               </tr>
               <tr>
                  <td width="4%">
                     <pre></pre>
                  </td>
                  <td width="96%">
                     <pre>[LIST=ALL]</pre>
                  </td>
               </tr>
               <tr>
                  <td width="4%">
                     <pre></pre>
                  </td>
                  <td width="96%">
                     <pre>[,SEQFLD={ }]</pre>
                  </td>
               </tr>
               <tr>
                  <td width="4%">
                     <pre></pre>
                  </td>
                  <td width="96%">
                     <pre>[,NEW={PO | PS}]</pre>
                  </td>
               </tr>
               <tr>
                  <td width="4%">
                     <pre></pre>
                  </td>
                  <td width="96%">
                     <pre>[,MEMBER=membername]</pre>
                  </td>
               </tr>
               <tr>
                  <td width="4%">
                     <pre></pre>
                  </td>
                  <td width="96%">
                     <pre>[,COLUMN=dd]</pre>
                  </td>
               </tr>
               <tr>
                  <td width="4%">
                     <pre></pre>
                  </td>
                  <td width="96%">
                     <pre>[,UPDATE=INPLACE]</pre>
                  </td>
               </tr>
               <tr>
                  <td width="4%">
                     <pre></pre>
                  </td>
                  <td width="96%">
                     <pre>[,INHDR=routinename]</pre>
                  </td>
               </tr>
               <tr>
                  <td width="4%">
                     <pre></pre>
                  </td>
                  <td width="96%">
                     <pre>[,INTLR=routinename]</pre>
                  </td>
               </tr>
               <tr>
                  <td width="4%">
                     <pre></pre>
                  </td>
                  <td width="96%">
                     <pre>[OUTHDR=routinename]</pre>
                  </td>
               </tr>
               <tr>
                  <td width="4%">
                     <pre></pre>
                  </td>
                  <td width="96%">
                     <pre>[OUTLR=routinename]</pre>
                  </td>
               </tr>
               <tr>
                  <td width="4%">
                     <pre></pre>
                  </td>
                  <td width="96%">
                     <pre>[,TOTAL=routinename,size]</pre>
                  </td>
               </tr>
               <tr>
                  <td width="4%">
                     <pre></pre>
                  </td>
                  <td width="96%">
                     <pre>[,NAME=membername]</pre>
                  </td>
               </tr>
               <tr>
                  <td width="4%">
                     <pre></pre>
                  </td>
                  <td width="96%">
                     <pre>[,LEVEL=hh]</pre>
                  </td>
               </tr>
               <tr>
                  <td width="4%">
                     <pre></pre>
                  </td>
                  <td width="96%">
                     <pre>[,SOURCE=x]</pre>
                  </td>
               </tr>
               <tr>
                  <td width="4%">
                     <pre></pre>
                  </td>
                  <td width="96%">
                     <pre>[,SSI=hhhhhhhh]</pre>
                  </td>
               </tr>
            </tbody></table>
            <p>The Function control statement is used to initiate an IEBUPDTE operation.&nbsp; At least one
               Function control statement must be provided for each member or dataset to be processed.&nbsp;
               The function actions are:
            </p>
            <blockquote>
               <p>ADD</p>
               <blockquote>
                  <p>Specifies that a member or a dataset is to be added
 to an old master dataset.&nbsp;
                     If a member is to be added and the member name 
already exists in the old master dataset, processing is 
terminated.&nbsp;
                     If, however, PARM=NEW is specified on the EXEC 
statement, the member is replaced.&nbsp;
                     For a sequential output master dataset, PARM=NEW 
must always be specified on the EXEC statement.
                  </p>
                  <p>When a member replaces an identically named member 
on the old master dataset or a member is changed and rewritten on the 
old master, the alias (if any) of the
                     original member still refers to the original 
member.&nbsp; However, if an identical alias is
                     specified for the newly written member, the 
original alias entry in the directory is
                     changed to refer to the newly written member.
                  </p>
               </blockquote>
               <p>CHANGE</p>
               <blockquote>
                  <p>Specifies that a member of a dataset is being entered in its entirety as a replacement for a sequential
                     dataset or for a member of the old master dataset.&nbsp; The member name must already exist in
                     the old master dataset.
                  </p>
               </blockquote>
               <p>REPL</p>
               <blockquote>
                  <p>Specifies that a member of a dataset is being entered in its entirety as a replacement for a sequential
                     dataset or for a member of the old master dataset.&nbsp; The member name must already exist in
                     the old master dataset.
                  </p>
               </blockquote>
               <p>REPRO</p>
               <blockquote>
                  <p>Specifies that a member or a dataset is to be copied in its entirety to a new master
                     dataset.
                  </p>
               </blockquote>
            </blockquote>
            <p>The Function control statement parameters are:</p>
            <blockquote>
               <p>LIST=ALL</p>
               <blockquote>
                  <p>Specifies that the SYSPRINT dataset is to contain 
the entire updated member or
                     dataset and the control statements used in its 
creation.&nbsp; Default:&nbsp; For old
                     datasets, if LIST is omitted, the SYSPRINT dataset 
contains modifications and control
                     statements only.&nbsp; If UPDATE was specified, the
 entire updated member is listed only when renumbering has been
                     done.&nbsp; For new datasets, the entire member or 
dataset and the control statements used in its creation are always
                     written to the SYSPRINT dataset.
                  </p>
               </blockquote>
               <p>SEQFLD={ddl | (ddl,ddl)}</p>
               <blockquote>
                  <p>ddl</p>
                  <blockquote>
                     <p>Specifies, in decimal, the starting column (up 
to column 80) and length (8 or less) of sequence numbers within existing
 logical records and subsequent data statements.&nbsp;
                        Note that the starting column specification (dd)
 plus the length (l) cannot exceed the logical record length (LRECL) 
plus 1.&nbsp;
                        Sequence numbers on incoming data statements and
 existing logical records must be padded to the left with enough zeros 
to fill the length of the sequence field.
                     </p>
                  </blockquote>
                  <p>(ddt, ddt)</p>
                  <blockquote>
                     <p>May be used when an alphameric sequence number 
generation is required.&nbsp; The first ddt specifies the sequence
                        number columns as above.&nbsp; The second ddt 
specifies, in decimal, the starting column
                        (up to column 80) and length (8 or less) of the 
numeric portion of the sequence numbers
                        in subsequent NUMBER statements.&nbsp; This 
information is used to determine which portion of the sequence
                        number specified by the NEW1 parameter may be 
incremented and which portion(s) should be copied to generate a new
                        sequence number for inserted or renumbered 
records.&nbsp; Note:&nbsp; The numeric
                        columns must fall within the sequence number 
columns specified (or defaulted) by the first
                        ddt.&nbsp; Acceptable alphameric characters are 
A-Z, 1-9, @, #, $, *.&nbsp; Default: 738 is assumed, that is, an
                        eight-byte sequence number beginning in column 
73.&nbsp; Therefore, if existing logical records and subsequent Data 
statements have
                        sequence numbers in columns 73 through 80, this 
keyword need not be coded.
                     </p>
                  </blockquote>
               </blockquote>
               <p>NEW={PO | PS}</p>
               <blockquote>
                  <p>Specifies the organization of the old master dataset and the organization of the updated output.&nbsp;
                     NEW should not be specified unless the organization of the new master dataset
                     is different from the organization of the old master.&nbsp; These values can be coded:
                  </p>
                  <ul>
                     <li>PO - Specifies that the old master dataset is a sequential dataset, and that the updated output is to become a member of
                        a partitioned dataset.
                     </li>
                     <li>PS - Specifies that the old master dataset is a partitioned dataset, and that a member of that
                        dataset is to be converted into a sequential dataset.
                     </li>
                  </ul>
               </blockquote>
               <p>MEMBER=membername</p>
               <blockquote>
                  <p>Specifies, a name to be assigned to the member placed in the partitioned dataset
                     defined by the SYSUT2 DD statement.&nbsp; MEMBER is used only when SYSUT1 defines a
                     sequential dataset, SYSUT2 defines a partitioned dataset, and NEW=PO is specified.
                  </p>
               </blockquote>
               <p>COLUMN=dd</p>
               <blockquote>
                  <p>Note:&nbsp; Used only with CHANGE.&nbsp; Specifies, in decimal, the starting column of a data field
                     within a logical record image.&nbsp; The field extends to the end of the image.&nbsp;
                     Within an existing logical record, the data in the defined field is replaced by data from a subsequent
                     Data statement.
                  </p>
               </blockquote>
               <p>UPDATE=INPLACE</p>
               <blockquote>
                  <p>Note: Used only with CHANGE.&nbsp; Specifies that 
the old master dataset is to be updated
                     within the space it actually occupies.&nbsp; The 
old master dataset must reside on a direct access device. UPDATE is 
valid&nbsp;
                     only when coded with CHANGE.&nbsp; No other 
function statements (ADD, REPL, REPRO) may be in the same
                     job step.
                  </p>
               </blockquote>
               <p>INHDR=routinename</p>
               <blockquote>
                  <p>Specifies the symbolic name of the user routine 
that handles any user input (SYSUTl) header labels.&nbsp;
                     When used with UPDATE, this routine assumes a 
special function.&nbsp; This parameter is valid only when a sequential
                     dataset is being processed.
                  </p>
               </blockquote>
               <p>INTLR=routinename</p>
               <blockquote>
                  <p>Specifies the symbolic name of the user routine that handles any user input (SYSUTl) trailer labels.&nbsp;
                     INTLR is valid only when a sequential dataset is being processed, but not when UPDATE is coded.
                  </p>
               </blockquote>
               <p>OUTHDR=routinename</p>
               <blockquote>
                  <p>Specifies the symbolic name of the user routine that handles any user output (SYSUT2) header labels.&nbsp;
                     OUTHDR is valid only when a sequential dataset is being processed, but not when UPDATE is coded.
                  </p>
               </blockquote>
               <p>OUTLR=routinename</p>
               <blockquote>
                  <p>Specifies the symbolic name of the user routine that handles any user output (SYSUT2) trailer labels.&nbsp;
                     OUTTLR is valid only when a sequential dataset is being processed, but not when UPDATE is coded.
                  </p>
               </blockquote>
               <p>TOTAL=routinename,size</p>
               <blockquote>
                  <p>Specifies that exits to a user's routine are to be provided prior to writing each record.&nbsp;
                     This parameter is valid only when a sequential dataset is being processed.&nbsp;
                     These values are coded:
                  </p>
                  <ul>
                     <li>routinename - Specifies the name of the user's totaling routine.</li>
                     <li>size - Specifies the number of bytes required 
for the user's data.&nbsp; The size should not exceed 32K, nor be less 
than 2 bytes.&nbsp;
                        In addition, the keyword OPTCD=T must be 
specified for the SYSUT2 (output) DD statement.
                     </li>
                  </ul>
               </blockquote>
               <p>NAME=membername</p>
               <blockquote>
                  <p>Specifies the name of the member placed into the partitioned dataset.&nbsp; The member name need not be
                     specified in the DD statement itself.&nbsp; NAME must be provided to identify each input member.&nbsp;
                  </p>
                  <p>This parameter is valid only when a member of a partitioned dataset is being processed.</p>
               </blockquote>
               <p>LEVEL=hh</p>
               <blockquote>
                  <p>Specifies the change (update) level in hexadecimal (00-FF).&nbsp; The level number is recorded in the directory
                     entry of the output member.&nbsp; This parameter is valid only when a member of a partitioned
                     dataset is being processed.&nbsp; This parameter has no effect when SSI is
                     specifed.
                  </p>
               </blockquote>
               <p>SOURCE=x</p>
               <blockquote>
                  <p>Specifies user modifications when the x value is 0,
 or IBM modifications when the x value is 1.&nbsp;
                     The source is recorded in the directory entry of 
the output member.&nbsp; This parameter is valid only when a
                     member of a partitioned dataset is being 
processed.&nbsp; This parameter has no effect
                     when SSI is specified.
                  </p>
               </blockquote>
               <p>SSI=hhhhhhhh</p>
               <blockquote>
                  <p>Specifies eight hexadecimal characters of system status information (SSI) to be placed in the directory of the new
                     master dataset as four packed hexadecimal bytes of user data.&nbsp; This parameter is valid only
                     when a member of a partitioned dataset is being processed.&nbsp; SSI overrides any
                     LEVEL or SOURCE data given on the same Function statement.
                  </p>
               </blockquote>
            </blockquote>
            <hr color="#808080">
            <table width="50%" cellspacing="0" cellpadding="0" border="0">
               <tbody><tr>
                  <td width="4%">
                     <pre>./</pre>
                  </td>
                  <td width="96%">
                     <pre><a name="IEBUPDTEnumber"></a>NUMBER | <a name="IEBUPDTEdelete"></a>DELETE</pre>
                  </td>
               </tr>
               <tr>
                  <td width="4%">
                     <pre></pre>
                  </td>
                  <td width="96%">
                     <pre>[SEQ1={cccccccc | ALL}]</pre>
                  </td>
               </tr>
               <tr>
                  <td width="4%">
                     <pre></pre>
                  </td>
                  <td width="96%">
                     <pre>[,SEQ2=cccccccc]</pre>
                  </td>
               </tr>
               <tr>
                  <td width="4%">
                     <pre></pre>
                  </td>
                  <td width="96%">
                     <pre>[,NEW1=cccccccc]</pre>
                  </td>
               </tr>
               <tr>
                  <td width="4%">
                     <pre></pre>
                  </td>
                  <td width="96%">
                     <pre>[,INCR=nnnnnnnn]</pre>
                  </td>
               </tr>
               <tr>
                  <td width="4%">
                     <pre></pre>
                  </td>
                  <td width="96%">
                     <pre>[,INSERT=YES]</pre>
                  </td>
               </tr>
            </tbody></table>
            <p>A Detail control statement is used with a Function 
control statement for certain applications, such
               as deleting or renumbering selected logical 
records.&nbsp; NUMBER specifies, when
               coded with a CHANGE Function control statement, that the 
sequence number of one or more logical records is to be changed.&nbsp;
               It specifies, when coded with an ADD or REPL Function 
control statement, the sequence numbers to be assigned to the records
               within new or replacement members or 
datasets.&nbsp;&nbsp; When used with an ADD or
               REPL Function control statement, no more than one NUMBER 
Detail control statement is permitted for each ADD or REPL Function
               control statement. If NUMBER is coded, it
               must be preceded and followed by at least&nbsp; one 
blank.&nbsp; DELETE specifies, when
               coded with a CHANGE Function control statement, that one 
or more logical records are to be deleted from a member or
               dataset.&nbsp; If DELETE is coded, it must be preceded 
and followed by at least one blank.&nbsp;&nbsp;
            </p>
            <p>When INSERT is coded on the Function control statement:</p>
            <ul>
               <li>The SEQ1 parameter specifies the existing logical record after which the insertion is to be made.&nbsp;
                  The SEQ2 parameter need not be coded; SEQ1=ALL cannot be coded.
               </li>
               <li>The NEWl parameter assigns a sequence number to the first logical record to be
                  inserted.&nbsp; If the parameter is alphameric, the SEQFLD=(ddl,ddl) parameter
                  should be coded .
               </li>
               <li>The INCR parameter is used to renumber as much as is 
necessary of the member
                  or dataset from the point of the first insertion; the 
member or dataset is renumbered until an existing logical record is 
found whose sequence number is
                  equal to or greater than the next sequence number to 
be assigned.&nbsp; If no such
                  logical record is found, the entire member or dataset 
is renumbered.
               </li>
               <li>Additional NUMBER Detail statements, if any, must 
specify INSERT.&nbsp; If a prior
                  numbering operation renumbers the logical record 
specified in the SEQ1 parameter of a subsequent NUMBER Detail statement,
 any NEWl or INCR
                  parameter specifications in the latter NUMBER 
statement are overridden.&nbsp;
                  The prior increment value is used to assign the next 
successive sequence numbers.&nbsp;
                  If a prior numbering operation does not renumber the 
logical record specified in
                  the SEQ1 parameter of a subsequent NUMBER Detail 
statement, the latter statement must contain NEWl and INCR 
specifications.
               </li>
               <li>The block of Data statements to be inserted must contain blank sequence numbers.</li>
               <li>The insert operation is terminated when a Function statement, a Detail
                  control statement, and end-of-file indication, or a Data statement containing a sequence
                  number is encountered.
               </li>
               <li>The SEQ1, SEQ2, and NEW1 parameters (with the 
exception of SEQ1=ALL) specify eight (maximum) alphameric 
characters.&nbsp;
                  The INCR parameter specifies eight (maximum) numeric 
characters.&nbsp; Only the significant part of a numeric
                  sequence number need be coded; for example, 
SEQ1=00000010 can be shortened to
                  SEQ1=10.&nbsp; If, however, the numbers are 
alphameric, the alphabetic characters must be specified; for example,
                  SEQ1=00ABCO10 can be shortened to SEQ1=ABCO10.
               </li>
            </ul>
            <p>The parameters are:</p>
            <blockquote>
               <p>SEQ1={cccccccc | ALL}</p>
               <blockquote>
                  <p>Specifies records to be renumbered, deleted, or assigned sequence numbers.&nbsp;
                     These values can be coded:
                  </p>
                  <ul>
                     <li>cccccccc - Specifies the sequence number of the
 first logical record to be renumbered or deleted.&nbsp;
                        This value is not coded in a NUMBER Detail 
control statement that is used with an ADD or
                        REPL Function control statement.&nbsp; When this
 value is used in an insert operation, it specifies the existing logical
 record after
                        which an insert is to be made.&nbsp; It must not
 equal the number of a statement
                        just replaced or added.&nbsp; Refer to the 
INSERT parameter for additional discussion.
                     </li>
                     <li>
                        ALL - Specifies a renumbering operation for the 
entire member or dataset.&nbsp; ALL is used only when a CHANGE Function
                        control statement and a NUMBER Detail control 
statement are used.&nbsp; ALL must be coded if sequence numbers are to 
be assigned to
                        existing logical records having blank sequence 
numbers.&nbsp; If ALL is not coded, all existing logical records having 
blank
                        sequence numbers are copied directly to the 
output master dataset.&nbsp; When ALL is coded, SEQ2 need not be coded 
and one NUMBER detail statement is permitted per function 
statement.&nbsp;
                        When ALL is coded:&nbsp;
                        <ul>
                           <li>SEQ2 need not be coded and&nbsp;</li>
                           <li>one NUMBER Detail control statement is permitted per Function
                              control statement.&nbsp;
                           </li>
                        </ul>
                  </li></ul>
               </blockquote>
               <p>SEQ2=cccccccc</p>
               <blockquote>
                  <p>Specifies the sequence number of the last logical record to be renumbered or deleted.&nbsp;
                     SEQ2 is required on all DELETE Detail control statements.&nbsp; If only one record is to be
                     deleted, the SEQ1 and SEQ2 specifications must be identical.&nbsp; SEQ2 is not coded in a NUMBER Detail
                     control statement that is used with an ADD or REPL Function control statement.
                  </p>
               </blockquote>
               <p>NEW1=cccccccc</p>
               <blockquote>
                  <p>Specifies the first sequence number assigned to new or replacement data, or specifies the first sequence number
                     assigned in a renumbering operation.&nbsp; A value specified in NEW1 must be greater than a value
                     specified in SEQ1 (unless SEQ1=ALL is specified, in which case this rule does not apply).
                  </p>
               </blockquote>
               <p>INCR=nnnnnnnn</p>
               <blockquote>
                  <p>Specifies an increment value used for assigning successive sequence numbers to new or replacement logical records,
                     or specifies an increment value used for renumbering existing logical records.
                  </p>
               </blockquote>
               <p>INSERT=YES</p>
               <blockquote>
                  <p>Specifies the insertion of a block of logical records.&nbsp; The records, which are Data statements containing blank
                     sequence numbers, are numbered and inserted in the output master dataset.&nbsp; INSERT is valid
                     only when coded with both a CHANGE Function control statement and a NUMBER Detail
                     control statement.&nbsp;
                     SEQl, NEWl, and INCR are required on the first NUMBER Detail control statement.
                  </p>
               </blockquote>
            </blockquote>
         </blockquote>
         <blockquote>
         <hr color="#808080">
         <p>Data statement</p>
         <p>A Data Statement is used with a Function control statement, or with a Function
            control statement
            and a Detail control statement.&nbsp; It contains a logical record used as replacement data for an
            existing logical record, or new data to be incorporated in the output master dataset.&nbsp;
            Each Data statement contains one logical record, which begins in the first column
            of the Data statement.&nbsp; The length of the logical record is equal to the logical record
            length (LRECL) specified for the output master dataset.&nbsp; Each logical record
            contains a sequence number to determine where the data is to be placed in the output master
            dataset.&nbsp; When used with a CHANGE Function control statement, a Data statement contains new
            or replacement data, as follows:
         </p>
         <ul>
            <li>If the sequence number in the Data statement is 
identical with a sequence number in an existing logical record, the Data
 statement replaces the existing
               logical record in the output master dataset.
            </li>
            <li>If no corresponding sequence number is found within the existing records, the
               Data statement is inserted in the proper collating sequence within the output
               master dataset.&nbsp; (For proper execution of this function, all records in the old
               master dataset must have a sequence number.)
            </li>
            <li>If a Data statement with a sequence number is used and INSERT= YES was specified, the insert operation is terminated.&nbsp;
               IEBUPDTE will continue processing if this sequence number is at least equal to the next old master record
               (record following the referred to sequence record).
            </li>
         </ul>
         <p>When used with an ADD or REPL Function control statement, a Data statement contains new data to be placed in the output master
            dataset.&nbsp;&nbsp;
         </p>
         <p>Sequence numbers within the old master dataset are assumed to be in ascending
            order.&nbsp; No validity checking of sequence numbers is performed for data statements
            or existing records.
         </p>
         <p>Sequence numbers in Data statements must be in the same 
relative position as
            sequence numbers in existing logical records.&nbsp; 
(Sequence numbers are assumed to be
            in columns 73 through 80; if the numbers are in columns 
other than these, the length and relative position must be specified in a
 SEQFLD parameter within a
            preceding Function control statement.)
         </p>
         <hr color="#808080">
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="4%">
                  <pre>./</pre>
               </td>
               <td width="96%">
                  <pre><a name="IEBUPDTEalias"></a>ALIAS | <a name="IEBUPDTEdelete"></a>DELETE</pre>
               </td>
            </tr>
            <tr>
               <td width="4%">
                  <pre></pre>
               </td>
               <td width="96%">
                  <pre>NAME=cccccccc</pre>
               </td>
            </tr>
         </tbody></table>
         <p>The ALIAS control statement is used to create or retain an 
alias in an output (partitioned)
            master directory.&nbsp; The ALIAS control statement can be 
used with any of the Function
            control statements.&nbsp; Multiple aliases can be assigned 
to each member up to a maximum of
            16 aliases.&nbsp; Note:&nbsp; If an ALIAS statement is 
specifying a name which already exists on the
            dataset, the original TTR of that directory entry will be 
destroyed.&nbsp; ALIAS must be preceded and followed by at least one 
blank.&nbsp;
            If multiple ALIAS control statements are used, they must 
follow the data records.
         </p>
         <p>The parameter is:</p>
         <blockquote>
            <p>NAME=cccccccc</p>
            <blockquote>
               <p>Specifies a one&nbsp; to eight character alias.</p>
            </blockquote>
         </blockquote>
         <hr color="#808080">
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="4%">
                  <pre>./</pre>
               </td>
               <td width="96%">
                  <pre><a name="IEBUPDTEendup"></a>ENDUP</pre>
               </td>
            </tr>
         </tbody></table>
         <p>An ENDUP control statement can be used to indicate the end of SYSIN input to this job
            step.&nbsp; It serves as an end-of-data indication if there is no other preceding delimiter
            statement.&nbsp; The ENDUP control statement follows the last group of SYSIN control statements.
         </p>
      <h3>&nbsp;</h3></blockquote>
      <h3>Program Parameter (PARM= on EXEC statement)</h3>
      <blockquote>
         <p>Additional information can be coded in the PARM parameter of the EXEC statement, as follows:</p>
         <blockquote>
            <p>PARM={NEW | MOD},[inhdr],[intlr]</p>
            <p>The action of the values which may be supplied are:</p>
            <blockquote>
               <p>NEW</p>
               <blockquote>
                  <p>Specifies that the input consists solely of the control dataset.&nbsp; The
                     input dataset (SYSUT2) is not defined if NEW is specified.
                  </p>
               </blockquote>
               <p>MOD</p>
               <blockquote>
                  <p>Specifies that the input consists of both the control dataset and the input dataset.&nbsp;
                     If neither NEW nor MOD is coded, MOD is assumed.
                  </p>
               </blockquote>
               <p>inhdr</p>
               <blockquote>
                  <p>Specifies the symbolic name of a routine that processes the user header label on the volume containing the control dataset.</p>
               </blockquote>
               <p>intlr</p>
               <blockquote>
                  <p>Specifies the symbolic name of a routine that processes the user trailer label on the volume containing the control dataset.</p>
               </blockquote>
            </blockquote>
         </blockquote>
      </blockquote>
      <h3>&nbsp;</h3>
      <h3>Examples</h3>
      <blockquote>
         <table width="75%" cellspacing="1" border="1">
            <tbody><tr>
               <td width="33%">
                  <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="IEBUPDTEj01"></a>Add
                     two members to a partitioned dataset
               </p></td>
            </tr>
            <tr>
               <td width="33%">
                  <pre><b>//IEBUPDTE JOB (001),'IEBUPDTE-01',CLASS=S,MSGCLASS=X
//IEBUPDTE EXEC PGM=IEBUPDTE,PARM=NEW                                   
//SYSUT2   DD  DSN=SYS2.PROCLIB,DISP=MOD                                
//SYSPRINT DD  SYSOUT=*                                                 
//SYSIN    DD  DATA       <font color="#0000FF">when statements to be added contain JCL statements, code DATA on SYSIN DD</font>
./ ADD NAME=CLEARDMP
./ NUMBER NEW1=10,INCR=10                                               
//CLEARDMP PROC DD=00         SPECIFY DD={00|01|02}                     
//* ***************************************************************** * 
//* CLEAR DUMP DATASET                                                * 
//* ***************************************************************** * 
//EMPTY    EXEC PGM=IEBGENER                                            
//SYSPRINT DD  SYSOUT=*                                                 
//SYSIN    DD  DUMMY                                                    
//SYSUT1   DD  DUMMY,DCB=(RECFM=U,LRECL=100,BLKSIZE=100)                
//SYSUT2   DD  DISP=SHR,DSN=SYS1.DUMP&amp;DD                                
./ ADD NAME=CLEARERP
./ NUMBER NEW1=10,INCR=10                                               
//CLEARERP PROC                                                         
//* ***************************************************************** * 
//* CLEAR ENVIRONMENTAL ERROR RECORDER DATASET                        * 
//* ***************************************************************** * 
//EREP     EXEC PGM=IFCDIP00                                            
//SERERDS  DD  DISP=SHR,DSN=SYS1.LOGREC                                 
./ ENDUP
//</b></pre>
               </td>
            </tr>
            <tr>
               <td width="33%">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="IEBUPDTEj02"></a>Change
                  member in partitioned dataset, update in place
               </td>
            </tr>
            <tr>
               <td width="33%">
                  <pre><b>//IEBUPDTE JOB (001),'IEBUPDTE-02',CLASS=A,MSGCLASS=X
//IEBUPDTE EXEC PGM=IEBUPDTE
//SYSPRINT DD SYSOUT=*
//SYSUT1   DD DSN=SYS2.PROCLIB,DISP=OLD
//SYSUT2   DD DSN=SYS2.PROCLIB,DISP=OLD
//SYSIN    DD DATA
./ CHANGE NAME=CLEARDMP,UPDATE=INPLACE
//SYSUT1   DD  DUMMY,DCB=(RECFM=U,LRECL=10,BLKSIZE=10)                   0000080
//STEP2 EXEC PGM=EXAMPLE2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 00000010
0000080
./ ENDUP
/*
//</b></pre>
               </td>
            </tr>
            <tr>
               <td width="33%">
                  <b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="IEBUPDTEj03"></a></b>Add
                  records to member in partitioned dataset
               </td>
            </tr>
            <tr>
               <td width="33%">
                  <pre><b>//IEBUPDTE JOB (001),'IEBUPDTE-03',CLASS=A,MSGCLASS=X
//IEBUPDTE EXEC PGM=IEBUPDTE
//SYSPRINT DD SYSOUT=*
//SYSUT1   DD DSN=SYS1.PARMLIB,DISP=OLD
//SYSUT2   DD DSN=SYS1.PARMLIB,DISP=OLD
//SYSIN    DD DATA
./ CHANGE NAME=SAMPLE
//EXTRADD  DD SYSOUT=A&nbsp;                                  &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 00000015
./ ENDUP
/*
//</b></pre>
               </td>
            </tr>
            <tr>
               <td width="33%">
                  <b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="IEBUPDTEj04"></a></b>Delete
                  records from a member in a partitioned dataset
               </td>
            </tr>
            <tr>
               <td width="33%">
                  <pre><b>//IEBUPDTE JOB (001),'IEBUPDTE-04',CLASS=A,MSGCLASS=X
//IEBUPDTE EXEC PGM=IEBUPDTE
//SYSPRINT DD SYSOUT=*
//SYSUT1   DD DSN=SYS1.PARMLIB,DISP=OLD
//SYSUT2   DD DSN=SYS1.PARMLIB,DISP=OLD
//SYSIN    DD *
./ CHANGE NAME=SAMPLE
./ DELETE SEQ1=15,SEQ2=20
/*
// </b></pre>
               </td>
            </tr>
            <tr>
               <td width="33%">
                  <b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="IEBUPDTEj05"></a></b>Create
                  a partitioned dataset, input data contained solely in control dataset
               </td>
            </tr>
            <tr>
               <td width="33%">
                  <pre><b>//IEBUPDTE JOB (001),'IEBUPDTE-05',CLASS=A,MSGCLASS=X
//IEBUPDTE EXEC PGM=IEBUPDTE,PARM=NEW
//SYSPRINT DD SYSOUT=*
</b><b>//SYSUT2   DD DSN=OUTLIB,UNIT=DISK,DISP=(NEW,KEEP),
//            VOL=SER=111112,SPACE=(TRK,(50,,10)),
//            DCB=(RECFM=F,LRECL=80,BLKSIZE=80)
//SYSIN    DD DATA
./ ADD NAME=MEMB1,LEVEL=00,SOURCE=0
 (data statements with sequence numbers in columns 73 through 80)
./ ADD NAME=MEMB2,LEVEL=00,SOURCE=0
 (data statements with sequence numbers in columns 73 through 80)
./ ADD NAME=MEMB3,LEVEL=00,SOURCE=0
 (data statements with sequence numbers in columns 73 through 80)
./ ENDUP
/*
//</b></pre>
               </td>
            </tr>
            <tr>
               <td width="33%">
                  <b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="IEBUPDTEj06"></a></b>Create
                  a partitioned dataset, input data copied from existing dataset
               </td>
            </tr>
            <tr>
               <td width="33%">
                  <pre><b>//IEBUPDTE JOB (001),'IEBUPDTE-06',CLASS=A,MSGCLASS=X
//IEBUPDTE EXEC PGM=IEBUPDTE,PARM=NEW
//SYSPRINT DD SYSOUT=*
//SYSUT1   DD DSN=SYS1.MACLIB,DISP=SHR
</b><b>//SYSUT2   DD DSN=SYS9.MACLIB,UNIT=DISK,DISP=(NEW,KEEP),
//            VOL=SER=111112,SPACE=(TRK,(50,,10)),
//            DCB=(RECFM=F,LRECL=80,BLKSIZE=80)
//SYSIN    DD DATA
./ REPRO NAME=ATTACH,LEVEL=00,SOURCE=1,LIST=ALL
./ REPRO NAME=DETACH,LEVEL=00,SOURCE=1,LIST=ALL
./ ADD NAME=EXIT,LEVEL=00,SOURCE=1,LIST=ALL
./ NUMBER NEW1=10,INCR=100
 (data statements for new EXIT member)
./ ENDUP
/*
//</b></pre>
               </td>
            </tr>
         </tbody></table>
      </blockquote>
      <p><font size="1">Source:&nbsp; <a href="http://bitsavers.trailing-edge.com/pdf/ibm/370/OS_VS2/Release_3.8_1978/GC26-3902-1_OS_VS2_MVS_Utilities_Rel_3.8_Sep83.pdf" target="_blank">GC26-3902-1 OS/VS2 MVS Utilities Release 3.8</a></font></p>
      <hr size="8" noshade="noshade">
      <h2><a name="IEHDASDR"></a>IEHDASDR <font size="2">[supplied by IBM, located in
         SYS1.LINKLIB]</font>
      </h2>
      <p><font color="#FF0000"><b>Warning</b></font>:&nbsp; If you have installed Jim Morrison's modifications to provide
         3375/3380/3390
         support under MVS, be advised that IEHDASDR does not recognize these device types and will not function
         correctly, if at all, with volumes of these types.&nbsp; <b><font color="#0000FF">As
         an alternative, I would suggest taking a look at ICKDSF for initializing DASD volumes and
         DSSDUMP/DSSREST for backing up DASD datasets.</font></b>
      </p>
      <p>Used to prepare direct access volumes for use.&nbsp; In 
addition, IEHDASDR can be used to dump the entire contents or portions 
of a
         direct access volume to a volume or volumes of the same direct 
access device type,
         or to a tape volume or volumes.&nbsp; Data that is dumped to a 
tape volume is arranged so that it can subsequently be restored to its 
original
         organization by IEHDASDR or IBCDMPRS (stand-alone restore 
program).
      </p>
      <p>IEHDASDR requires the following DD statements:</p>
      <ul>
         <li>SYSPRINT - defines a sequential output message dataset.</li>
         <li>SYSIN - defines a sequential input dataset that contains IEHDASDR control
            statements.
         </li>
         <li>anyname - defines DASD volume to be used as input (DUMP) or output
            (RESTORE).
         </li>
         <li>anyname - defines tape volume to be used as input (RESTORE) or output
            (DUMP)
         </li>
         <li>anyname - defines source for IPL loader program</li>
      </ul>
      <h3>&nbsp;</h3>
      <h3>Control Statements</h3>
      <blockquote>
      <table width="50%" cellspacing="0" cellpadding="0" border="0">
         <tbody><tr>
            <td width="13%">
               <pre><a name="IEHDASDRanalyze"></a>ANALYZE</pre>
            </td>
            <td width="87%">
               <pre>TODD=cuu</pre>
            </td>
         </tr>
         <tr>
            <td width="13%">
               <pre></pre>
            </td>
            <td width="87%">
               <pre>,VTOC=xxxxx</pre>
            </td>
         </tr>
         <tr>
            <td width="13%">
               <pre></pre>
            </td>
            <td width="87%">
               <pre>,EXTENT=xxxxx</pre>
            </td>
         </tr>
         <tr>
            <td width="13%">
               <pre></pre>
            </td>
            <td width="87%">
               <pre>,NEWVOLID=serial</pre>
            </td>
         </tr>
         <tr>
            <td width="13%">
               <pre></pre>
            </td>
            <td width="87%">
               <pre>[,IPLDD=ddname]</pre>
            </td>
         </tr>
         <tr>
            <td width="13%">
               <pre></pre>
            </td>
            <td width="87%">
               <pre>[,OWNERID=name]</pre>
            </td>
         </tr>
         <tr>
            <td width="13%">
               <pre></pre>
            </td>
            <td width="87%">
               <pre>[,PURGE={YES | NO}</pre>
            </td>
         </tr>
      </tbody></table>
      <p>The ANALYZE control statement prepares the volume to make it ready for use; writes label track and
         creates Volume Table of Contents.&nbsp; The parameters are:
      </p>
      <blockquote>
         <p>TODD=cuu</p>
         <blockquote>
            <p>Specifies the channel and unit address of a direct access device containing an
               offline volume to be initialized.&nbsp;&nbsp;
            </p>
         </blockquote>
         <p>VTOC=xxxxx</p>
         <blockquote>
            <p>Specifies a one to five byte decimal relative track address representing a primary track on which the volume table of
               contents is to begin.&nbsp; The VTOC cannot occupy track 0.
            </p>
         </blockquote>
         <p>EXTENT=xxxxx</p>
         <blockquote>
            <p>Specifies the decimal length of the VTOC in tracks.</p>
         </blockquote>
         <p>NEWVOLID=serial</p>
         <blockquote>
            <p>Specifies a one to six character serial number.</p>
         </blockquote>
         <p>IPLDD=ddname</p>
         <blockquote>
            <p>Specifies,the ddname of a DD statement defining the dataset containing the IPL program.&nbsp;
               The IPL program can be defined as a sequential dataset or a member of a partitioned dataset.
            </p>
         </blockquote>
         <p>OWNERID=name</p>
         <blockquote>
            <p>Specifies a one to ten character name or other identifying information to be
               placed in the volume label record.&nbsp; OWNERID is specified as a character
               string of any alphameric, national character, hyphen (-), slash (/), or period
               (.).
            </p>
         </blockquote>
         <p>PURGE={YES | NO}</p>
         <p>Specifies whether the ANALYZE operation is be terminated when an unexpired dataset is
            encountered.&nbsp; These values can be coded:
         </p>
         <ul>
            <li>YES - Indicates that all unexpired datasets on the 
volume can be overwritten provided that the operator signals his
               concurrence when the first unexpired dataset is 
encountered.&nbsp; If PURGE=YES is coded and an unexpired dataset is
               encountered, the operator is prompted.&nbsp; The operator
 replies are:
            </li>
         </ul>
         <blockquote>
            <blockquote>
               <p>U - Which indicates that all unexpired datasets on this volume can be overwritten.</p>
               <p>T - Which indicates that this volume contains unexpired datasets that must not be overwritten.</p>
            </blockquote>
         </blockquote>
         <ul>
            <li>NO - Specifies that the various operations are to be terminated if an unexpired dataset is
               encountered.
            </li>
         </ul>
         <p>The PURGE parameter does not apply to password-protected datasets; the operator must
            always respond with the proper password for each password-protected dataset encountered.&nbsp;
            If he is unable to do so, the operation is terminated.
         </p>
      </blockquote>
      <hr color="#808080">
      <table width="50%" cellspacing="0" cellpadding="0" border="0">
         <tbody><tr>
            <td width="9%">
               <pre><a name="IEHDASDRlabel"></a>LABEL</pre>
            </td>
            <td width="91%">
               <pre>TODD=cuu</pre>
            </td>
         </tr>
         <tr>
            <td width="9%">
               <pre></pre>
            </td>
            <td width="91%">
               <pre>,NEWVOLID=serial</pre>
            </td>
         </tr>
         <tr>
            <td width="9%">
               <pre></pre>
            </td>
            <td width="91%">
               <pre>[,OWNERID=name]</pre>
            </td>
         </tr>
      </tbody></table>
      <p>The LABEL control statement changes the volume serial number of
 a direct access volume and, optionally, updates the owner field.&nbsp;
         The parameters are:
      </p>
      <blockquote>
         <blockquote>
            <p>TODD=cuu</p>
            <blockquote>
               <p>Specifies the channel and unit address of a direct access device containing an
                  offline volume to be labeled.&nbsp;
               </p>
            </blockquote>
            <p>NEWVOLID=serial</p>
            <blockquote>
               <p>Specifies a one to six character serial number.</p>
            </blockquote>
            <p>OWNERID=name</p>
            <blockquote>
               <p>Specifies a one to ten character name or other identifying
                  information to be placed in the volume label record.&nbsp; OWNERID is
                  specified as a character string of any alphameric, national character,
                  hyphen (-), slash (/), or period (.).
               </p>
            </blockquote>
         </blockquote>
      </blockquote>
      <hr color="#808080">
      <table width="50%" cellspacing="0" cellpadding="0" border="0">
         <tbody><tr>
            <td width="9%">
               <pre><a name="IEHDASDRdump"></a>DUMP</pre>
            </td>
            <td width="91%">
               <pre>FROMDD=ddname</pre>
            </td>
         </tr>
         <tr>
            <td width="9%">
               <pre></pre>
            </td>
            <td width="91%">
               <pre>,TODD=ddname</pre>
            </td>
         </tr>
         <tr>
            <td width="9%">
               <pre></pre>
            </td>
            <td width="91%">
               <pre>[,CPYVOLID={YES | NO}]</pre>
            </td>
         </tr>
         <tr>
            <td width="9%">
               <pre></pre>
            </td>
            <td width="91%">
               <pre>[,BEGIN=cccchhhh]</pre>
            </td>
         </tr>
         <tr>
            <td width="9%">
               <pre></pre>
            </td>
            <td width="91%">
               <pre>[,END=cccchhhh]</pre>
            </td>
         </tr>
      </tbody></table>
      <p>The DUMP control statement dumps a single track, a group of tracks, or an entire direct access volume.&nbsp;
         The parameters are:
      </p>
      <blockquote>
         <p>FROMDD=ddname</p>
         <blockquote>
            <p>Specifies the ddname of the DD statement defining the device containing the direct access volume from which a
               copy is to be made.
            </p>
         </blockquote>
         <p>TODD=ddname</p>
         <blockquote>
            <p>Specifies the ddnames of the DD statement defining the device containing the tape
               volume on which a copy is to be made.
            </p>
         </blockquote>
         <p>CPYVOLID={YES | NO}</p>
         <blockquote>
            <p>Specifies whether receiving direct access volumes are to be assigned the serial number of the dumped volume.&nbsp;
               These values can be coded:
            </p>
            <ul>
               <li>YES - Specifies that all receiving direct access volumes are to be assigned the serial number of the dumped volume.</li>
               <li>NO - Specifies that receiving volumes are to keep their own serial numbers.</li>
            </ul>
         </blockquote>
         <p>BEGIN=cccchhhh</p>
         <blockquote>
            <p>Specifies in hexadecimal a cylinder number, cccc and head number, hhhh, that identify the first track to be dumped.&nbsp;
               If BEGIN is omitted, the dump operation begins with track 0.
            </p>
         </blockquote>
         <p>END=cccchhhh</p>
         <blockquote>
            <p>Specifies in hexadecimal a cylinder number, cccc, and head number,hhhh, that identify the last track to be dumped.&nbsp;
               If only one track is to be dumped, both BEGIN and END specify that track address.&nbsp;
               Default:&nbsp; The last primary track of the volume is the last track to be copied.&nbsp;
            </p>
         </blockquote>
      </blockquote>
      <hr color="#808080">
      <table width="50%" cellspacing="0" cellpadding="0" border="0">
         <tbody><tr>
            <td width="11%">
               <pre><a name="IEHDASDRrestore"></a>RESTORE</pre>
            </td>
            <td width="89%">
               <pre>TODD=ddname</pre>
            </td>
         </tr>
         <tr>
            <td width="11%">
               <pre></pre>
            </td>
            <td width="89%">
               <pre>,FROMDD=ddname</pre>
            </td>
         </tr>
         <tr>
            <td width="11%">
               <pre></pre>
            </td>
            <td width="89%">
               <pre>[,CPYVOLID={YES | NO}]</pre>
            </td>
         </tr>
         <tr>
            <td width="11%">
               <pre></pre>
            </td>
            <td width="89%">
               <pre>[,PURGE={YES | NO}]</pre>
            </td>
         </tr>
      </tbody></table>
      <p>The RESTORE control statement restores a previously dumped direct access volume to a direct access device.&nbsp;
         The parameters are:
      </p>
      <blockquote>
         <p>TODD=ddname</p>
         <blockquote>
            <p>Specifies the ddname of the DD statement that identifies the volume serial number of the output volume.</p>
         </blockquote>
         <p>FROMDD=ddname</p>
         <blockquote>
            <p>Specifies the ddname of the DD statement that defines the tape volume containing the data to be restored.</p>
         </blockquote>
         <p>CPYVOLID={YES | NO}</p>
         <blockquote>
            <p>Specifies whether receiving direct access volumes are to be assigned the serial number of the dumped volume.&nbsp;
               These values can be coded:
            </p>
            <ul>
               <li>YES - Specifies that all receiving direct access volumes are to be assigned the serial number of the dumped volume.</li>
               <li>NO - Specifies that receiving volumes are to keep their own serial numbers.</li>
            </ul>
         </blockquote>
         <p>PURGE={YES | NO}</p>
         <blockquote>
            <p>Specifies whether the ANALYZE operation is be terminated when an unexpired dataset is
               encountered.&nbsp; These values can be coded:
            </p>
            <ul>
               <li>YES - Indicates that all unexpired datasets on the 
volume can be overwritten provided that the operator signals his
                  concurrence when the first unexpired dataset is 
encountered.&nbsp; If PURGE=YES is coded and an unexpired dataset is
                  encountered, the operator is prompted.&nbsp; The 
operator replies are:
               </li>
               <blockquote>
                  <p>U - Which indicates that all unexpired datasets on this volume can be overwritten.</p>
                  <p>T - Which indicates that this volume contains unexpired datasets that must not be overwritten.</p>
               </blockquote>
               <li>NO - Specifies that the various operations are to be terminated if an unexpired dataset is
                  encountered.
               </li>
            </ul>
         </blockquote>
         <p>The PURGE parameter does not apply to password-protected datasets; the operator must
            always respond with the proper password for each password-protected dataset encountered.&nbsp;
            If he is unable to do so, the operation is terminated.
         </p>
      </blockquote></blockquote>
      <h3>&nbsp;</h3>
      <h3>Examples</h3>
      <blockquote>
         <table width="75%" cellspacing="1" border="1">
            <tbody><tr>
               <td width="33%">
                  <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="IEHDASDRj01"></a>Initialize
                     2314, 3330 (1 and 2), 3340, 3350 DASD volumes
               </p></td>
            </tr>
            <tr>
               <td width="33%">
                  <pre><b>//IEHDASDR JOB 1,'IEHDASDR-INIT',CLASS=S,MSGCLASS=X                            
//* ***************************************************************** * 
//* * USE ONLY FOR 3350 | 3330 | 3340 | 2314                          * 
//* ***************************************************************** * 
//*                                                                     
//IEHDASDR EXEC PGM=IEHDASDR,REGION=4096K                               
//SYSPRINT DD  SYSOUT=*                                                 
//SYSIN    DD  *                                                        
       ANALYZE TODD=127,                                               C
               VTOC=50,EXTENT=10,                                      C
               NEWVOLID=111111,                                        C
               OWNERID=HERCULES                                         
/*                                                                      
//                     </b></pre>
               </td>
            </tr>
            <tr>
               <td width="33%">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="IEHDASDRj02"></a>Dump
                  DASD volume to tape
               </td>
            </tr>
            <tr>
               <td width="33%">
                  <pre><b>//IEHDASDR JOB 1,'IEHDASDR-DUMP',CLASS=S,MSGCLASS=X        
//IEHDASDR EXEC PGM=IEHDASDR
//SYSPRINT DD SYSOUT=*                                             
//DISK     DD UNIT=2314,VOL=SER=DLIB01,DISP=OLD                        
//TAPE     DD UNIT=TAPE,DSN=BACKUP.TAPE.DLIBS,DISP=(NEW,KEEP),
//            VOL=SER=DBKD01,LABEL=(2,SL)  
//SYSIN    DD *                                                       
       DUMP FROMDD=DISK,TODD=TAPE
/*                                                                                                                             
// </b></pre>
               </td>
            </tr>
            <tr>
               <td width="33%">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="IEHDASDRj03"></a>Restore
                  DASD volume from backup
               </td>
            </tr>
            <tr>
               <td width="33%">
                  <pre><b>//IEHDASDR JOB 1,'IEHDASDR-RESTORE',CLASS=S,MSGCLASS=X        
//IEHDASDR EXEC PGM=IEHDASDR
//SYSPRINT DD SYSOUT=*                                             
//TAPE     DD UNIT=BACKUP.TAPE.DLIBS,DSN=TAPE,DISP=OLD,
//            VOL=SER=DBKD01,LABEL=(2,SL)  
//DISK     DD UNIT=2314,VOL=SER=111111,DISP=OLD                        
//SYSIN    DD *                                                       
       RESTORE FROMDD=TAPE,TODD=DISK,PURGE=YES,CPYVOLID=YES
/*                                                                                                                             
//                                              </b></pre>
               </td>
            </tr>
            <tr>
               <td width="33%">
                  <b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="IEHDASDRj04"></a></b>Alter
                  Volume Serial on offline 2314
               </td>
            </tr>
            <tr>
               <td width="33%">
                  <pre><b>//IEHDASDR JOB 1,'IEHDASDR-RELABEL',CLASS=S,MSGCLASS=X   
//IEHDASDR EXEC PGM=IEHDASDR                                 
//SYSPRINT DD SYSOUT=*                                       
//SYSIN    DD *                                                 
       LABEL TODD=123,NEWVOLID=134134,OWNERID=HERCULES       
/*                                                           
//                                                           </b></pre>
               </td>
            </tr>
         </tbody></table>
      </blockquote>
      <p><font size="1">Source:&nbsp; <a href="http://bitsavers.trailing-edge.com/pdf/ibm/370/OS_VS2/Release_3.8_1978/GC26-3902-1_OS_VS2_MVS_Utilities_Rel_3.8_Sep83.pdf" target="_blank">GC26-3902-1 OS/VS2 MVS Utilities Release 3.8</a></font></p>
      <hr size="8" noshade="noshade">
      <h2><a name="IEHINITT"></a>IEHINITT <font size="2">[supplied by IBM, located in
         SYS1.LINKLIB]</font>
      </h2>
      <p>Note:&nbsp; As the majority of the audience for this page is running MVS
         under Hercules, I will point out that there is a Hercules' utility provided to
         initialize emulated tape images:&nbsp; hetinit.&nbsp; The hetinit utility may be
         run from a command prompt (Windows) or terminal (Linux) or by using the
         Hercules' shell command (sh) from the Hercules' command prompt.&nbsp; In
         addition, the COPYMODS program may be used to initialize multiple tapes per
         execution.&nbsp; There is
         little use for the IBM IEHINITT utility, except for history.
      </p>
      <p>Used to place IBM volume label sets written in EBCDIC onto any number of magnetic tapes mounted on one or more tape
         units.&nbsp; Each volume label set created by the program contains:
      </p>
      <ul>
         <li>A standard volume label with user-specified serial number and owner identification.</li>
         <li>An 80-byte dummy header label. For IBM standard labels, this record consists
            of HDR1 followed by zeros.
         </li>
         <li>A tape mark.</li>
      </ul>
      <p>IEHINITT requires the following DD statements:</p>
      <ul>
         <li>SYSPRINT - defines a sequential output message dataset.</li>
         <li>SYSIN - defines a sequential input dataset that contains IEHINITT control
            statements.
         </li>
         <li>anyname - defines a tape unit to be used in a labeling operation; more than one tape unit
            can be identified.
         </li>
      </ul>
      <h3>&nbsp;</h3>
      <h3>Control Statements</h3>
      <blockquote>
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="11%">
                  <pre>ddname</pre>
               </td>
               <td width="11%">
                  <pre><a name="IEHINITTinitt"></a>INITT</pre>
               </td>
               <td width="89%">
                  <pre>SER=xxxxxx</pre>
               </td>
            </tr>
            <tr>
               <td width="11%">
                  <pre></pre>
               </td>
               <td width="11%">
                  <pre></pre>
               </td>
               <td width="89%">
                  <pre>[,OWNER='cccccccccc']</pre>
               </td>
            </tr>
            <tr>
               <td width="11%">
                  <pre></pre>
               </td>
               <td width="11%">
                  <pre></pre>
               </td>
               <td width="89%">
                  <pre>[,NUMBTAPE = {n | 1]</pre>
               </td>
            </tr>
            <tr>
               <td width="11%">
                  <pre></pre>
               </td>
               <td width="11%">
                  <pre></pre>
               </td>
               <td width="89%">
                  <pre>,DISP= {REWIND I UNLOAD}</pre>
               </td>
            </tr>
         </tbody></table>
         <p>The INITT control statement provides control information for
 the IEHINITT program.&nbsp; Any number of INITT utility control 
statements can be included for a given
            execution of the program.&nbsp; An identically named DD 
statement must exist for
            each utility control statement in the job step.&nbsp; The 
parameters are:
         </p>
         <blockquote>
            <p>ddname</p>
            <blockquote>
               <p>Specifies a name that is identical to a ddname in the name field of a DD statement defining a tape unit(s).&nbsp;
                  This name must begin in column 1.
               </p>
            </blockquote>
            <p>SER=xxxxxx</p>
            <blockquote>
               <p>Specifies the volume serial number of the first, or 
only tape to be labeled.&nbsp;
                  The serial number cannot contain blanks, commas, 
apostrophes, equal signs, or special characters
                  other than periods or hyphens.&nbsp; A specified 
serial number is incremented by one for each additional tape to be 
labeled.&nbsp;
                  (Serial number 999999 is incremented to 000000.)&nbsp;
 When processing multiple tapes, the volume serial number must
                  be all numeric.
               </p>
            </blockquote>
            <p>OWNER='cccccccccccccc'</p>
            <blockquote>
               <p>Specifies the owner's name or similar 
identification.&nbsp; The information is specified as character 
constants, and can be
                  up to 10 bytes in length.&nbsp; The delimiting 
apostrophes can be omitted, if no
                  blanks, commas, apostrophes, equal signs, or other 
special characters (except periods or hyphens) are included.&nbsp;
                  If an apostrophe is included within the OWNER name 
field, it must be written as two consecutive apostrophes.
               </p>
            </blockquote>
            <p>NUMBTAPE={n | 1}</p>
            <blockquote>
               <p>Specifies the number of tapes to be labeled according 
to the specifications made in this control statement.&nbsp;
                  The value n represents a number from 1 to 255. If more
 than one tape is specified, the serial number must be numeric.
               </p>
            </blockquote>
            <p>DISP={REWIND | UNLOAD}</p>
            <blockquote>
               <p>Specifies whether a tape is to be rewound or unloaded.&nbsp; These values can be coded:</p>
               <ul>
                  <li>REWIND - Specifies that a tape is to be rewound (but not unloaded) after the label has been written.&nbsp;
                     If DISP=REWIND is not specified, the tape volume is rewound and unloaded.
                  </li>
                  <li>UNLOAD - Specifies that a tape is to be unloaded after the label has been written.</li>
               </ul>
            </blockquote>
         </blockquote>
      </blockquote>
      <p>&nbsp;</p>
      <p>Message <b>IEC701D </b>will be displayed on the console to request the
         mounting of scratch tape(s) to be initialized.&nbsp; A response of: <b>r nn,M</b>
         informs IEHINITT that the tape(s) have been mounted, so it will proceed.
      </p>
      <h3>&nbsp;</h3>
      <h3>Examples</h3>
      <blockquote>
         <table width="75%" cellspacing="1" border="1">
            <tbody><tr>
               <td width="33%">
                  <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="IEHINITTj01"></a>Initialize
                     3 tapes
               </p></td>
            </tr>
            <tr>
               <td width="33%">
                  <pre><b>//IEHINITT JOB (SYS),'LABEL TAPES',MSGCLASS=X,CLASS=S        
//IEHINITT EXEC PGM=IEHINITT                                  
//SYSPRINT DD  SYSOUT=*                                       
//LABEL    DD  UNIT=(TAPE,,DEFER)
//SYSIN    DD  *                                              
LABEL INITT SER=014020,NUMBTAPE=3,OWNER=HERCULES,DISP=UNLOAD  
/*                                                            
//                     </b></pre>
               </td>
            </tr>
         </tbody></table>
      </blockquote>
      <p><font size="1">Source:&nbsp; <a href="http://bitsavers.trailing-edge.com/pdf/ibm/370/OS_VS2/Release_3.8_1978/GC26-3902-1_OS_VS2_MVS_Utilities_Rel_3.8_Sep83.pdf" target="_blank">GC26-3902-1 OS/VS2 MVS Utilities Release 3.8</a></font></p>
      <hr size="8" noshade="noshade">
      <h2><a name="IEHLIST"></a>IEHLIST <font size="2">[supplied by IBM, located in
         SYS1.LINKLIB]</font>
      </h2>
      <p>Used to list entries in a volume table of contents, entries in the directory of one or more partitioned datasets,
         or entries in an OS catalog.&nbsp; <b><font color="#0000FF">I
         would also suggest taking a look at IEHMAP, SUPERLST, and VTOCLIST (for VTOCs)
         and LISTPDS and MAPDISK (for Partitioned datasets).</font></b>
      </p>
      <p>IEHLIST requires the following DD statements:</p>
      <ul>
         <li>SYSPRINT - defines a sequential output message dataset.</li>
         <li>SYSIN - defines a sequential input dataset that contains IEHLIST control
            statements.
         </li>
         <li>anyname - defines a DASD volume for which the Volume Table of Contents is
            to be listed or on which a Partitioned dataset resides for which the
            directory is to be listed.
         </li>
      </ul>
      <h3>&nbsp;</h3>
      <h3>Control Statements</h3>
      <blockquote>
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="13%">
                  <pre><a name="IEHLISTlistctlg"></a>LISTCTLG</pre>
               </td>
               <td width="87%">
                  <pre>[VOL=device=serial]</pre>
               </td>
            </tr>
            <tr>
               <td width="13%">
                  <pre></pre>
               </td>
               <td width="87%">
                  <pre>[,NODE=name]</pre>
               </td>
            </tr>
         </tbody></table>
         <p>The LISTCTLG control statement requests a listing of all or part of an OS catalog (SYSCTLG).&nbsp; <b><font color="#FF0000">Note:</font></b>&nbsp;
            This is for listing OS CVOL catalogs; MVS uses VSAM catalogs (IDCAMS is the
            utility to list VSAM catalog contents).&nbsp; The parameters are:
         </p>
         <blockquote>
            <p>VOL=device=serial</p>
            <blockquote>
               <p>Specifies the device type and volume serial number of the volume on which the
                  catalog resides.
               </p>
            </blockquote>
            <p>NODE=name</p>
            <blockquote>
               <p>Specifies a qualified name.&nbsp; All dataset entries 
whose names are qualified
                  by this name are listed.&nbsp; The CVOL must be 
defined in the VSAM Master Catalog as: SYSTCTLG.VYYYYYY, where YYYYYY is
 the
                  serial number of the CVOL.&nbsp; Default: All dataset 
entries are listed.
               </p>
            </blockquote>
         </blockquote>
         <hr color="#808080">
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="11%">
                  <pre><a name="IEHLISTlistpds"></a>LISTPDS</pre>
               </td>
               <td width="89%">
                  <pre>DSNAME=dsname | (dsname[,dsname]...)</pre>
               </td>
            </tr>
            <tr>
               <td width="11%">
                  <pre></pre>
               </td>
               <td width="89%">
                  <pre>[,VOL=device=serial]</pre>
               </td>
            </tr>
            <tr>
               <td width="11%">
                  <pre></pre>
               </td>
               <td width="89%">
                  <pre>[,{DUMP | FORMAT}]</pre>
               </td>
            </tr>
         </tbody></table>
         <p>The LISTPDS control statement requests a directory listing of one or more partitioned datasets.&nbsp; The
            parameters are:
         </p>
         <blockquote>
            <p>DSNAME=dsname | (dsname[,dsname]...)</p>
            <blockquote>
               <p>Specifies the fully qualified names of the partitioned
 datasets whose directories are to be listed.&nbsp;
                  A maximum of ten names is allowed.&nbsp; If the list 
consists of a single name, the parentheses can be omitted.&nbsp;
                  DSNAME may be abbreviated to DSN.
               </p>
            </blockquote>
            <p>VOL=device=serial</p>
            <blockquote>
               <p>Specifies the device type and volume serial number of the volume on which the
                  partitioned dataset resides.
               </p>
            </blockquote>
            <p>DUMP | FORMAT</p>
            <blockquote>
               <p>DUMP</p>
               <blockquote>
                  <p>Specifies that the listing is to be in unedited, hexadecimal form.</p>
               </blockquote>
               <p>FORMAT</p>
               <blockquote>
                  <p>Specifies that the listing is to be edited for each directory entry.&nbsp;</p>
               </blockquote>
            </blockquote>
            <p>&nbsp;Default:&nbsp; If both DUMP and FORMAT are omitted, DUMP is the
               default used.
            </p>
         </blockquote>
         <hr color="#808080">
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="11%">
                  <pre><a name="IEHLISTlistvtoc"></a>LISTVTOC</pre>
               </td>
               <td width="89%">
                  <pre>[{DUMP | FORMAT}]</pre>
               </td>
            </tr>
            <tr>
               <td width="11%">
                  <pre></pre>
               </td>
               <td width="89%">
                  <pre>[,DATE=dddyy]</pre>
               </td>
            </tr>
            <tr>
               <td width="11%">
                  <pre></pre>
               </td>
               <td width="89%">
                  <pre>[,VOL=device=serial]</pre>
               </td>
            </tr>
            <tr>
               <td width="11%">
                  <pre></pre>
               </td>
               <td width="89%">
                  <pre>[,DSNAME=(name[,name]...)]</pre>
               </td>
            </tr>
         </tbody></table>
         <p>The LISTVTOC control statement requests a listing of all or part of a volume table of contents.&nbsp; The
            parameters are:
         </p>
         <blockquote>
            <p>DUMP | FORMAT</p>
            <blockquote>
               <p>DUMP</p>
               <blockquote>
                  <p>Specifies that the listing is to be in unedited, hexadecimal form.&nbsp;
                     Default:&nbsp; If both DUMP and FORMAT are omitted, an abbreviated edited format is generated.&nbsp;
                  </p>
               </blockquote>
               <p>FORMAT</p>
               <blockquote>
                  <p>Specifies that a comprehensive edited listing is to be generated.</p>
               </blockquote>
            </blockquote>
            <p>&nbsp;Default:&nbsp; If both DUMP and FORMAT are omitted, an abbreviated edited format is generated</p>
            <p>DATE=dddyy</p>
            <blockquote>
               <p>Specifies that each entry that expires before this date is to be flagged with an asterisk (*) in the listing.&nbsp;
                  This parameter applies only to the abbreviated edited format.&nbsp; The date is represented by ddd, the day of
                  the year, and yy, the last two digits of the year.&nbsp; Default: No asterisks appear in the listing.
               </p>
            </blockquote>
            <p>VOL=device=serial</p>
            <blockquote>
               <p>Specifies the device type and volume serial number of the volume on which the
                  VTOC resides.
               </p>
            </blockquote>
            <p>DSNAME=(name[,name]...)</p>
            <blockquote>
               <p>Specifies the fully qualified names of the datasets 
whose entries are to be listed.&nbsp; A maximum of ten names is 
allowed.&nbsp; If the
                  list consists of a single name, the parentheses can be
 omitted.&nbsp; DSNAME
                  may be abbreviated to DSN.
               </p>
            </blockquote>
         </blockquote>
      </blockquote>
      <h3>&nbsp;</h3>
      <h3>Program Parameter (PARM= on EXEC statement)</h3>
      <blockquote>
         <p>Additional information can be coded in the PARM parameter of the EXEC statement, as follows:</p>
         <blockquote>
            <p>PARM='LINECNT=nn'</p>
            <blockquote>
               <p>Specifies the number of lines, nn, to be printed per 
page; nn is a decimal number from 01 through 99.&nbsp;
                  If LINECNT is not specified, 58 lines are printed per 
page.&nbsp; The PARM field cannot contain embedded blanks,
                  zeros, or any other PARM keywords, or the default of 
58 is used.
               </p>
            </blockquote>
         </blockquote>
      </blockquote>
      <h3>&nbsp;</h3>
      <h3>Examples</h3>
      <blockquote>
         <table width="75%" cellspacing="1" border="1">
            <tbody><tr>
               <td width="33%">
                  <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="IEHLISTj01"></a>List
                     VTOC
               </p></td>
            </tr>
            <tr>
               <td width="33%">
                  <pre><b>//IEHLIST  JOB (001),'IEHLIST-VTOC',CLASS=A,MSGCLASS=X 
//IEHLIST  EXEC PGM=IEHLIST                            
//SYSPRINT DD  SYSOUT=*                                
//VOL      DD  DISP=OLD,UNIT=SYSDA,VOL=SER=PUB000      
//SYSIN    DD  *                                       
  LISTVTOC FORMAT,VOL=SYSDA=PUB000                     
//                                                     
//                     </b></pre>
               </td>
            </tr>
            <tr>
               <td width="33%">
                  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="IEHLISTj02"></a>List
                  PDS
               </td>
            </tr>
            <tr>
               <td width="33%">
                  <pre><b>//IEHLIST  JOB (001),'IEHLIST-PDS',CLASS=A,MSGCLASS=X      
//IEHLIST EXEC PGM=IEHLIST                                 
//SYSPRINT DD  SYSOUT=*                                    
//VOL      DD  DISP=OLD,UNIT=SYSDA,VOL=SER=SYSCPK          
//SYSIN    DD  *                                           
  LISTPDS DSN=SYSC.PROCLIB,VOL=SYSDA=SYSCPK,FORMAT         
//                                                         
//                     </b></pre>
               </td>
            </tr>
         </tbody></table>
      </blockquote>
      <p><font size="1">Source:&nbsp; <a href="http://bitsavers.trailing-edge.com/pdf/ibm/370/OS_VS2/Release_3.8_1978/GC26-3902-1_OS_VS2_MVS_Utilities_Rel_3.8_Sep83.pdf" target="_blank">GC26-3902-1 OS/VS2 MVS Utilities Release 3.8</a></font></p>
      <hr size="8" noshade="noshade">
      <h2><a name="IEHMAP"></a>IEHMAP <font size="2">[origin unknown, located in
         SYSC.LINKLIB]</font>
      </h2>
      <p>Used to obtain a formatted listing of a VTOC, a dataset or a catalog.&nbsp;
         Even though the name of this utility suggests it is an IBM utility, it is
         not.&nbsp; The source for several versions of IEHMAP may be found on the CBT Tape; the
         version that runs under MVS 3.8 is located in File #83 on CBT Tape V129.&nbsp;
         Note:&nbsp; The catalog functions are for OS catalogs, not MVS catalogs, which
         are VSAM, so the catalog functions of IEHMAP are not documented here.
      </p>
      <p>
         IEHMAP requires the following DD statements:
      </p>
      <ul>
         <li>SYSPRINT - defines a sequential output message dataset.</li>
         <li>SYSIN - defines a sequential input dataset that contains IEHMAP control
            statements.
         </li>
         <li>DDNAME1 [through DDNAMEn] - defines the volume(s) on which IEHMAP is to
            operate.
         </li>
      </ul>
      <h3>&nbsp;</h3>
      <h3>Control Statements</h3>
      <blockquote>
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="11%">
                  <pre><a name="IEHMAPname"></a>NAME</pre>
               </td>
               <td width="89%">
                  <pre>VOL=volid</pre>
               </td>
            </tr>
            <tr>
               <td width="11%">
                  <pre></pre>
               </td>
               <td width="89%">
                  <pre>[,OPT=NOPRINT]</pre>
               </td>
            </tr>
            <tr>
               <td width="11%">
                  <pre></pre>
               </td>
               <td width="89%">
                  <pre>[,OPT=AQUEUE]</pre>
               </td>
            </tr>
         </tbody></table>
         <p>The NAME control statement requests a report on all datasets on the volume,
            in addition to information about the Volume Table Of Contents.&nbsp; The
            information reported is:
         </p>
         <blockquote>
            <p>A)&nbsp; Information taken from the formats 4, 5, and 6:</p>
            <blockquote>
               <p>description of the device type for DASD volume<br>
                  description of the VTOC of volume<br>
                  summary of available space on the volume<br>
                  summary of split cylinder datasets (if applicable)
               </p>
            </blockquote>
            <p>B)&nbsp; An alphabetical listing of each dataset on volume, including:</p>
            <blockquote>
               <p>creation date as dd/mm/yy<br>
                  expiration date as dd/mm/yy <b>or</b> change date as dd/mm/yy <b>if OPT=AQUEUE
                  specified</b><br>
                  volume created on <b>or</b> creation date as dd/mm/yy <b>if OPT=AQUEUE
                  specified</b><br>
                  dataset sequence number <b>or</b> reference date as dd/mm/yy <b>if OPT=AQUEUE
                  specified</b><br>
                  DSORG, RECFM, BLKSIZE, LRECL, KEYLEN, OPTCD<br>
                  tracks allocated<br>
                  tracks actually used<br>
                  number of extents<br>
                  secondary allocation<br>
                  allocation type
               </p>
            </blockquote>
            <p>C)&nbsp; The number of datasets on the volume and the space they occupy.</p>
            <p>D)&nbsp; A count of the DSCB�s in the VTOC</p>
            <p>E)&nbsp; Errors found in DSCB�s counts</p>
            <p>F)&nbsp; The number of different types of dataset organizations found.</p>
            <p>G)&nbsp; The number of datasets by extents.</p>
            <p>H)&nbsp; The allocation of datasets by tracks.</p>
            <p>I)&nbsp; The number of contiguous available cylinders.</p>
            <p>J)&nbsp; The number of contiguous available tracks.
            </p>
         </blockquote>
         <p>The parameters for the NAME control statement are:</p>
         <blockquote>
            <p>VOL=volid</p>
            <blockquote>
               <p>Specifies the volume serial number for the DASD volume on which to report.</p>
            </blockquote>
            <p>OPT=NOPRINT</p>
            <blockquote>
               <p>Specifies that detail information for the dataset(s) on the volume is to be
                  suppressed; only items A and C through J below are reported.&nbsp; This is provided to give a
                  quick summary of the VTOC.
               </p>
            </blockquote>
            <p>OPT=AQUEUE</p>
            <blockquote>
               <p>Specifies that the creation, reference and change dates be formatted in place of
                  the volume created on, the dataset sequence number, and the expiration date.
               </p>
            </blockquote>
         </blockquote>
         <hr color="#808080">
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="11%">
                  <pre><a name="IEHMAPtracks"></a>TRACKS</pre>
               </td>
               <td width="89%">
                  <pre>VOL=volid</pre>
               </td>
            </tr>
            <tr>
               <td width="11%">
                  <pre></pre>
               </td>
               <td width="89%">
                  <pre>[,OPT=NOPRINT]</pre>
               </td>
            </tr>
         </tbody></table>
         <p>The TRACKS control statement requests a report on all track allocations on
            the volume, in addition to information about the Volume Table Of Contents.&nbsp;
            The information reported is:
         </p>
         <blockquote>
            <p>A)&nbsp; The allocation of each track on the volume in CCHHR order:</p>
            <blockquote>
               <p>the starting cchh<br>
                  the ending cchh<br>
                  the name of the dataset it is assigned to<br>
                  an indication that it is free space<br>
                  an indication that it is assigned to "unaccounted space" (vtoc, etc.)<br>
                  the extent number (if assigned to a dataset)<br>
                  the number of tracks in the extent
               </p>
            </blockquote>
            <p>B)&nbsp; A listing of any errors found in track allocation:</p>
            <blockquote>
               <p>overlapping tracks<br>
                  missing tracks<br>
                  invalid extents
               </p>
            </blockquote>
            <p>Note:&nbsp; If missing tracks are found, in place of the starting and ending CCHH�s a
               hexadecimal number will appear; this is the
               value that would have to be placed in a format 5 to recover this space as available space.
            </p>
            <p>C)&nbsp; A totaling of all tracks found</p>
            <p>D)&nbsp; A totaling of all tracks missing (if applicable)</p>
         </blockquote>
         <p>The parameters for the TRACKS control statement are:</p>
         <blockquote>
            <p>VOL=volid</p>
            <blockquote>
               <p>Specifies the volume serial number for the DASD volume on which to
                  report.
               </p>
            </blockquote>
            <p>OPT=NOPRINT</p>
            <blockquote>
               <p>Specifies that allocation information for the dataset(s) on the volume
                  are to be suppressed; only items B through D below are reported..
               </p>
            </blockquote>
         </blockquote>
         <hr color="#808080">
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="11%">
                  <pre><a name="IEHMAPmap"></a>MAP</pre>
               </td>
               <td width="89%">
                  <pre>VOL=volid</pre>
               </td>
            </tr>
            <tr>
               <td width="11%">
                  <pre></pre>
               </td>
               <td width="89%">
                  <pre>[,OPT=NOPRINT]</pre>
               </td>
            </tr>
         </tbody></table>
         <p>The MAP control statement requests a report that will include all of the
            information that is reported by the NAME and TRACKS control statements (above).
         </p>
         <p>The parameters for the MAP control statement are:</p>
         <blockquote>
            <p>VOL=volid</p>
            <blockquote>
               <p>Specifies the volume serial number for the DASD volume on which to
                  report.
               </p>
            </blockquote>
            <p>OPT=NOPRINT</p>
            <blockquote>
               <p>Specifies that detail information for the dataset(s) on the volume and
                  allocation information are to be suppressed.
               </p>
            </blockquote>
         </blockquote>
         <hr color="#808080">
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="11%">
                  <pre><a name="IEHMAPdump"></a>DUMP</pre>
               </td>
               <td width="89%">
                  <pre>{VOL=volid | dsname}</pre>
               </td>
            </tr>
         </tbody></table>
         <p>The DUMP control statement requests a report that will include all of the
            information that is reported by the NAME and TRACKS control statements (above),
            plus a dump of the DSCBs associated with each dataset.&nbsp; When listing a
            volume, it will also provide a hex dump of each DSCB in the format 4, 5, and 6
            chains, and the format 1 chain.
         </p>
         <p>The parameters for the DUMP control statement are:</p>
         <blockquote>
            <p>VOL=volid</p>
            <blockquote>
               <p>Specifies the volume serial number for the DASD volume on which
                  to report.&nbsp;&nbsp;
               </p>
            </blockquote>
            <p>dsname</p>
            <blockquote>
               <p>Specifies the name of the dataset on which to report.</p>
            </blockquote>
         </blockquote>
         <hr color="#808080">
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="11%">
                  <pre><a name="IEHMAPdump456"></a>DUMP456</pre>
               </td>
               <td width="89%">
                  <pre>{VOL=volid | dsname}</pre>
               </td>
            </tr>
         </tbody></table>
         <p>THe DUMP456 control statement requests a report that will include all of the
            information that is reported by the NAME control statement (above), plus a hex
            dump of the format 4, 5, and 6 chains, when
            listing a volume, and the format 1 chain, when listing a dataset.
         </p>
         <p>The parameters for the DUMP456 control statement are:</p>
         <blockquote>
            <p>VOL=volid</p>
            <blockquote>
               <p>Specifies the volume serial number for the DASD volume on which to report.</p>
            </blockquote>
            <p>dsname&nbsp;</p>
            <blockquote>
               <p>Specifies the name of the dataset on which to report.&nbsp;&nbsp;</p>
            </blockquote>
         </blockquote>
         <hr color="#808080">
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="11%">
                  <pre><a name="IEHMAPcchhr"></a>CCHHR</pre>
               </td>
               <td width="89%">
                  <pre>{VOL=volid | dsname}</pre>
               </td>
            </tr>
         </tbody></table>
         <p>The CCHRR control statement requests a report that will 
include all of the
            information that is reported by the DUMP control statement 
(above), however, the DSCBs will be dumped in CCHHR order; that is, they
 will be dumped in the order they are in the
            VTOC, not alphabetically by dataset name.&nbsp; Also, the 
various chains of DSCBs (the format 1 chain, the format 5 chain, and the
            format 6 chain) will not be dumped in chain order.&nbsp; 
This is similar to the dump option of
            IEHLIST.
         </p>
         <p>The parameters for the CCHRR control statement are:</p>
         <blockquote>
            <p>VOL=volid</p>
            <blockquote>
               <p>Specifies the volume serial number for the DASD volume on which
                  to report.
               </p>
            </blockquote>
         </blockquote>
         <hr color="#808080">
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="11%">
                  <pre><a name="IEHMAPdsname"></a>DSNAME</pre>
               </td>
               <td width="89%">
                  <pre>dsname</pre>
               </td>
            </tr>
         </tbody></table>
         <p>The DSNAME control statement will report the same information as a NAME
            control statement for a single dataset.
         </p>
         <p>The parameters for the DSNAME control statement are:</p>
         <blockquote>
            <p>dsname&nbsp;</p>
            <blockquote>
               <p>Specifies the name of the dataset on which to report.</p>
            </blockquote>
         </blockquote>
         <hr color="#808080">
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="11%">
                  <pre><a name="IEHMAPpds"></a>PDS</pre>
               </td>
               <td width="89%">
                  <pre>{VOL=volid | dsname}</pre>
               </td>
            </tr>
         </tbody></table>
         <p>The PDS control statement will report the same information 
as a DSNAME
            control statement (above), but will report only partitioned 
datasets (DSORG=PO).&nbsp;
            If
            a single dataset is requested, it will not be listed if it 
is not a Partitioned
            dataset.&nbsp;&nbsp; It will also report a listing of the 
members from the directory in
            alphabetical order, along with a dump of the directory 
information in hexadecimal, and a summary of the directory space.&nbsp;
            Note:&nbsp; An 'A' after a member name indicates that it is 
an alias.
         </p>
         <p>The parameters for the PDS control statement are:</p>
         <blockquote>
            <p>VOL=volid&nbsp;</p>
            <blockquote>
               <p>Specifies the volume serial number for the DASD volume on which
                  to report.
               </p>
            </blockquote>
            <p>dsname&nbsp;</p>
            <blockquote>
               <p>Specifies the name of the dataset on which to report.</p>
            </blockquote>
         </blockquote>
         <hr color="#808080">
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="11%">
                  <pre><a name="IEHMAPttr"></a>TTR</pre>
               </td>
               <td width="89%">
                  <pre>{VOL=volid | dsname}</pre>
               </td>
            </tr>
         </tbody></table>
         <p>The TTR control statement will report the same information as a PDS control
            statement (above),
            however, the members from the directory will be listed in TTR order, not alphabetically.&nbsp;
            Alias names will be sorted alphabetically after the true member name.
         </p>
         <p>The parameters for the TTR control statement are:</p>
         <blockquote>
            <p>VOL=volid&nbsp;</p>
            <blockquote>
               <p>Specifies the volume serial number for the DASD volume on which
                  to report.
               </p>
            </blockquote>
            <p>dsname</p>
            <blockquote>
               <p>Specifies the name of the dataset on which to report.</p>
            </blockquote>
         </blockquote>
         <hr color="#808080">
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="11%">
                  <pre><a name="IEHMAPattrib"></a>ATTRIB</pre>
               </td>
               <td width="89%">
                  <pre>{VOL=volid[,OPT=TTR] | dsname}</pre>
               </td>
            </tr>
         </tbody></table>
         <p>The ATTRIB control statement will report the same 
information as a DSNAME
            control statement (above), but will report only partitioned 
datasets (DSORG=PO).&nbsp;
            If
            a single dataset is requested, it will not be listed if it 
is not a Partitioned
            dataset.&nbsp; It will also give a listing of the members 
from the directory in
            alphabetical order, and if the members are load modules, it 
will format the linkage editor data from the directory as follows:
         </p>
         <blockquote>
            <p>the member name<br>
               an indication that the member is an alias<br>
               the ttr where the member starts<br>
               the number of user ttr�s<br>
               the ttr where the text records start<br>
               the os/vs linkage editor flags<br>
               the load module size (storage required)<br>
               the load module entry point<br>
               the setssi data (if present)<br>
               the setcode data (if present)<br>
               the true member name if an alias<br>
               the true entry point if an alias<br>
               the load modules linkage editor attributes:
            </p>
            <blockquote>
               <p>REFR refreshable<br>
                  RENT re-entrant<br>
                  REUS reuseable<br>
                  DC downward compatible<br>
                  OL only loadable<br>
                  OVLY overlay<br>
                  NE not editable<br>
                  NOTEX not executable
               </p>
            </blockquote>
         </blockquote>
         <p>The parameters for the ATTRIB control statement are:</p>
         <blockquote>
            <p>VOL=volid&nbsp;</p>
            <blockquote>
               <p>Specifies the volume serial number for the DASD volume on which
                  to report.
               </p>
            </blockquote>
            <p>OPT=TTR</p>
            <blockquote>
               <p>&nbsp;Specifies that the member names will be sorted in
                  TTR order rather than alphabetical.
               </p>
            </blockquote>
            <p>dsname</p>
            <blockquote>
               <p>Specifies the name of the dataset on which to report.</p>
            </blockquote>
         </blockquote>
         <hr color="#808080">
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="11%">
                  <pre><a name="IEHMAPdir"></a>DIR</pre>
               </td>
               <td width="89%">
                  <pre>{VOL=volid | dsname}</pre>
               </td>
            </tr>
         </tbody></table>
         <p>The DIR control statement will report the same informaiton as a NAME control
            statement, but will report only partitioned datasets (DSORG=PO).&nbsp; If
            a single dataset is requested, it will not be listed if it is not a Partitioned
            dataset.&nbsp; A summary of the directory
            space will also be reported.
         </p>
         <p>The parameters for the DIR control statement are:</p>
         <blockquote>
            <p>VOL=volid</p>
            <blockquote>
               <p>Specifies the volume serial number for the DASD volume on which
                  to report.
               </p>
            </blockquote>
            <p>dsname</p>
            <blockquote>
               <p>Specifies the name of the dataset on which to report.</p>
            </blockquote>
         </blockquote>
         <hr color="#808080">
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="11%">
                  <pre><a name="IEHMAPverify"></a>VERIFY</pre>
               </td>
               <td width="89%">
                  <pre> VOL=volid</pre>
               </td>
            </tr>
         </tbody></table>
         <p>The VERIFY control statement will report the same information as a NAME
            control statement, plus a verification of the format 4, 5, 6, and 1 chains is performed:
         </p>
         <ul>
            <li>all formats 5 are validated to be chained from the first format 5</li>
            <li>all formats 6 are validated to be chained from the format 4</li>
            <li>all formats 2 are validated to be chained from the format 1</li>
            <li>all formats 3 are validated to be chained from a format 1 or 2</li>
         </ul>
         <p>Any errors, such as dangling (ie, non-chained) formats 2, 3,
 5 or 6 are
            listed.&nbsp; If a second format 4 is found, it will be 
listed.&nbsp; If the key of a format 0 DSCB is not 44 hex zeroes, it too
 will
            be listed. If an unknown DSCB type (with an id higher than 
6) is found, it will also be listed.
         </p>
         <p>The parameter for the VERIFY control statement is:</p>
         <blockquote>
            <p>VOL=volid</p>
            <blockquote>
               <p>Specifies the volume serial number for the DASD volume on which
                  to report.
               </p>
            </blockquote>
         </blockquote>
         <hr color="#808080">
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="11%">
                  <pre><a name="IEHMAPfree"></a>FREE</pre>
               </td>
               <td width="89%">
                  <pre>VOL=volid</pre>
               </td>
            </tr>
         </tbody></table>
         <p>The FREE control statement will report a description of the VTOC and a summary of the
            available space.
         </p>
         <p>The parameter for the FREE control statement is:</p>
         <blockquote>
            <p>VOL=volid</p>
            <blockquote>
               <p>Specifies the volume serial number for the DASD volume on which
                  to report.
               </p>
            </blockquote>
         </blockquote>
         <hr color="#808080">
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="11%">
                  <pre><a name="IEHMAPoverlap"></a>OVERLAP</pre>
               </td>
               <td width="89%">
                  <pre>VOL=volid</pre>
               </td>
            </tr>
         </tbody></table>
         <p>The OVERLAP control statement will check the VTOC of the volume for overlapping extents and
            list any that are found.
         </p>
         <p>The parameter for the OVERLAP control statement is:</p>
         <blockquote>
            <p>VOL=volid</p>
            <blockquote>
               <p>Specifies the volume serial number for the DASD volume on which
                  to report.
               </p>
            </blockquote>
         </blockquote>
         <hr color="#808080">
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="11%">
                  <pre><a name="IEHMAPmissing"></a>MISSING</pre>
               </td>
               <td width="89%">
                  <pre>VOL=volid</pre>
               </td>
            </tr>
         </tbody></table>
         <p>The MISSING control statement will check the VTOC of the volume for missing tracks, and list
            any that are found.
         </p>
         <p>The parameter for the MISSING control statement is:</p>
         <blockquote>
            <p>VOL=volid</p>
            <blockquote>
               <p>Specifies the volume serial number for the DASD volume on which
                  to report.
               </p>
            </blockquote>
         </blockquote>
         <hr color="#808080">
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="11%">
                  <pre><a name="IEHMAPavail"></a>AVAIL</pre>
               </td>
               <td width="89%">
                  <pre>VOL=volid</pre>
               </td>
            </tr>
         </tbody></table>
         <p>The AVAIL control statement will list all available space on the volume in CCHHR order.</p>
         <p>The parameter for the MISSING control statement is:</p>
         <blockquote>
            <p>VOL=volid</p>
            <blockquote>
               <p>Specifies the volume serial number for the DASD volume on which
                  to report.
               </p>
            </blockquote>
         </blockquote>
         <p>The AVAIL Control statement will list all available space on the volume in CCHHR order.</p>
         <hr color="#808080">
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="11%">
                  <pre><a name="IEHMAPfixup"></a>FIXUP</pre>
               </td>
               <td width="89%">
                  <pre>VOL=volid</pre>
               </td>
            </tr>
         </tbody></table>
         <p>The FIXUP control statement makes an attempt to recover 
missing tracks on the
            volume.&nbsp; This is done by adding missing extents to the 
last format 5 in the format 5 chain, and in addition, one extra format 5
 will
            be built from a format 0.&nbsp; By this means, from 26 to 51
 missing extents may be recovered.
         </p>
         <p>The output of FIXUP is the same as two TRACKS control 
statements.&nbsp; The first output shows the missing tracks that were 
found, and the
            action that IEHMAP took (replaced or not replaced).&nbsp; 
The second is a normal TRACKS
            output showing what the VTOC looks like after the FIXUP 
operation.
         </p>
         <p>The parameter for the FIXUP control statement is:</p>
         <blockquote>
            <p>VOL=volid</p>
            <blockquote>
               <p>Specifies the volume serial number for the DASD volume to attempt
                  corrections.
               </p>
            </blockquote>
         </blockquote>
         <hr color="#808080">
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="11%">
                  <pre><a name="IEHMAPsort"></a>SORT</pre>
               </td>
               <td width="89%">
                  <pre>VOL=volid</pre>
               </td>
            </tr>
         </tbody></table>
         <p>The SORT control statement makes a more encompassing attempt to recover
            missing tracks than a FIXUP control statement.&nbsp; IEHMAP attempts to arrange
            the missing tracks in CCHHR order in the format 5 chain, then the format 5 chain
            is rewritten.&nbsp; The output of a SORT operation is the same as a FIXUP;
            however, all free space will be listed as missing, and the action IEHMAP took
            will be shown.&nbsp;
         </p>
         <p>SORT should be used if the second output of a FIXUP shows that IEHMAP has
            created multiple contiguous extents, and/or the volume has more than three
            formats 5.&nbsp; By multiple contiguous free extents is meant two or more
            contiguous extents marked as 'AVAILABLE' on the second output of FIXUP.
         </p>
         <p>The parameter for the SORT control statement is:</p>
         <blockquote>
            <p>VOL=volid</p>
         </blockquote>
         <blockquote>
            <blockquote>
               <p>Specifies the volume serial number for the DASD volume to attempt
                  corrections.
               </p>
            </blockquote>
         </blockquote>
      </blockquote>
      <p>&nbsp;</p>
      <h3>Program Parameter (PARM= on EXEC statement)</h3>
      <blockquote>
         <p>Additional information can be coded in the PARM parameter of the EXEC statement, as follows:</p>
         <blockquote>
            <p>PARM='[LINES=nnn][,MIN=mmm],[MAX=vvv][,TSO]'</p>
            <p>The parameters are:</p>
            <blockquote>
               <p>LINES=nnn</p>
               <blockquote>
                  <p>nnn specifies the number of lines to print per page.&nbsp; If specified,
                     the number may range 10 through 999; if a number is submitted outside this
                     range, the default will be used.&nbsp; The default line count is 56.&nbsp;
                     LINES may be abbreviated L.
                  </p>
               </blockquote>
               <p>MIN=mmm</p>
               <blockquote>
                  <p>mmm specifies the minimum value (in k-bytes) for the variable conditional GETMAIN�s IEHMAP does to
                     obtain the area for control blocks, reading in DSCB�s, etc.&nbsp; This
                     will be rouanded to the next higher 4-k boundary.&nbsp; The default is 64 (16 4-k pages).
                  </p>
               </blockquote>
               <p>MAX=vvv</p>
               <blockquote>
                  <p>vvv is the maximum value (in k-bytes) for the 
variable conditional GETMAIN�s IEHMAP does to obtain the area for
                     control blocks, reading in DSCB�s, etc.&nbsp; 
This will be rounded to the next higher
                     4-k boundary.&nbsp; The value must be at least 1 
(one) higher than the value of the MIN= parameter (or its default); if
                     it is not, it will be set to mmm+4.&nbsp; The 
default value is 128 (32 4-k pages).
                  </p>
               </blockquote>
               <p>TSO</p>
               <blockquote>
                  <p>notifies IEHMAP that it is running under TSO, and, therefore, it is not authorized.&nbsp;
                     When running under TSO, it cannot ENQ upon the VTOC or catalog; also, the FIXUP and SORT
                     Control statements cannot be specified.
                  </p>
               </blockquote>
            </blockquote>
         </blockquote>
      </blockquote>
      <h3>&nbsp;</h3>
      <h3>Examples</h3>
      <blockquote>
         <table width="75%" cellspacing="1" border="1">
            <tbody><tr>
               <td width="33%">
                  <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="IEHMAPj01"></a>List
                     all datasets on volume
               </p></td>
            </tr>
            <tr>
               <td width="33%">
                  <pre><b>//IEHMAP  JOB  (001),'IEHMAP',CLASS=A,MSGCLASS=X                        
//IEHMAP  EXEC PGM=IEHMAP,REGION=4096K                                  
//SYSPRINT DD  SYSOUT=*                                                 
//DD1      DD  UNIT=SYSALLDA,VOL=SER=SYSP01,DISP=OLD                    
//SYSIN    DD  *                                                        
  NAME   VOL=SYSP01,OPT=AQUEUE 
*                                                                       
* List all volume information and all datasets:                         
*      NAME VOL=volid[,OPT=NOPRINT][OPT=AQUEUE]                         
*                                     change/create/refer dates         
*                        suppress dataset list                          
* List track summary and all allocations for datasets:                  
*      TRACKS VOL=volid[,OPT=NOPRINT]                                    
*                         suppress allocations for datasets             
* List combined NAME &amp; TRACK information with single command:           
*      MAP VOL=volid[,OPT=NOPRINT]                                      
*                       suppress dataset &amp; allocation detail            
* List MAP information, plus hex dump of DSCBs:                         
*      DUMP VOL=volid   datasetname                                     
* List NAME information, plus hex dump of DSCBs:                        
*      DUMP456 VOL=volid   datasetname                                  
* List DUMP information,only in CCHHR order:                            
*      CCHHR VOL=volid                                                  
* List NAME information for single dataset:                             
*      DSNAME datasetname                                               
* List NAME information, only include Partitioned datasets:             
*      PDS VOL=volid   datasetname                                      
* List PDS information, only in TTR order:                              
*      TTR VOL=volid   datasetname                                      
* List DSNAME information, only include Partitioned datasets:           
*      ATTRIB VOL=volid[OPT=TTR]                                       
*                          sort member names in TTR order               
* List NAME information, plus directory information, only include       
* Partitioned datasets:                                                 
*      DIR VOL=volid   dsname                                           
* List NAME information, plus errors in DSCBs:                          
*      VERIFY VOL=volid                                                 
* List VTOC and available space information:                            
*      FREE VOL=volid                                                   
* List overlapping extents:                                             
*      OVERLAP VOL=volid                                                
* List missing tracks:                                                  
*      MISSING VOL=volid                                                
* List available space in CCHHR order:                                  
*      AVAIL VOL=volid                                                  
/*                                                                      
//                                                                      </b></pre>
               </td>
            </tr>
         </tbody></table>
      </blockquote>
      <hr size="8" noshade="noshade">
      <h2><a name="IEHMOVE"></a>IEHMOVE <font size="2">[supplied by IBM, located in
         SYS1.LINKLIB]</font>
      </h2>
      <p align="LEFT">Used to move or copy one or several datasets from one DASD
         volume to another.&nbsp; IEHMOVE can be used to move or copy:
      </p>
      <ul>
         <li>
            <p align="LEFT">A dataset residing on from one to five volumes, with the
               exception of ISAM datasets, and VSAM data spaces.
         </p></li>
         <li>
            <p align="LEFT">A group of cataloged datasets.
         </p></li>
         <li>
            <p align="LEFT">An OS catalog (CVOL) or portions of a CVOL.
         </p></li>
         <li>
            <p align="LEFT">A volume of datasets.
         </p></li>
      </ul>
      <p align="LEFT">In an IEHMOVE action, if the target device type is not capable
         of receiving a copy of the source dataset (i.e., source is DASD and target is
         tape), IEHMOVE attempts to reorganize the data in order to create an unloaded
         copy of the source dataset; if a subsequent IEHMOVE specifies the unloaded copy
         as source and a target that is capable of receiving the original dataset format,
         IEHMOVE attempts to recreate the original format of the original source dataset.
      </p>
      <p align="LEFT">IEHMOVE frequently gets bad reviews, and there are other
         utilities that may be used to do most of the functions it provides, but I still
         find it useful when I am moving datasets from one DASD volume to another.&nbsp;
         I will not be including Control statements that I have found not to work, or
         problematic, under MVS and VSAM catalogs.&nbsp; <b><font color="#0000FF">I would
         also suggest taking a look at PDSUR, which is able to read (and process) IEHMOVE
         unloaded datasets as well as create unloaded datasets in IEHMOVE format.</font></b>
      </p>
      <p align="LEFT">In the scope of this page, IEHMOVE's functions relating to OS
         catalogs (CVOLs) is not really applicable, since MVS uses VSAM catalogs, so
         those functions will not be covered.
      </p>
      <p>IEHMOVE requires the following DD statements:</p>
      <ul>
         <li>SYSPRINT - defines a sequential output message dataset.</li>
         <li>SYSIN - defines a sequential input dataset that contains IEHMOVE control
            statements.
         </li>
         <li>SYSUT1 - defines a DASD volume on which three required work datasets will
            be allocated.
         </li>
         <li>anyname1 - defines the source dataset.</li>
         <li>anyname2 - defines the target dataset.</li>
      </ul>
      <p>&nbsp;</p>
      <h3>Control Statements</h3>
      <p>Control statements for IEHMOVE follow the same rules as JCL; i.e., if a
         statement requires continuation onto a following record, the operands on the
         record to be continued are stopped following a comma before reaching column 72,
         a non-blank character is placed in column 72, and the statement continues on the
         following record beginning in column 16.
      </p>
      <blockquote>
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="9%">
                  <pre><a name="IEHMOVEmovedsname"></a>MOVE</pre>
               </td>
               <td width="91%">
                  <pre>DSNAME=name</pre>
               </td>
            </tr>
            <tr>
               <td width="9%">
                  <pre></pre>
               </td>
               <td width="91%">
                  <pre>,FROM=device=serial</pre>
               </td>
            </tr>
            <tr>
               <td width="9%">
                  <pre></pre>
               </td>
               <td width="91%">
                  <pre>[,FROMDD=ddname]</pre>
               </td>
            </tr>
            <tr>
               <td width="9%">
                  <pre></pre>
               </td>
               <td width="91%">
                  <pre>,TO=device=serial</pre>
               </td>
            </tr>
            <tr>
               <td width="9%">
                  <pre></pre>
               </td>
               <td width="91%">
                  <pre>[,TODD=ddname]</pre>
               </td>
            </tr>
            <tr>
               <td width="9%">
                  <pre></pre>
               </td>
               <td width="91%">
                  <pre>[,UNCATLG]</pre>
               </td>
            </tr>
            <tr>
               <td width="9%">
                  <pre></pre>
               </td>
               <td width="91%">
                  <pre>[,RENAME=newname]</pre>
               </td>
            </tr>
            <tr>
               <td width="9%">
                  <pre></pre>
               </td>
               <td width="91%">
                  <pre>[,UNLOAD]</pre>
               </td>
            </tr>
            <tr>
               <td width="9%">
                  <pre></pre>
               </td>
               <td width="91%">
                  <pre>[,COPYAUTH]</pre>
               </td>
            </tr>
         </tbody></table>
         <p>The MOVE DSNAME control statement is used to move a dataset.&nbsp; The source dataset is scratched.&nbsp; The
            parameters are:
         </p>
         <blockquote>
            <p>DSNAME=name</p>
            <blockquote>
               <p>Specifies the fully qualified name of the dataset to be moved.</p>
            </blockquote>
            <p>FROM=device=serial</p>
            <blockquote>
               <p>Specifies the device type and serial number of the volume on which the
                  dataset resides if it is not cataloged.&nbsp; If the dataset is cataloged,
                  FROM should not be specified.
               </p>
            </blockquote>
            <p>FROMDD=ddname</p>
            <blockquote>
               <p>Specifies the name of the DD statement from which DCB 
and LABEL
                  information (except dataset sequence number), for 
input datasets on tape
                  volumes, can be obtained.&nbsp; When FROMDD is used 
for a partitioned
                  dataset, the tape dataset must be an unloaded version 
of a partitioned dataset.&nbsp; The FROMDD operand can be omitted, 
provided
                  the dataset has
                  standard labels<br>
                  and resides on a 9-track tape volume.
               </p>
            </blockquote>
            <p>TO=device=serial</p>
            <blockquote>
               <p>Specifies the device type and volume serial number of the volume to which
                  the dataset is to be moved.&nbsp;
               </p>
            </blockquote>
            <p>TODD=ddname</p>
            <blockquote>
               <p>Specifies the name of a DD statement from which DCB (except RECFM,
                  BLKSIZE and LRECL) and LABEL (except dataset sequence number) information
                  for output datasets on tape volumes, can be obtained.
               </p>
            </blockquote>
            <p>UNCATLG</p>
            <blockquote>
               <p>Specifies that the catalog entry pertaining to the source dataset is to
                  be removed.&nbsp; This parameter should be used only if the source dataset
                  is cataloged.&nbsp;&nbsp; If the volume is identified by FROM, UNCATLG is
                  ignored.&nbsp; Alias entries in VSAM catalogs for the source datasets are
                  lost and can be replaced with Access Method Services if the datasets are
                  later cataloged.&nbsp; For a MOVE operation, UNCATLG inhibits cataloging of
                  the output dataset.
               </p>
            </blockquote>
            <p>RENAME=newname</p>
            <blockquote>
               <p>Specifies that the dataset is to be renamed, and indicates the new name.</p>
            </blockquote>
            <p>UNLOAD</p>
            <blockquote>
               <p>Specifies that the dataset is to be unloaded to the receiving volume(s).</p>
            </blockquote>
            <p>COPYAUTH</p>
            <blockquote>
               <p>Specifies that the receiving dataset is to be given the same access list
                  as the input dataset, if the input dataset is RACF-protected.
               </p>
            </blockquote>
         </blockquote>
         <hr color="#808080">
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="9%">
                  <pre><a name="IEHMOVEmovepds"></a>MOVE</pre>
               </td>
               <td width="91%">
                  <pre>PDS=name</pre>
               </td>
            </tr>
            <tr>
               <td width="9%">
                  <pre></pre>
               </td>
               <td width="91%">
                  <pre>,FROM=device=serial</pre>
               </td>
            </tr>
            <tr>
               <td width="9%">
                  <pre></pre>
               </td>
               <td width="91%">
                  <pre>[,FROMDD=ddname]</pre>
               </td>
            </tr>
            <tr>
               <td width="9%">
                  <pre></pre>
               </td>
               <td width="91%">
                  <pre>,TO=device=serial</pre>
               </td>
            </tr>
            <tr>
               <td width="9%">
                  <pre></pre>
               </td>
               <td width="91%">
                  <pre>[,TODD=ddname]</pre>
               </td>
            </tr>
            <tr>
               <td width="9%">
                  <pre></pre>
               </td>
               <td width="91%">
                  <pre>[,UNCATLG]</pre>
               </td>
            </tr>
            <tr>
               <td width="9%">
                  <pre></pre>
               </td>
               <td width="91%">
                  <pre>[,RENAME=newname]</pre>
               </td>
            </tr>
            <tr>
               <td width="9%">
                  <pre></pre>
               </td>
               <td width="91%">
                  <pre>[,UNLOAD]</pre>
               </td>
            </tr>
            <tr>
               <td width="9%">
                  <pre></pre>
               </td>
               <td width="91%">
                  <pre>[,EXPAND=nn]</pre>
               </td>
            </tr>
            <tr>
               <td width="9%">
                  <pre></pre>
               </td>
               <td width="91%">
                  <pre>[,COPYAUTH]</pre>
               </td>
            </tr>
         </tbody></table>
         <p>The MOVE PDS control statement is used to move partitioned datasets.&nbsp; When used in conjunction with
            INCLUDE, EXCLUDE, REPLACE, or SELECT statements, the MOVE PDS statement can be
            used to merge selected members of several partitioned datasets or to delete
            members.&nbsp; If IEHMOVE is used to allocate space for an output partitioned
            dataset, the MOVE PDS statement can be used to expand a partitioned
            directory.&nbsp; If the receiving volume contains a partitioned dataset with the
            same name, the two datasets are merged.&nbsp; The source dataset is
            scratched.&nbsp; The parameters are:
         </p>
         <blockquote>
            <p>PDS=name</p>
            <blockquote>
               <p>Specifies the fully qualified name of the partitioned dataset to be moved
                  or copied.
               </p>
            </blockquote>
            <p>FROM=device=serial</p>
            <blockquote>
               <p>Specifies the device type and serial number of the volume on which the
                  dataset resides if it is not cataloged.&nbsp; If the dataset is cataloged,
                  FROM should not be specified.
               </p>
            </blockquote>
            <p>FROMDD=ddname</p>
            <blockquote>
               <p>Specifies the name of the DD statement from which DCB 
and LABEL
                  information (except dataset sequence number), for 
input datasets on tape
                  volumes, can be obtained.&nbsp; When FROMDD is used 
for a partitioned
                  dataset, the tape dataset must be an unloaded version 
of a partitioned dataset.&nbsp; The FROMDD operand can be omitted, 
provided
                  the dataset has
                  standard labels<br>
                  and resides on a 9-track tape volume.
               </p>
            </blockquote>
            <p>TO=device=serial</p>
            <blockquote>
               <p>Specifies the device type and volume serial number of the volume to which
                  the partitioned dataset is to be moved.
               </p>
            </blockquote>
            <p>TODD=ddname</p>
            <blockquote>
               <p>Specifies the name of a DD statement from which DCB (except RECFM,
                  BLKSIZE and LRECL) and LABEL (except dataset sequence number) information
                  for output datasets on tape volumes, can be obtained.
               </p>
            </blockquote>
            <p>UNCATLG</p>
            <blockquote>
               <p>Specifies that the catalog entry pertaining to the source partitioned
                  dataset is to be removed.&nbsp; This parameter should be used only if the
                  source dataset is cataloged.&nbsp; If the volume is identified by FROM,
                  UNCATLG is ignored.&nbsp; Alias entries in VSAM catalogs for the source
                  datasets are lost and can be replaced with Access Method Services if the
                  datasets are later cataloged.&nbsp; For a MOVE operation,<br>
                  UNCATLG inhibits cataloging of the output dataset.
               </p>
            </blockquote>
            <p>RENAME=newname</p>
            <blockquote>
               <p>Specifies that the dataset is to be renamed, and indicates the new name.</p>
            </blockquote>
            <p>UNLOAD</p>
            <blockquote>
               <p>Specifies that the dataset is to be unloaded to the receiving volume(s).</p>
            </blockquote>
            <p>EXPAND=nn</p>
            <blockquote>
               <p>Specifies the number of 256-byte records (up to 99 decimal) to be added
                  to the directory of the specified partitioned dataset.&nbsp; EXPAND will be
                  ignored if space is previously allocated.
               </p>
            </blockquote>
            <p>COPYAUTH</p>
            <blockquote>
               <p>Specifies that the receiving dataset is to be given the same access list
                  as the input dataset, if the input dataset is RACF-protected.
               </p>
            </blockquote>
         </blockquote>
         <hr color="#808080">
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="9%">
                  <pre><a name="IEHMOVEmovedsgroup"></a>MOVE</pre>
               </td>
               <td width="91%">
                  <pre>DSGROUP=name</pre>
               </td>
            </tr>
            <tr>
               <td width="9%">
                  <pre></pre>
               </td>
               <td width="91%">
                  <pre>,TO=device=serial</pre>
               </td>
            </tr>
            <tr>
               <td width="9%">
                  <pre></pre>
               </td>
               <td width="91%">
                  <pre>[,TODD=ddname]</pre>
               </td>
            </tr>
            <tr>
               <td width="9%">
                  <pre></pre>
               </td>
               <td width="91%">
                  <pre>[,UNCATLG]</pre>
               </td>
            </tr>
            <tr>
               <td width="9%">
                  <pre></pre>
               </td>
               <td width="91%">
                  <pre>[,UNLOAD]</pre>
               </td>
            </tr>
            <tr>
               <td width="9%">
                  <pre></pre>
               </td>
               <td width="91%">
                  <pre>[,COPYAUTH]</pre>
               </td>
            </tr>
         </tbody></table>
         <p>The MOVE DSGROUP control statement is used to move groups of datasets whose names are partially qualified by one or
            more identical names.&nbsp; Source datasets are scratched.&nbsp; Dataset groups
            to be moved must reside on direct access volumes.&nbsp; Only datasets that could
            be moved by MOVE DSNAME or MOVE PDS can be moved by MOVE DSGROUP.&nbsp; Alias
            entries in VSAM catalogs for the datasets are lost and can be replaced with
            Access Method Services.&nbsp; The parameters are:
         </p>
         <blockquote>
            <p>DSGROUP=name</p>
            <blockquote>
               <p>Specifies the cataloged dataset(s) to be moved.&nbsp; If name is a fully
                  qualified dataset name, that dataset is not moved.&nbsp; If name is one or
                  more qualifiers, all datasets whose names are qualified by name are moved.
               </p>
            </blockquote>
            <p>TO=device=serial</p>
            <blockquote>
               <p>Specifies the device type and volume serial number of the volume to which
                  the dataset(s) is to be moved.
               </p>
            </blockquote>
            <p>TODD=ddname</p>
            <blockquote>
               <p>Specifies the name of a DD statement from which DCB (except RECFM,
                  BLKSIZE and LRECL) and LABEL (except dataset sequence number) information
                  for output datasets on tape volumes, can be obtained.
               </p>
            </blockquote>
            <p>UNCATLG</p>
            <blockquote>
               <p>Specifies that the catalog entry pertaining to the source dataset(s) is
                  to be removed.&nbsp; This parameter should be used only if the source
                  dataset(s) is cataloged.&nbsp; If the volume is identified by FROM, UNCATLG
                  is&nbsp; ignored.&nbsp; Alias entries in VSAM catalogs for the source
                  dataset(s) are lost and can be replaced with Access Method Services if the
                  dataset(s) are later cataloged.&nbsp; For a MOVE operation, UNCATLG inhibits
                  cataloging of the output dataset(s).
               </p>
            </blockquote>
            <p>UNLOAD</p>
            <blockquote>
               <p>Specifies that the dataset is to be unloaded to the receiving volume(s).</p>
            </blockquote>
            <p>COPYAUTH</p>
            <blockquote>
               <p>Specifies that the receiving dataset is to be given the same access list
                  as the input dataset, if the input dataset is RACF-protected.
               </p>
            </blockquote>
         </blockquote>
         <hr color="#808080">
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="9%">
                  <pre><a name="IEHMOVEmovevolume"></a>MOVE</pre>
               </td>
               <td width="91%">
                  <pre>VOLUME=device=serial</pre>
               </td>
            </tr>
            <tr>
               <td width="9%">
                  <pre></pre>
               </td>
               <td width="91%">
                  <pre>,TO=device=serial</pre>
               </td>
            </tr>
            <tr>
               <td width="9%">
                  <pre></pre>
               </td>
               <td width="91%">
                  <pre>[,TODD=ddname]</pre>
               </td>
            </tr>
            <tr>
               <td width="9%">
                  <pre></pre>
               </td>
               <td width="91%">
                  <pre>[,UNLOAD]</pre>
               </td>
            </tr>
            <tr>
               <td width="9%">
                  <pre></pre>
               </td>
               <td width="91%">
                  <pre>[,COPYAUTH]</pre>
               </td>
            </tr>
         </tbody></table>
         <p>The MOVE VOLUME is used to move all the datasets residing on a specified volume.&nbsp; Datasets
            to be moved must reside on direct access volumes.&nbsp; The parameters are:
         </p>
         <blockquote>
            <p>VOLUME=device=serial</p>
            <blockquote>
               <p>Specifies the device type and volume serial number of the source volume.</p>
            </blockquote>
            <p>TO=device=serial</p>
            <blockquote>
               <p>Specifies the device type and volume serial number of the volume to which
                  the datasets are to be moved.
               </p>
            </blockquote>
            <p>TODD=ddname</p>
            <blockquote>
               <p>Specifies the name of a DD statement from which DCB (except RECFM,
                  BLKSIZE and LRECL) and LABEL (except dataset sequence number) information
                  for output datasets on tape volumes, can be obtained.
               </p>
            </blockquote>
            <p>UNLOAD</p>
            <blockquote>
               <p>Specifies that the dataset is to be unloaded to the receiving volume(s).</p>
            </blockquote>
            <p>COPYAUTH</p>
            <blockquote>
               <p>Specifies that the receiving dataset is to be given the same access list
                  as the input dataset, if the input dataset is RACF-protected.
               </p>
            </blockquote>
         </blockquote>
         <hr color="#808080">
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="9%">
                  <pre><a name="IEHMOVEcopydsname"></a>COPY</pre>
               </td>
               <td width="91%">
                  <pre>DSNAME=name</pre>
               </td>
            </tr>
            <tr>
               <td width="9%">
                  <pre></pre>
               </td>
               <td width="91%">
                  <pre>,FROM=device=serial</pre>
               </td>
            </tr>
            <tr>
               <td width="9%">
                  <pre></pre>
               </td>
               <td width="91%">
                  <pre>[,FROMDD=ddname]</pre>
               </td>
            </tr>
            <tr>
               <td width="9%">
                  <pre></pre>
               </td>
               <td width="91%">
                  <pre>,TO=device=serial</pre>
               </td>
            </tr>
            <tr>
               <td width="9%">
                  <pre></pre>
               </td>
               <td width="91%">
                  <pre>[,TODD=ddname]</pre>
               </td>
            </tr>
            <tr>
               <td width="9%">
                  <pre></pre>
               </td>
               <td width="91%">
                  <pre>[,UNCATLG]</pre>
               </td>
            </tr>
            <tr>
               <td width="9%">
                  <pre></pre>
               </td>
               <td width="91%">
                  <pre>[,CATLG]</pre>
               </td>
            </tr>
            <tr>
               <td width="9%">
                  <pre></pre>
               </td>
               <td width="91%">
                  <pre>[,RENAME=newname]</pre>
               </td>
            </tr>
            <tr>
               <td width="9%">
                  <pre></pre>
               </td>
               <td width="91%">
                  <pre>[,UNLOAD]</pre>
               </td>
            </tr>
            <tr>
               <td width="9%">
                  <pre></pre>
               </td>
               <td width="91%">
                  <pre>[,COPYAUTH]</pre>
               </td>
            </tr>
         </tbody></table>
         <p>The COPY DSNAME is used to copy a dataset.&nbsp; The source dataset, if cataloged, remains
            cataloged unless UNCATLG or CATLG is specified.&nbsp; The parameters are:
         </p>
         <blockquote>
            <p>DSNAME=name</p>
            <blockquote>
               <p>Specifies the fully qualified name of the dataset to be copied.</p>
            </blockquote>
            <p>FROM=device=serial</p>
            <blockquote>
               <p>Specifies the device type and serial number of the volume on which the
                  dataset resides if it is not cataloged.&nbsp; If the dataset is cataloged,
                  FROM should not be specified.
               </p>
            </blockquote>
            <p>FROMDD=ddname</p>
            <blockquote>
               <p>Specifies the name of the DD statement from which DCB 
and LABEL
                  information (except dataset sequence number), for 
input datasets on tape
                  volumes, can be obtained.&nbsp; When FROMDD is used 
for a partitioned
                  dataset, the tape dataset must be an unloaded version 
of a partitioned dataset.&nbsp; The FROMDD operand can be omitted, 
provided
                  the dataset has
                  standard labels<br>
                  and resides on a 9-track tape volume.
               </p>
            </blockquote>
            <p>TO=device=serial</p>
            <blockquote>
               <p>Specifies the device type and volume serial number of the volume to which
                  the dataset is to be copied.
               </p>
            </blockquote>
            <p>TODD=ddname</p>
            <blockquote>
               <p>Specifies the name of a DD statement from which DCB (except RECFM,
                  BLKSIZE and LRECL) and LABEL (except dataset sequence number) information
                  for output datasets on tape volumes, can be obtained.
               </p>
            </blockquote>
            <p>UNCATLG</p>
            <blockquote>
               <p>Specifies that the catalog entry pertaining to the source dataset is to
                  be removed.&nbsp; This parameter should be used only if the source dataset
                  is cataloged.&nbsp; If the volume is identified by FROM, UNCATLG is ignored.&nbsp;
                  Alias entries in VSAM catalogs for the source datasets are lost and can be
                  replaced with Access Method Services if the datasets are later
                  cataloged.&nbsp;
               </p>
            </blockquote>
            <p>CATLG</p>
            <blockquote>
               <p>Specifies that the copied dataset(s) is to be cataloged.&nbsp; The
                  cataloging is done in the VSAM master/JOBCAT/STEPCAT catalog.&nbsp;&nbsp; If
                  the RENAME and FROM operands are omitted, the source dataset(s) is
                  uncataloged to permit the copied dataset(s) to be cataloged.
               </p>
            </blockquote>
            <p>RENAME=newname</p>
            <blockquote>
               <p>Specifies that the dataset is to be renamed, and indicates the new name.</p>
            </blockquote>
            <p>UNLOAD</p>
            <blockquote>
               <p>Specifies that the dataset is to be unloaded to the receiving volume(s).</p>
            </blockquote>
            <p>COPYAUTH</p>
            <blockquote>
               <p>Specifies that the receiving dataset is to be given the same access list
                  as the input dataset, if the input dataset is RACF-protected.
               </p>
            </blockquote>
         </blockquote>
         <hr color="#808080">
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="9%">
                  <pre><a name="IEHMOVEcopypds"></a>COPY</pre>
               </td>
               <td width="91%">
                  <pre>PDS=name</pre>
               </td>
            </tr>
            <tr>
               <td width="9%">
                  <pre></pre>
               </td>
               <td width="91%">
                  <pre>,FROM=device=serial</pre>
               </td>
            </tr>
            <tr>
               <td width="9%">
                  <pre></pre>
               </td>
               <td width="91%">
                  <pre>[,FROMDD=ddname]</pre>
               </td>
            </tr>
            <tr>
               <td width="9%">
                  <pre></pre>
               </td>
               <td width="91%">
                  <pre>,TO=device=serial</pre>
               </td>
            </tr>
            <tr>
               <td width="9%">
                  <pre></pre>
               </td>
               <td width="91%">
                  <pre>[,TODD=ddname]</pre>
               </td>
            </tr>
            <tr>
               <td width="9%">
                  <pre></pre>
               </td>
               <td width="91%">
                  <pre>[,UNCATLG]</pre>
               </td>
            </tr>
            <tr>
               <td width="9%">
                  <pre></pre>
               </td>
               <td width="91%">
                  <pre>[,CATLG]</pre>
               </td>
            </tr>
            <tr>
               <td width="9%">
                  <pre></pre>
               </td>
               <td width="91%">
                  <pre>[,RENAME=newname]</pre>
               </td>
            </tr>
            <tr>
               <td width="9%">
                  <pre></pre>
               </td>
               <td width="91%">
                  <pre>[,EXPAND=nn]</pre>
               </td>
            </tr>
            <tr>
               <td width="9%">
                  <pre></pre>
               </td>
               <td width="91%">
                  <pre>[,COPYAUTH]</pre>
               </td>
            </tr>
         </tbody></table>
         <p>The COPY PDS control statement is used to copy partitioned datasets.&nbsp; When used in conjunction with
            INCLUDE, EXCLUDE, REPLACE, or SELECT statements, the COpy PDS statement can be
            used to merge selected members of several partitioned datasets or to delete
            members.&nbsp; If IEHMOVE is used to allocate space for an output partitioned
            dataset, the COPY PDS statement can be used to expand a partitioned
            directory.&nbsp; If the receiving volume already contains a partitioned dataset
            with the same name, the two are merged.&nbsp; The parameters are:
         </p>
         <blockquote>
            <p>PDS=name</p>
            <blockquote>
               <p>Specifies the fully qualified name of the partitioned dataset to be moved
                  or copied.
               </p>
            </blockquote>
            <p>FROM=device=serial</p>
            <blockquote>
               <p>Specifies the device type and serial number of the volume on which the
                  dataset resides if it is not cataloged.&nbsp; If the dataset is cataloged,
                  FROM should not be specified.
               </p>
            </blockquote>
            <p>FROMDD=ddname</p>
            <blockquote>
               <p>Specifies the name of the DD statement from which DCB 
and LABEL
                  information (except dataset sequence number), for 
input datasets on tape
                  volumes, can be obtained.&nbsp; When FROMDD is used 
for a partitioned
                  dataset, the tape dataset must be an unloaded version 
of a partitioned dataset.&nbsp; The FROMDD operand can be omitted, 
provided
                  the dataset has
                  standard labels<br>
                  and resides on a 9-track tape volume.
               </p>
            </blockquote>
            <p>TO=device=serial</p>
            <blockquote>
               <p>Specifies the device type and volume serial number of the volume to which
                  the partitioned dataset is to be copied.
               </p>
            </blockquote>
            <p>TODD=ddname</p>
            <blockquote>
               <p>Specifies the name of a DD statement from which DCB (except RECFM,
                  BLKSIZE and LRECL) and LABEL (except dataset sequence number) information
                  for output datasets on tape volumes, can be obtained.
               </p>
            </blockquote>
            <p>UNCATLG</p>
            <blockquote>
               <p>Specifies that the catalog entry pertaining to the source partitioned
                  dataset is to be removed.&nbsp; This parameter should be used only if the
                  source dataset is cataloged.&nbsp; If the volume is identified by FROM,
                  UNCATLG is ignored.&nbsp; Alias entries in VSAM catalogs for the source
                  datasets are lost and can be replaced with Access Method Services if the
                  datasets are later cataloged.&nbsp;
               </p>
            </blockquote>
            <p>CATLG</p>
            <blockquote>
               <p>Specifies that the copied dataset(s) is to be cataloged.&nbsp; The
                  cataloging is done in the VSAM master/JOBCAT/STEPCAT catalog.&nbsp;&nbsp; If
                  the RENAME and FROM operands are omitted, the source dataset(s) is
                  uncataloged to permit the copied dataset(s) to be cataloged.
               </p>
            </blockquote>
            <p>RENAME=newname</p>
            <blockquote>
               <p>Specifies that the dataset is to be renamed, and indicates the new name.</p>
            </blockquote>
            <p>EXPAND=nn</p>
            <blockquote>
               <p>Specifies the number of 256-byte records (up to 99 decimal) to be added
                  to the directory of the specified partitioned dataset.&nbsp; EXPAND cannot
                  be specified if space is previously allocated.&nbsp;&nbsp;
               </p>
            </blockquote>
            <p>COPYAUTH</p>
            <blockquote>
               <p>Specifies that the receiving dataset is to be given the same access list
                  as the input dataset, if the input dataset is RACF-protected.
               </p>
            </blockquote>
         </blockquote>
         <hr color="#808080">
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="9%">
                  <pre><a name="IEHMOVEcopydsgroup"></a>COPY</pre>
               </td>
               <td width="91%">
                  <pre>DSGROUP=name</pre>
               </td>
            </tr>
            <tr>
               <td width="9%">
                  <pre></pre>
               </td>
               <td width="91%">
                  <pre>,TO=device=serial</pre>
               </td>
            </tr>
            <tr>
               <td width="9%">
                  <pre></pre>
               </td>
               <td width="91%">
                  <pre>[,TODD=ddname]</pre>
               </td>
            </tr>
            <tr>
               <td width="9%">
                  <pre></pre>
               </td>
               <td width="91%">
                  <pre>[,UNCATLG]</pre>
               </td>
            </tr>
            <tr>
               <td width="9%">
                  <pre></pre>
               </td>
               <td width="91%">
                  <pre>[,CATLG]</pre>
               </td>
            </tr>
            <tr>
               <td width="9%">
                  <pre></pre>
               </td>
               <td width="91%">
                  <pre>[,UNLOAD]</pre>
               </td>
            </tr>
            <tr>
               <td width="9%">
                  <pre></pre>
               </td>
               <td width="91%">
                  <pre>[,COPYAUTH]</pre>
               </td>
            </tr>
         </tbody></table>
         <p>The COPY DSGROUP is used to copy groups of datasets whose names are partially qualified by one or
            more identical names.&nbsp; Only datasets that can be copied with COPY DSNAME or
            COPY PDS can be copied with COPY DSGROUP.&nbsp; Dataset groups to be copied must
            reside on DASD volumes.&nbsp; The parameters are:
         </p>
         <blockquote>
            <p>DSGROUP=name</p>
            <blockquote>
               <p>Specifies the cataloged dataset(s) to be copied.&nbsp; If name is a fully
                  qualified dataset name, that dataset is not copied.&nbsp; If name is one or
                  more qualifiers, all datasets whose names are qualified by name are copied.
               </p>
            </blockquote>
            <p>TO=device=serial</p>
            <blockquote>
               <p>Specifies the device type and volume serial number of the volume to which
                  the dataset(s) is to be copied.
               </p>
            </blockquote>
            <p>TODD=ddname</p>
            <blockquote>
               <p>Specifies the name of a DD statement from which DCB (except RECFM,
                  BLKSIZE and LRECL) and LABEL (except dataset sequence number) information
                  for output datasets on tape volumes, can be obtained.
               </p>
            </blockquote>
            <p>UNCATLG</p>
            <blockquote>
               <p>Specifies that the catalog entry pertaining to the source dataset(s) is
                  to be removed.&nbsp; This parameter should be used only if the source
                  dataset(s) is cataloged.&nbsp; If the volume is identified by FROM, UNCATLG
                  is ignored.&nbsp; Alias entries in VSAM catalogs for the source dataset(s)
                  are lost and can be replaced with Access Method Services if the dataset(s)
                  are later cataloged.&nbsp;
               </p>
            </blockquote>
            <p>CATLG</p>
            <blockquote>
               <p>Specifies that the copied dataset(s) is to be cataloged.&nbsp; The
                  cataloging is done in the VSAM master/JOBCAT/STEPCAT catalog.&nbsp;&nbsp;&nbsp;
               </p>
            </blockquote>
            <p>UNLOAD</p>
            <blockquote>
               <p>Specifies that the dataset is to be unloaded to the receiving volume(s).</p>
            </blockquote>
            <p>COPYAUTH</p>
            <blockquote>
               <p>Specifies that the receiving dataset is to be given the same access list
                  as the input dataset, if the input dataset is RACF-protected.
               </p>
            </blockquote>
         </blockquote>
         <hr color="#808080">
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="9%">
                  <pre><a name="IEHMOVEcopyvolume"></a>COPY</pre>
               </td>
               <td width="91%">
                  <pre>VOLUME=device=serial</pre>
               </td>
            </tr>
            <tr>
               <td width="9%">
                  <pre></pre>
               </td>
               <td width="91%">
                  <pre>,TO=device=serial</pre>
               </td>
            </tr>
            <tr>
               <td width="9%">
                  <pre></pre>
               </td>
               <td width="91%">
                  <pre>[,TODD=ddname]</pre>
               </td>
            </tr>
            <tr>
               <td width="9%">
                  <pre></pre>
               </td>
               <td width="91%">
                  <pre>[,CATLG]</pre>
               </td>
            </tr>
            <tr>
               <td width="9%">
                  <pre></pre>
               </td>
               <td width="91%">
                  <pre>[,UNLOAD]</pre>
               </td>
            </tr>
            <tr>
               <td width="9%">
                  <pre></pre>
               </td>
               <td width="91%">
                  <pre>[,COPYAUTH]</pre>
               </td>
            </tr>
         </tbody></table>
         <p>The COPY VOLUME is used to copy all the datasets residing on a specified volume.&nbsp; Datasets
            to be copied must reside on direct access volumes.&nbsp; The parameters are:
         </p>
         <blockquote>
            <p>VOLUME=device=serial</p>
            <blockquote>
               <p>Specifies the device type and volume serial number of the source volume.</p>
            </blockquote>
            <p>TO=device=serial</p>
            <blockquote>
               <p>Specifies the device type and volume serial number of the volume to which
                  the datasets are to be copied.
               </p>
            </blockquote>
            <p>TODD=ddname</p>
            <blockquote>
               <p>Specifies the name of a DD statement from which DCB (except RECFM,
                  BLKSIZE and LRECL) and LABEL (except dataset sequence number) information
                  for output datasets on tape volumes, can be obtained.
               </p>
            </blockquote>
            <p>CATLG</p>
            <blockquote>
               <p>Specifies that the copied dataset(s) is to be cataloged.&nbsp; The
                  cataloging is done in the VSAM master/JOBCAT/STEPCAT catalog.&nbsp; In my
                  experience, under MVS, CATLG will fail because the source dataset(s) are not
                  uncataloged.&nbsp;
               </p>
            </blockquote>
            <p>UNLOAD</p>
            <blockquote>
               <p>Specifies that the dataset is to be unloaded to the receiving volume(s).</p>
            </blockquote>
            <p>COPYAUTH</p>
            <blockquote>
               <p>Specifies that the receiving dataset is to be given the same access list
                  as the input dataset, if the input dataset is RACF-protected.
               </p>
            </blockquote>
         </blockquote>
         <p>&nbsp;</p>
      </blockquote>
      <h3>Program Parameter (PARM= on EXEC statement)</h3>
      <blockquote>
         <p>The optional PARM values which may be specified are PARM='[POWER=n][,LINECNT=xx]'.&nbsp;
            The values are:
         </p>
         <blockquote>
            <p>POWER=n</p>
            <blockquote>
               <p>Used to request that the normal amount of space allocated for work areas be
                  increased n times (1 to 999).&nbsp; The POWER parameter is used when 750 or
                  more members are being moved or copied.&nbsp; The progression for the value of
                  n is:
               </p>
               <ul>
                  <li>POWER=2 when 750 to 1,500 members are to be moved or copied.</li>
                  <li>POWER=3 when 1,501 to 2,250 members are to be moved or copied.</li>
                  <li>POWER=4 when 2,251 to 3,000 members are to be moved or copied.</li>
               </ul>
               <p>If POWER = 2, the work space requirement on the SYSUT1 volume is two
                  times the basic requirement; if POWER=3, work space requirement is three
                  times the basic requirement, etc.&nbsp; For example, if POWER=2, three
                  areas of 26, 26, and 52 contiguous tracks on a 2314 must be
                  available.&nbsp; If a direct access device other than a 2314 is used, an
                  equivalent amount of space must be available.
               </p>
            </blockquote>
            <p>LINECNT=xx</p>
            <blockquote>
               <p>Specifies the number of lines per page in the listing of the SYSPRINT
                  dataset; xx is a two-digit number in the range 04 through 99.
               </p>
            </blockquote>
         </blockquote>
      </blockquote>
      <p>&nbsp;</p>
      <h3>Examples</h3>
      <blockquote>
         <table width="75%" cellspacing="1" border="1">
            <tbody><tr>
               <td width="33%">
                  <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="IEHMOVEj01"></a>Copy
                     partitioned dataset from one DASD to another DASD, recataloging
               </p></td>
            </tr>
            <tr>
               <td width="33%">
                  <pre><b>//IEHMOVE JOB (001),'IEHMOVE-1',CLASS=A,MSGCLASS=X                      
//IEHMOVE EXEC PGM=IEHMOVE,REGION=4096K,PARM='POWER=9'                 
//SYSPRINT DD  SYSOUT=*                                                 
//SYSUT1   DD  UNIT=3390,VOL=SER=PUB001,DISP=OLD                        
//DDFROM   DD  UNIT=3380,VOL=SER=MVS380,DISP=OLD                        
//DDTO     DD  UNIT=3380,VOL=SER=MVS381,DISP=OLD                        
//SYSIN    DD  *  
  COPY PDS=JAY01.FILE807.PDS,FROM=3380=MVS380,TO=3380=MVS381,          C
               UNCATLG,CATLG                                            
//</b></pre>
               </td>
            </tr>
            <tr>
               <td width="33%">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="IEHMOVEj02"></a>Copy
                  all datasets from one DASD volume to another DASD volume
               </td>
            </tr>
            <tr>
               <td width="33%">
                  <pre><b>//IEHMOVE JOB (001),'IEHMOVE-2',CLASS=A,MSGCLASS=X         
//IEHMOVE EXEC PGM=IEHMOVE,REGION=4096K,PARM='POWER=9'     
//SYSPRINT DD  SYSOUT=*                                    
//SYSUT1   DD  UNIT=3390,VOL=SER=PUB001,DISP=OLD           
//DDFROM   DD  UNIT=3380,VOL=SER=MVS381,DISP=OLD           
//DDTO     DD  UNIT=3380,VOL=SER=SYSP01,DISP=OLD           
//SYSIN    DD  *                                           
  COPY VOLUME=3380=MVS380,TO=3380=SYSP01                   </b><b>
//</b></pre>
               </td>
            </tr>
            <tr>
               <td width="33%">
                  <b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="IEHMOVEj03"></a></b>Move
                  all datasets matching HLQ from one DASD to another DASD, recataloging
               </td>
            </tr>
            <tr>
               <td width="33%">
                  <pre><b>//IEHMOVE JOB (001),'IEHMOVE-3',CLASS=A,MSGCLASS=X                      
//IEHMOVE EXEC PGM=IEHMOVE,REGION=4096K,PARM='POWER=9'                  
//SYSPRINT DD  SYSOUT=*                                                 
//SYSUT1   DD  UNIT=3390,VOL=SER=PUB001,DISP=OLD                        
//DDFROM   DD  UNIT=3380,VOL=SER=PUB000,DISP=OLD                        
//DDTO     DD  UNIT=3380,VOL=SER=MVS381,DISP=OLD                        
//SYSIN    DD  *                                                        
  MOVE DSGROUP=HMVS01.PROJECT1,                                        C
               FROM=3380=PUB000,TO=3380=MVS381                         </b><b>
//</b></pre>
               </td>
            </tr>
            <tr>
               <td width="33%">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="IEHMOVEj04"></a>Unload
                  all datasets matching HLQ from DASD to tape
               </td>
            </tr>
            <tr>
               <td width="33%">
                  <pre><b>//IEHMOVE JOB (001),'IEHMOVE-4',CLASS=A,MSGCLASS=X                      
//IEHMOVE EXEC PGM=IEHMOVE,REGION=4096K,PARM='POWER=9'                  
//SYSPRINT DD  SYSOUT=*                                                 
//SYSUT1   DD  UNIT=3390,VOL=SER=PUB001,DISP=OLD                        
//DDFROM   DD  UNIT=3380,VOL=SER=PUB000,DISP=OLD                        
//DDTO     DD  UNIT=TAPE,VOL=SER=22005M,DISP=(NEW,KEEP),LABEL=(1,SL)    
//SYSIN    DD  *                                                        
  COPY DSGROUP=HMVS01,                                                 C
               FROM=3380=PUB000,TO=TAPE=22005M,UNLOAD                   </b><b>
//</b></pre>
               </td>
            </tr>
            <tr>
               <td width="33%">
                  <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="IEHMOVEj05"></a>Reload
                     partitioned dataset from tape to DASD
               </p></td>
            </tr>
            <tr>
               <td width="33%">
                  <pre><b>//IEHMOVE JOB (001),'IEHMOVE-5',CLASS=A,MSGCLASS=X                      
//IEHMOVE EXEC PGM=IEHMOVE,REGION=4096K,PARM='POWER=9'                  
//SYSPRINT DD  SYSOUT=*                                                 
//SYSUT1   DD  UNIT=3390,VOL=SER=PUB001,DISP=OLD                        
//DDIN     DD  UNIT=TAPE,DSN=JAY01.FILE046.PDS,DISP=OLD,                
//             VOL=SER=22005M,LABEL=(4,SL)                              
//DDOUT    DD  UNIT=3380,VOL=SER=MVS380,DISP=OLD                        
//SYSIN    DD  *                                                        
  COPY DSNAME=HMVS01.FILE046.PDS,                                      C
               FROM=TAPE=(22005M,4),TO=3380=MVS380                      </b><b>
//</b></pre>
               </td>
            </tr>
         </tbody></table>
      </blockquote>
      <p><font size="1">Source:&nbsp; <a href="http://bitsavers.trailing-edge.com/pdf/ibm/370/OS_VS2/Release_3.8_1978/GC26-3902-1_OS_VS2_MVS_Utilities_Rel_3.8_Sep83.pdf" target="_blank">GC26-3902-1 OS/VS2 MVS Utilities Release 3.8</a></font></p>
      <hr size="8" noshade="noshade">
      <h2><a name="IEHPROGM"></a>IEHPROGM <font size="2">[supplied by IBM, located in
         SYS1.LINKLIB]</font>
      </h2>
      <p align="LEFT">Used to modify system control data and to maintain datasets at an organizational level.&nbsp;
         IEHPROGM can be used to:
      </p>
      <ul>
         <li>
            <p align="LEFT">Scratch a dataset or a member.
         </p></li>
         <li>
            <p align="LEFT">Rename a dataset or a member.
         </p></li>
         <li>
            <p align="LEFT">Catalog or uncatalog a non-VSAM dataset.
         </p></li>
         <li>
            <p align="LEFT">Maintain dataset passwords.
         </p></li>
      </ul>
      <p>IEHPROGM requires the following DD statements:</p>
      <ul>
         <li>SYSPRINT - defines a sequential output message dataset.</li>
         <li>SYSIN - defines a sequential input dataset that contains IEHPROGM control
            statements.
         </li>
         <li>anyname1 - defines the DASD volume on which affected datasets reside.</li>
      </ul>
      <p>&nbsp;</p>
      <h3>Control Statements</h3>
      <p>Control statements for IEHPROGM follow the same rules as JCL; i.e., if a
         statement requires continuation onto a following record, the operands on the
         record to be continued are stopped following a comma before reaching column 72,
         a non-blank character is placed in column 72, and the statement continues on the
         following record beginning in column 16.
      </p>
      <blockquote>
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="12%">
                  <pre><a name="IEHPROGMscratch"></a>SCRATCH  </pre>
               </td>
               <td width="88%">
                  <pre>{DSNAME=name | VTOC}</pre>
               </td>
            </tr>
            <tr>
               <td width="12%">
                  <pre></pre>
               </td>
               <td width="88%">
                  <pre>[,VOL=device=list]</pre>
               </td>
            </tr>
            <tr>
               <td width="12%">
                  <pre></pre>
               </td>
               <td width="88%">
                  <pre>[,PURGE]</pre>
               </td>
            </tr>
            <tr>
               <td width="12%">
                  <pre></pre>
               </td>
               <td width="88%">
                  <pre>[,MEMBER=name]</pre>
               </td>
            </tr>
            <tr>
               <td width="12%">
                  <pre></pre>
               </td>
               <td width="88%">
                  <pre>[,SYS]</pre>
               </td>
            </tr>
         </tbody></table>
         <p>The SCRATCH control statement is used to scratch a dataset 
or member from a DASD volume.&nbsp; A dataset or member is
            scratched only from the volumes designated in the SCRATCH 
statement.&nbsp; This function does not uncatalog scratched 
datasets.&nbsp;
            The parameters are:
         </p>
         <blockquote>
            <p>DSNAME=name | VTOC</p>
            <blockquote>
               <p>DSNAME=name</p>
               <blockquote>
                  <p>Specifies the fully qualified name of either the 
dataset to be scratched or the partitioned dataset that contains the 
member to be
                     scratched.&nbsp; The qualified name must not exceed
 44 characters, including delimiters.
                  </p>
               </blockquote>
               <p>VTOC</p>
               <blockquote>
                  <p>Specifies that all datasets on the specified volume, except those protected by a password or those whose expiration
                     dates have not expired, are to be scratched.&nbsp; Password-protected datasets are
                     scratched if the correct password is provided.&nbsp; The effect of VTOC is modified
                     when it is used with PURGE or SYS.&nbsp; <b><font color="#FF0000">Extreme
                     caution is advised when specifying VTOC and PURGE together; the result will be
                     the removal of all datasets on the volume with no warning given nor
                     confirmation
                     required.</font></b>
                  </p>
               </blockquote>
            </blockquote>
            <p>VOL=device=list</p>
            <blockquote>
               <p>Specifies the device type and serial number(s) of the volume(s), limited to 50, that contain the
                  dataset(s).
               </p>
               <p>If VTOC or MEMBER is specified, VOL cannot specify more than one volume.&nbsp;
                  Caution should be used when specifying VTOC if VOL specifies the system residence
                  volume.
               </p>
            </blockquote>
            <p>PURGE</p>
            <blockquote>
               <p>Specifies that each dataset specified by DSNAME or VTOC be scratched, even if its expiration date has not elapsed.&nbsp;
                  Default:&nbsp; The specified datasets are scratched only if their expiration dates have elapsed.
               </p>
            </blockquote>
            <p>MEMBER=name</p>
            <blockquote>
               <p>Specifies a member name or alias of a member (in the 
named dataset) to be removed from the directory of a partitioned 
dataset.&nbsp;
                  This name is not validity-checked because all members 
must be accessible, whether the name is valid or not.
               </p>
            </blockquote>
            <p>SYS</p>
            <blockquote>
               <p>Specifies that datasets that have names that begin with "AAAAAAAA.AAAAAAAA.AAAAAAAA.AAAAAAAA." or
                  "SYSnnnnn.T" and "P" or "V" in position 19 are to be scratched.&nbsp;
                  These are names<br>
                  assigned to datasets by the operating system.&nbsp; This parameter is valid only when VTOC is specified.&nbsp;
                  If the name of the dataset to be scratched begins with SYS, nnnnn is the date.
               </p>
            </blockquote>
         </blockquote>
         <hr color="#808080">
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="10%">
                  <pre><a name="IEHPROGMrename"></a>RENAME  </pre>
               </td>
               <td width="90%">
                  <pre>DSNAME=name</pre>
               </td>
            </tr>
            <tr>
               <td width="10%">
                  <pre></pre>
               </td>
               <td width="90%">
                  <pre>,VOL=device=list</pre>
               </td>
            </tr>
            <tr>
               <td width="10%">
                  <pre></pre>
               </td>
               <td width="90%">
                  <pre>,NEWNAME=name</pre>
               </td>
            </tr>
            <tr>
               <td width="10%">
                  <pre></pre>
               </td>
               <td width="90%">
                  <pre>[,MEMBER=name]</pre>
               </td>
            </tr>
         </tbody></table>
         <p>The RENAME control statement is used to change the name or alias of a dataset or member residing on a DASD volume.&nbsp;
            The name is changed only on the designated volume(s).&nbsp; The rename operation does not update the catalog.&nbsp;
            The parameters are:
         </p>
         <blockquote>
            <p>DSNAME=name</p>
            <blockquote>
               <p>Specifies the fully qualified name of either the dataset to be renamed or the partitioned dataset that contains the member to be
                  renamed.&nbsp; The qualified name must not exceed 44 characters, including delimiters.
               </p>
            </blockquote>
            <p>VOL=device=list</p>
            <blockquote>
               <p>Specifies the device type and serial number(s) of the volume(s), limited to 50, that contain the
                  dataset(s).
               </p>
               <p>If MEMBER is specified, VOL cannot specify more than one volume.</p>
            </blockquote>
            <p>NEWNAME=name</p>
            <blockquote>
               <p>Specifies the new fully qualified name for the dataset, or the new member or alias.</p>
            </blockquote>
            <p>MEMBER=name</p>
            <blockquote>
               <p>Specifies a member name or alias of a member (in the named dataset) to be renamed.&nbsp;
                  This name is not validity-checked because all members must be accessible, whether the name is valid or not.
               </p>
            </blockquote>
         </blockquote>
         <hr color="#808080">
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="9%">
                  <pre><a name="IEHPROGMcatlg"></a>CATLG  </pre>
               </td>
               <td width="91%">
                  <pre>DSNAME=name</pre>
               </td>
            </tr>
            <tr>
               <td width="9%">
                  <pre></pre>
               </td>
               <td width="91%">
                  <pre>,VOL=device=list</pre>
               </td>
            </tr>
         </tbody></table>
         <p>The CATLG control statement is used to add an entry for a non-VSAM dataset to a catalog.&nbsp; The
            parameters are:
         </p>
         <blockquote>
            <p>DSNAME=name</p>
            <blockquote>
               <p>Specifies the fully qualified name of either the dataset to be cataloged.&nbsp;
                  The qualified name must not exceed 44 characters, including delimiters.
               </p>
            </blockquote>
            <p>VOL=device=list</p>
            <blockquote>
               <p>Specifies the device type and serial number(s) of the volume(s), limited to 50, that contain the
                  dataset(s).
               </p>
               <p>The volume serial numbers must appear in the same order in which they were originally encountered (in
                  DD statements within the input stream) when the dataset was created.
               </p>
            </blockquote>
         </blockquote>
         <hr color="#808080">
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="12%">
                  <pre><a name="IEHPROGMuncatlg"></a>UNCATLG</pre>
               </td>
               <td width="88%">
                  <pre>DSNAME=name</pre>
               </td>
            </tr>
         </tbody></table>
         <p>The UNCATLG control statemetn is used to remove an entry for a non-VSAM dataset from a catalog.&nbsp; The
            parameter is:
         </p>
         <blockquote>
            <p>DSNAME=name</p>
            <blockquote>
               <p>Specifies the fully qualified name of either the dataset to be uncataloged.&nbsp;
                  The qualified name must not exceed 44 characters, including delimiters.
               </p>
            </blockquote>
         </blockquote>
         <hr color="#808080">
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="9%">
                  <pre><a name="IEHPROGMadd"></a>ADD</pre>
               </td>
               <td width="91%">
                  <pre>DSNAME=name</pre>
               </td>
            </tr>
            <tr>
               <td width="9%">
                  <pre></pre>
               </td>
               <td width="91%">
                  <pre>[,PASWORD2=new-password]</pre>
               </td>
            </tr>
            <tr>
               <td width="9%">
                  <pre></pre>
               </td>
               <td width="91%">
                  <pre>[,CPASWORD=control-password]</pre>
               </td>
            </tr>
            <tr>
               <td width="9%">
                  <pre></pre>
               </td>
               <td width="91%">
                  <pre>[,TYPE=code]</pre>
               </td>
            </tr>
            <tr>
               <td width="9%">
                  <pre></pre>
               </td>
               <td width="91%">
                  <pre>[,VOL=device=list]</pre>
               </td>
            </tr>
            <tr>
               <td width="9%">
                  <pre></pre>
               </td>
               <td width="91%">
                  <pre>[,DATA='user-data']</pre>
               </td>
            </tr>
         </tbody></table>
         <p>The ADD control statement is used to add a password entry in
 the PASSWORD dataset.&nbsp; When the control entry for a direct access,
 online dataset is added, the indicated
            protection status of the dataset is set in the DSCB; when a 
secondary entry is added, the protection status in the DSCB is not 
changed.&nbsp;
            The parameters are:
         </p>
         <blockquote>
            <p>DSNAME=name</p>
            <blockquote>
               <p>Specifies the fully qualified name of either the dataset whose password entry is to be
                  assigned.&nbsp; The qualified name must not exceed 44 characters, including delimiters.
               </p>
            </blockquote>
            <p>PASWORD1=current-password</p>
            <p>PASWORD2=new-password</p>
            <blockquote>
               <p>Specifies the new password to be added or assigned to the entry.&nbsp; If the
                  password is not to be changed, the current password must also be specified as the new password.&nbsp;
                  The password can consist of one to eight alphameric characters.&nbsp; Default:&nbsp;
                  The operator is prompted for a new password.
               </p>
            </blockquote>
            <p>CPASWORD=control-password
            </p>
            <blockquote>
               <p>Specifies the control password for the dataset.&nbsp; CPASWORD must be specified unless this is the first
                  password assigned to the dataset, in which case PASWORD2 specifies the password to be added.
               </p>
            </blockquote>
            <p>TYPE=code
            </p>
            <blockquote>
               <p>Specifies the protection code of the password, and if a control password entry is to be
                  changed for or assigned to a direct access, online dataset, specifies the protection
                  status of the dataset. The values that can be specified for code are:
               </p>
               <ul>
                  <li>1 - Specifies that the password is to allow both read and write access to the dataset; if a control
                     password is being assigned or changed, read/write protection is set in the
                     DSCB.
                  </li>
                  <li>2 - Specifies that the password is to allow only read access to the dataset; if control password
                     is assigned or changed, read/write protection is set in the DSCB.
                  </li>
                  <li>3 - Specifies that the password is to allow b0th read and write access to the dataset; if a control
                     password is being assigned or changed, read-without-password protection is set in the
                     DSCB.
                  </li>
               </ul>
               <p>Default:&nbsp; For ADD, if this parameter is omitted the new password is assigned the same protection code
                  as the control password for the dataset.&nbsp; If a control password is being "added,"
                  TYPE=3 is the default.&nbsp;&nbsp;
               </p>
            </blockquote>
            <p>VOL=device=list
            </p>
            <blockquote>
               <p>Specifies the device type and serial number(s) of the volume(s), limited to 50, that contain the
                  dataset(s).
               </p>
               <p>If omitted, the protection status in the DSCB is not 
set or changed, unless the dataset is
                  cataloged.&nbsp; This parameter is not necessary for 
secondary password entries, or if the desired protection status in the
                  DSCB is already set or is not to be changed by ADD or 
REPLACE.
               </p>
            </blockquote>
            <p>DATA='user-data'
            </p>
            <blockquote>
               <p>Specifies the user data is to be placed in the 
password entry.&nbsp; The user
                  data has a maximum length of 77 bytes and must be 
enclosed in apostrophes.&nbsp;
                  If DATA is omitted from an ADD operation, 77 blanks 
are used.&nbsp; If DATA is omitted from a REPLACE operation, current 
user data is not
                  changed.
               </p>
            </blockquote>
         </blockquote>
         <hr color="#808080">
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="11%">
                  <pre><a name="IEHPROGMreplace"></a>REPLACE  </pre>
               </td>
               <td width="89%">
                  <pre>DSNAME=name</pre>
               </td>
            </tr>
            <tr>
               <td width="11%">
                  <pre></pre>
               </td>
               <td width="89%">
                  <pre>[,PASWORD1=current-password]</pre>
               </td>
            </tr>
            <tr>
               <td width="11%">
                  <pre></pre>
               </td>
               <td width="89%">
                  <pre>[,PASWORD2= new-password]</pre>
               </td>
            </tr>
            <tr>
               <td width="11%">
                  <pre></pre>
               </td>
               <td width="89%">
                  <pre>[,CPASWORD=control-password]</pre>
               </td>
            </tr>
            <tr>
               <td width="11%">
                  <pre></pre>
               </td>
               <td width="89%">
                  <pre>[,TYPE=code]</pre>
               </td>
            </tr>
            <tr>
               <td width="11%">
                  <pre></pre>
               </td>
               <td width="89%">
                  <pre>[,VOL=device=list]</pre>
               </td>
            </tr>
            <tr>
               <td width="11%">
                  <pre></pre>
               </td>
               <td width="89%">
                  <pre>[,DATA='user-data']</pre>
               </td>
            </tr>
         </tbody></table>
         <p>The REPLACE control statement is used to replace any or all 
of the following information in a password entry:&nbsp;
            the password name, protection mode (read/write or read only)
 of the password, and user data.&nbsp;
            When the control entry for a direct access, online dataset 
is replaced, the protection status of the dataset is changed in the
            DSCB if necessary; when a secondary entry is replaced, the 
protection status in the
            DSCB is not changed.&nbsp; The parameters are:
         </p>
         <blockquote>
            <p>DSNAME=name</p>
            <blockquote>
               <p>Specifies the fully qualified name of either the dataset whose password entry is to be
                  changed.&nbsp; The qualified name must not exceed 44 characters, including delimiters.
               </p>
            </blockquote>
            <p>PASWORD1=current-password</p>
            <blockquote>
               <p>Specifies the password in the entry to be changed.&nbsp; Default: The operator is prompted for the current password.</p>
            </blockquote>
            <p>PASWORD2=new-password</p>
            <blockquote>
               <p>Specifies the new password to be added or assigned to 
the entry.&nbsp; If the
                  password is not to be changed, the current password 
must also be specified as the new password.&nbsp; The password can 
consist of
                  one to eight alphameric characters.&nbsp; 
Default:&nbsp; The operator is prompted for a new password.
               </p>
            </blockquote>
            <p>CPASWORD=control-password</p>
            <blockquote>
               <p>Specifies the control password for the dataset.&nbsp; CPASWORD must be specified unless the control entry is
                  being changed or deleted, in which case PASWORD1 specifies the control password.
               </p>
            </blockquote>
            <p>TYPE=code
            </p>
            <blockquote>
               <p>Specifies the protection code of the password, and if a control password entry is to be
                  changed for or assigned to a direct access, online dataset, specifies the protection
                  status of the dataset. The values that can be specified for code are:
               </p>
               <ul>
                  <li>1 - Specifies that the password is to allow both read and write access to the dataset; if a control
                     password is being assigned or changed, read/write protection is set in the
                     DSCB.
                  </li>
                  <li>2 - Specifies that the password is to allow only read access to the dataset; if control password
                     is assigned or changed, read/write protection is set in the DSCB.
                  </li>
                  <li>3 - Specifies that the password is to allow b0th read and write access to the dataset; if a control
                     password is being assigned or changed, read-without-password protection is set in the
                     DSCB.
                  </li>
               </ul>
               <p>Default:&nbsp; For REPLACE, the protection is not changed.
               </p>
            </blockquote>
            <p>VOL=device=list</p>
            <blockquote>
               <p>Specifies the device type and serial number(s) of the volume(s), limited to 50, that contain the
                  dataset(s).
               </p>
               <p>If omitted, the protection status in the DSCB is not 
set or changed, unless the dataset is
                  cataloged.&nbsp; This parameter is not necessary for 
secondary password entries, or if the desired protection status in the
                  DSCB is already set or is not to be changed by ADD or 
REPLACE.
               </p>
            </blockquote>
            <p>DATA='user-data'
            </p>
            <blockquote>
               <p>Specifies the user data is to be placed in the password entry.&nbsp; The user
                  data has a maximum length of 77 bytes and must be enclosed in apostrophes.&nbsp;
                  If DATA is omitted from a REPLACE operation, current user data is not changed.
               </p>
            </blockquote>
         </blockquote>
         <hr color="#808080">
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="11%">
                  <pre><a name="IEHPROGMdeletep"></a>DELETEP  </pre>
               </td>
               <td width="89%">
                  <pre>DSNAME=name</pre>
               </td>
            </tr>
            <tr>
               <td width="11%">
                  <pre></pre>
               </td>
               <td width="89%">
                  <pre>[,PASWORD1=current-password]</pre>
               </td>
            </tr>
            <tr>
               <td width="11%">
                  <pre></pre>
               </td>
               <td width="89%">
                  <pre>[,CPASWORD=control-password]</pre>
               </td>
            </tr>
            <tr>
               <td width="11%">
                  <pre></pre>
               </td>
               <td width="89%">
                  <pre>[,VOL=device=list]</pre>
               </td>
            </tr>
         </tbody></table>
         <p>The DELETEP control statement is used to delete an entry in 
the PASSWORD dataset.&nbsp; If a control entry is deleted, all the 
secondary entries for
            that dataset are also deleted.&nbsp; If a secondary entry is
 deleted, only that entry is deleted.&nbsp;
            When the control entry for a direct access, online dataset 
is deleted, the protection status in the DSCB is
            set to indicate that the dataset is no longer 
protected.&nbsp; The parameters
            are:<br>
         </p>
         <blockquote>
            <p>DSNAME=name</p>
            <blockquote>
               <p>Specifies the fully qualified name of either the dataset whose password entry is to be deleted.&nbsp; The
                  qualified name must not exceed 44 characters, including delimiters.
               </p>
            </blockquote>
            <p>PASWORD1=current-password</p>
            <blockquote>
               <p>Specifies the password in the entry to be deleted.&nbsp; Default: The operator is prompted for the current password.</p>
            </blockquote>
            <p>CPASWORD=control-password</p>
            <blockquote>
               <p>Specifies the control password for the dataset.&nbsp; CPASWORD must be specified unless the control entry is
                  being changed or deleted, in which case PASWORD1 specifies the control password.
               </p>
            </blockquote>
            <p>VOL=device=list</p>
            <blockquote>
               <p>Specifies the device type and serial number(s) of the volume(s), limited to 50, that contain the
                  dataset(s).
               </p>
               <p>If omitted, the protection status in the DSCB is not 
set or changed, unless the dataset is
                  cataloged.&nbsp; This parameter is not necessary for 
secondary password entries, or if the desired protection status in the
                  DSCB is already set or is not to be changed by ADD or 
REPLACE.
               </p>
            </blockquote>
         </blockquote>
         <hr color="#808080">
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="9%">
                  <pre><a name="IEHPROGMlist"></a>LIST  </pre>
               </td>
               <td width="91%">
                  <pre>DSNAME=name</pre>
               </td>
            </tr>
            <tr>
               <td width="9%">
                  <pre></pre>
               </td>
               <td width="91%">
                  <pre>,PASWORD1=current-password</pre>
               </td>
            </tr>
         </tbody></table>
         <p>The LIST control statement is used to format and print information from a password entry.&nbsp; The
            parameters are:
         </p>
         <blockquote>
            <p>DSNAME=name</p>
            <blockquote>
               <p>Specifies the fully qualified name of the dataset whose password entry is to be
                  listed.&nbsp; The qualified name must not exceed 44 characters, including delimiters.
               </p>
            </blockquote>
            <p>PASWORD1=current-password</p>
            <blockquote>
               <p>Specifies the password in the entry to be listed.&nbsp; Default: The operator is prompted for the current password.</p>
            </blockquote>
         </blockquote>
      </blockquote>
      <h3>&nbsp;</h3>
      <h3>Examples</h3>
      <blockquote>
         <table width="75%" cellspacing="1" border="1">
            <tbody><tr>
               <td width="33%">
                  <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="IEHPROGMj01"></a>Scratch
                     all expired datasets, including SYS datasets
               </p></td>
            </tr>
            <tr>
               <td width="33%">
                  <pre><b>//IEHPROGM JOB (001),'IEHPROGM-1',CLASS=S,MSGCLASS=X                    
//PROGM    EXEC PGM=IEHPROGM                                            
//SYSPRINT  DD SYSOUT=*                                                 
//DD1       DD UNIT=3350,VOL=SER=WORK00,DISP=OLD                        
//SYSIN     DD  *                                                        
   SCRATCH VTOC,VOL=3350=WORK00
</b><b>//</b></pre>
               </td>
            </tr>
            <tr>
               <td width="33%">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="IEHPROGMj02"></a>Remove
                  all datasets on volume, regardless of expiration status
               </td>
            </tr>
            <tr>
               <td width="33%">
                  <pre><b>//IEHPROGM JOB (001),'IEHPROGM-2',CLASS=S,MSGCLASS=X                    
//PROGM    EXEC PGM=IEHPROGM                                            
//SYSPRINT  DD SYSOUT=*                                                 
//DD1       DD UNIT=3380,VOL=SER=MVS380,DISP=OLD                        
//SYSIN     DD  *                                                        
   SCRATCH VTOC,PURGE,VOL=3380=MVS380</b><b>
//</b></pre>
               </td>
            </tr>
            <tr>
               <td width="33%">
                  <b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="IEHPROGMj03"></a></b>Scratch
                  and uncatalog two datasets
               </td>
            </tr>
            <tr>
               <td width="33%">
                  <pre><b>//IEHPROGM JOB (001),'IEHPROGM-3',CLASS=S,MSGCLASS=X                    
//PROGM    EXEC PGM=IEHPROGM                                            
//SYSPRINT  DD SYSOUT=*                                                 
//DD1       DD UNIT=3380,VOL=SER=MVS380,DISP=OLD                        
//SYSIN     DD  *                                                        
   UNCATLG JAY01.CUSTOMER.MASTER
   SCRATCH JAY01.CUSTOMER.MASTER,VOL=3380=MVS380
   UNCATLG JAY01.FILE807.PDS
   SCRATCH JAY01.FILE807.PDS,VOL=3380=MVS380</b><b>
//</b></pre>
               </td>
            </tr>
            <tr>
               <td width="33%">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="IEHPROGMj04"></a>Rename
                  and recatalog a dataset
               </td>
            </tr>
            <tr>
               <td width="33%">
                  <pre><b>//IEHPROGM JOB (001),'IEHPROGM-4',CLASS=S,MSGCLASS=X                    
//PROGM    EXEC PGM=IEHPROGM                                            
//SYSPRINT  DD SYSOUT=*                                                 
//DD1       DD UNIT=3380,VOL=SER=MVS380,DISP=OLD                        
//SYSIN     DD  *                                                        
   RENAME DSNAME=JAY01.SIMULAO.LINKLIB,NEWNAME=JAY01.SIMULAN.LINKLIB,  C
               VOL=3380=MVS380 </b><b>
   UNCATLG </b><b>JAY01.SIMULAO.LINKLIB
</b><b>   CATLG JAY01.SIMULAN.LINKLIB
</b><b>//</b></pre>
               </td>
            </tr>
            <tr>
               <td width="33%">
                  <b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="IEHPROGMj05"></a></b>Add
                  passwords to a dataset
               </td>
            </tr>
            <tr>
               <td width="33%">
                  <pre><b>//IEHPROGM JOB (001),'IEHPROGM-5',CLASS=S,MSGCLASS=X                    
//PROGM    EXEC PGM=IEHPROGM                                            
//SYSPRINT  DD SYSOUT=*                                                 
//DD1       DD UNIT=3380,VOL=SER=MVS380,DISP=OLD                        
//SYSIN     DD  *                                                        
   ADD DSNAME=JAY01.STUDENT.MASTER,PASWORD2=KEY,TYPE=1,                C
               DATA='SECONDARY IS READ'
   ADD DSNAME=JAY01.STUDENT.MASTER,CPASWORD=KEY,TYPE=2,                C
               PASWORD2=READ,DATA='ASSIGNED TO J.DOE'
</b><b>//</b></pre>
               </td>
            </tr>
            <tr>
               <td width="33%">
                  <b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="IEHPROGMj06"></a></b>List
                  passwords for a dataset
               </td>
            </tr>
            <tr>
               <td width="33%">
                  <pre><b>//IEHPROGM JOB (001),'IEHPROGM-6',CLASS=S,MSGCLASS=X                    
//PROGM    EXEC PGM=IEHPROGM                                            
//SYSPRINT  DD SYSOUT=*                                                 
//DD1       DD UNIT=3380,VOL=SER=MVS380,DISP=OLD                        
//SYSIN     DD  *                                                        
   LIST DSNAME=JAY01.STUDENT.MASTER,PASWORD1=KEY
</b><b>//</b></pre>
               </td>
            </tr>
            <tr>
               <td width="33%">
                  <b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="IEHPROGMj07"></a></b>Rename
                  a member of a Partitioned dataset
               </td>
            </tr>
            <tr>
               <td width="33%">
                  <pre><b>//IEHPROGM JOB (001),'IEHPROGM-7',CLASS=S,MSGCLASS=X                    
//PROGM    EXEC PGM=IEHPROGM                                            
//SYSPRINT  DD SYSOUT=*                                                 
//DD1       DD UNIT=3380,VOL=SER=MVS381,DISP=OLD                        
//SYSIN     DD  *                      
</b><b>   RENAME DSNAME=JAY01.ISAM.COBOL,VOL=3380=MVS381,MEMBER=ISREPT,       C
               NEWNAME=ISREPT1</b><b>
//</b></pre>
               </td>
            </tr>
         </tbody></table>
      </blockquote>
      <p><font size="1">Source:&nbsp; <a href="http://bitsavers.trailing-edge.com/pdf/ibm/370/OS_VS2/Release_3.8_1978/GC26-3902-1_OS_VS2_MVS_Utilities_Rel_3.8_Sep83.pdf" target="_blank">GC26-3902-1 OS/VS2 MVS Utilities Release 3.8</a></font></p>
      <hr size="8" noshade="noshade">
      <h2><a name="LISTPDS"></a>LISTPDS <font size="2">[written by Gene Czarcinski, located in
         SYSC.LINKLIB]</font>
      </h2>
      <p>Used for listing and/or punching source libraries or 
datasets.&nbsp; LISTPDS generates formatted listings of a
         PDS directory, the contents of processed members or sequential 
files, as well as (optionally) punching processed members and/or 
sequential datasets.&nbsp;
         Records may be generated which allow the output to be used in 
conjunction with the IBM utility
         IEBUPDTE.<br>
         <br>
         LISTPDS is located in File #316 of the CBT tape and was 
developed by Gene Czarcinski at the NASA/Goddard Space Flight 
Center.&nbsp;
         LISTPDS requires the following DD statements:
      </p>
      <ul>
         <li>SYSPRINT - defines a sequential output message dataset.</li>
         <li>SYSLIST - defines a sequential output dataset.&nbsp; Will contain the
            listing of the requested datasest.&nbsp; Required when the LIST option is
            used.
         </li>
         <li>SYSPUNCH - defines a sequential output dataset.&nbsp; Required when either
            DECK or UPDTE options are used.
         </li>
         <li>SYSLIB - defines the Partitioned or sequential dataset(s) to be processed.</li>
         <li>SYSIN - defines a sequential input dataset that contains statements used to specify
            individual members to process.&nbsp; Only the first partitioned dataset of
            SYSLIB will be used.&nbsp; When SYSIN is empty, DUMMY, or not included, all
            members of SYSLIB are processed.&nbsp; If the EXCLUDE option is specified,
            all members other than those specified in the SYSIN file will be
            listed.&nbsp; The EXCLUDE/SELECT option is ignored if SYSIN is a null dataset or if the NOSEL option is specified.
         </li>
      </ul>
      <h3>&nbsp;</h3>
      <h3>Program Parameter (PARM= on EXEC statement)</h3>
      <blockquote>
         <p>The execution of LISTPDS and which options are used are entered as keywords
            in the parameter field.&nbsp;
            The keywords, their function and defaults are:
         </p>
         <blockquote>
            <p><a name="LISTPDSlist"></a>LIST | NOLIST</p>
            <ul>
               <li>LIST - Produce a listing of the contents of the datasets in the SYSLIB file on
                  SYSLIST.&nbsp;
                  The DD statement SYSLIST is required.&nbsp; <u>The default is LIST.</u>
               </li>
               <li>NOLIST - Do not produce a listing of datasets and/or members.</li>
            </ul>
            <p><a name="LISTPDSdeck"></a>DECK | NODECK</p>
            <ul>
               <li>DECK - Reproduce card images of the contents of the members in the SYSLIB file on
                  SYSPUNCH.&nbsp;
                  The SYSPUNCH DD statement is required.&nbsp;
               </li>
               <li>NODECK - Do not reproduce card images.&nbsp; <u>The default is NODECK.</u></li>
            </ul>
            <p><a name="LISTPDSlistdir"></a>LISTDIR</p>
            <ul>
               <li>Produces only a listing of the directory entries for 
the members.&nbsp; No record count is given and less I/O time is 
required.&nbsp;
                  <u>The default is no directory listing.</u>
               </li>
            </ul>
            <p><a name="LISTPDSupdte"></a>UPDTE | NOUPDTE</p>
            <ul>
               <li>UPDTE - IEBUPDTE utility ADD statements will be produced on SYSPUNCH.&nbsp;
                  When DECK is also specified they will precede each member.&nbsp; If a
                  member contains IEBUPDTE statements, the './' statements within the member
                  will be written with '&gt;&lt;' in place of the './' characters.&nbsp; The SYSPUNCH DD statement is required.
               </li>
               <li>NOUPDTE - IEBUPDTE utility ADD statements will not be produced.&nbsp; <u>The default is
                  NOUPDTE.</u>
               </li>
            </ul>
            <p><a name="LISTPDSssi"></a>SSI | NOSSI</p>
            <ul>
               <li>SSI - The system status information is included on the IEBUPDTE ADD statements.</li>
               <li>NOSSI - The system status information is not placed on the IEBUPDTE ADD statements.&nbsp;
                  <u>The default is NOSSI.</u>
               </li>
            </ul>
            <p><a name="LISTPDSspf"></a>SPF | NOSPF</p>
            <ul>
               <li>SPF - If ISPF statistics exist, they are included on the IEBUPDTE ADD
                  statements.&nbsp; <u>The default is SPF.</u>
               </li>
               <li>NOSPF&nbsp; - ISPF statistics are not included on the IEBUPDTE ADD
                  statements.
               </li>
            </ul>
            <p><a name="LISTPDStrunc"></a>TRUNC | NOTRUNC</p>
            <ul>
               <li>TRUNC - For partitioned datasets with records longer than 100 bytes, only the first 100 bytes are listed on
                  SYSLIST.&nbsp; <u>The default is TRUNC.</u>
               </li>
               <li>NOTRUNC - For partitioned datasets with records longer than 100 bytes, the entire record is
                  listed on SYSLIST.&nbsp; This will require more than on line per record
                  listed.
               </li>
            </ul>
            <p><a name="LISTPDSlinecnt"></a>LINECNT=nn</p>
            <ul>
               <li>The number of lines printed per page for SYSPRINT and SYSLIST is specified by
                  nn.&nbsp;
                  <u>The default value is 60.</u>&nbsp; This should be changed  to 58 for devices which allow a maximum of 66 lines per page, such as a XEROX 1200 printer.
               </li>
            </ul>
            <p><a name="LISTPDSrits"></a>RITS | CRBE | CRJE</p>
            <ul>
               <li>Used to inform LISTPDS special processing is required due to 88-byte logical records.&nbsp;
                  <u>The default is to treat Partitioned datasets as not being either a RITS,
                  CRBE or CRJE library.</u>
               </li>
            </ul>
            <p><a name="LISTPDShexout"></a>HEXOUT | NOHEXOUT</p>
            <ul>
               <li>HEXOUT - Prints the records on SYSLIST in hexadecimal format.&nbsp; This is useful for non-source members.&nbsp;
                  The default is NOHEXOUT.
               </li>
               <li>NOHEXOUT - Prints the records on SYSLIST as they exist; unprintable
                  characters (not in the 64 character set) will be printed as blanks.&nbsp; <u>The default is
                  NOHEXOUT.</u>
               </li>
            </ul>
            <p><a name="LISTPDSnum"></a>NUM | NONUM</p>
            <ul>
               <li>NUM - Prints the record number on the left margin 
followed by a space and then the remainder of the record image.&nbsp;
                  Datasets with record format F, FB, or U are assumed to
 have the record number in the last 8
                  bytes of each record.&nbsp; Datasets with record 
format V or VB, are assumed to have the record number in the first 8 
bytes
                  of each record.&nbsp; This applies to both partitioned
 and sequential organization datasets.
               </li>
               <li>NONUM&nbsp; - Prints each record as they exist.&nbsp; <u>The default for this option is
                  NONUM.</u>
               </li>
            </ul>
            <p><a name="LISTPDSxlate"></a>XLATE | TEXT | NOXLATE | NOTEXT</p>
            <ul>
               <li>XLATE and TEXT - Lower case characters are translated to upper case
                  before printing.&nbsp; <u>The default is TEXT.</u>
               </li>
               <li>NOXLATE and NOTEXT - Records are printed as they exist.</li>
            </ul>
            <p><a name="LISTPDSeject"></a>EJECT | NOEJECT</p>
            <ul>
               <li>EJECT - Each member begins on a new page.&nbsp; <u>The default is EJECT.</u></li>
               <li>NOEJECT - Triple spacing is used to separate members.</li>
            </ul>
            <p><a name="LISTPDSselect"></a>SELECT | NOSEL | EXCLUDE</p>
            <ul>
               <li>SELECT - Only the member names specified in SYSIN will be
                  processed.&nbsp; If a SYSIN DD is supplied, this option is assumed to be in effect,
                  unless NOSEL is specified.
               </li>
               <li>NOSEL - All members are processed.</li>
               <li>EXCLUDE - The member names specified in SYSIN file will NOT be printed if this option is specified.&nbsp;
                  All other members will be printed.
               </li>
            </ul>
            <p><a name="LISTPDSeropt"></a>EROPT={TERM | ACC}</p>
            <ul>
               <li>TERM - Processing will be terminated if an I/O error occurs while reading
                  SYSLIB.&nbsp;
               </li>
               <li>ACC - Processing will continue after an I/O error is encountered while reading
                  SYSLIB.&nbsp;
                  The bad records are ignored.&nbsp; <u>The default is EROPT=ACC.</u>
               </li>
            </ul>
            <p>MAXLIST=nn</p>
            <ul>
               <li>  The number specified will limit printing on SYSLIST to the first nn lines of each member.&nbsp;
                  <u>The default is print all records for each member.</u>
               </li>
            </ul>
         </blockquote>
      </blockquote>
      <p>&nbsp;</p>
      <h3>Control Statements</h3>
      <blockquote>
         <p>There are no control statements.&nbsp; If specific members of a
            partitioned dataset are to be selected or excluded, their names are included
            in SYSIN.&nbsp; The names specified are separated by commas.&nbsp; As many
            statements as are required may be included in a single execution.
         </p>
      </blockquote>
      <h3>&nbsp;</h3>
      <h3>Examples</h3>
      <blockquote>
         <table width="75%" cellspacing="1" border="1">
            <tbody><tr>
               <td width="33%">
                  <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="LISTPDSj01"></a>Print
                     the directory of a partitioned dataset
               </p></td>
            </tr>
            <tr>
               <td width="33%">
                  <pre><b>//LISTPDS  JOB (1),'LISTPDS-1',CLASS=A,MSGCLASS=X   
//LISTPDS  EXEC PGM=LISTPDS,PARM='NOLIST'           
//SYSPRINT  DD  SYSOUT=*                            
//SYSLIST   DD  SYSOUT=*                            
//SYSLIB    DD  DISP=SHR,DSN=SYSC.PROCLIB           
//SYSPUNCH  DD  SYSOUT=B                            
//                                                  </b><b>                                                      </b></pre>
               </td>
            </tr>
            <tr>
               <td width="33%">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="LISTPDSj02"></a>Print
                  all members of a partitioned dataset
               </td>
            </tr>
            <tr>
               <td width="33%">
                  <pre><b>//LISTPDS  JOB (1),'LISTPDS-2',CLASS=A,MSGCLASS=X  
//LISTPDS  EXEC PGM=LISTPDS,PARM='LIST'            
//SYSPRINT  DD  SYSOUT=*                           
//SYSLIST   DD  SYSOUT=*                           
//SYSLIB    DD  DISP=SHR,DSN=SYSC.PROCLIB          
//SYSPUNCH  DD  SYSOUT=B                           </b><b>
// </b></pre>
               </td>
            </tr>
            <tr>
               <td width="33%">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="LISTPDSj03"></a>Punch
                  selected members of a partitioned dataset
               </td>
            </tr>
            <tr>
               <td width="33%">
                  <pre><b>//LISTPDS  JOB (1),'LISTPDS-3',CLASS=A,MSGCLASS=X   
//LISTPDS  EXEC PGM=LISTPDS,PARM='NOLIST,DECK'      
//SYSPRINT  DD  SYSOUT=*                            
//SYSLIST   DD  SYSOUT=*                            
//SYSLIB    DD  DISP=SHR,DSN=SYSC.PROCLIB           
//SYSPUNCH  DD  SYSOUT=B                            
//SYSIN     DD  *                                   
ASMGC,ASMGCL,ASMGCLG                                
COBUC,COBUCG,COBUCL,COBUCLG
//                                                  </b></pre>
               </td>
            </tr>
            <tr>
               <td width="33%">
                  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="LISTPDSj04"></a>Punch
                  selected members of a partitioned dataset with IEBUPDTE cards
               </td>
            </tr>
            <tr>
               <td width="33%">
                  <pre><b>//LISTPDS  JOB (1),'LISTPDS-4',CLASS=A,MSGCLASS=X        
//LISTPDS  EXEC PGM=LISTPDS,PARM='NOLIST,DECK,UPDTE,SPF' 
//SYSPRINT  DD  SYSOUT=*                                 
//SYSLIST   DD  SYSOUT=*                                 
//SYSLIB    DD  DISP=SHR,DSN=JAY01.ISAM.COBOL            
//SYSPUNCH  DD  SYSOUT=B                                 
//SYSIN     DD  *                                        
ISREPT1,ISREPT2                                          
//                                                       </b></pre>
               </td>
            </tr>
            <tr>
               <td width="33%">
                  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="LISTPDSj05"></a>Punch
                  and print sequential dataset
               </td>
            </tr>
            <tr>
               <td width="33%">
                  <pre><b>//LISTPDS  JOB (1),'LISTPDS-5',CLASS=A,MSGCLASS=X     
//LISTPDS  EXEC PGM=LISTPDS,PARM='LIST,DECK'          
//SYSPRINT  DD  SYSOUT=*                              
//SYSLIST   DD  SYSOUT=*                              
//SYSLIB    DD  DISP=SHR,DSN=JAY01.CBLPATCH.ZAPS      
//SYSPUNCH  DD  SYSOUT=B                              
//                                                    </b></pre>
               </td>
            </tr>
         </tbody></table>
      </blockquote>
      <hr size="8" noshade="noshade">
      <h2><a name="MINIUNZ"></a>MINIUNZ <font size="2">[distributed by Greg
      Price, located in SYSC.LINKLIB]</font>
      </h2>
      <p>Used for uncompressing the contents of datasets created by compression
      utilities commonly used on PCs and by the companion program MINIZIP.&nbsp;
      </p>
      <p>MINIUNZ was written in the C-language and has been ported to MVS using
      the compiler JCC, from Jason Winter, which produces Assembler language
      output and requires no runtime libraries.&nbsp; This version is from File
      #135 of the CBT tape (version 502, 11/2021).
      </p>
      <p>MINIUNZ
         requires the following DD statements:
      </p>
      <ul>
         <li>STDOUT - defines a sequential output message dataset.</li>
         <li>inputDD - defines the sequential input dataset containing the
          compressed data records.</li>
         <li>outputDD - defines the output partitioned or sequential dataset
          that will contain the extracted data records.</li>
      </ul>
      <h3>&nbsp;</h3>
      <h3>Program Parameter (PARM= on EXEC statement)</h3>
      <blockquote>
         <p>The parameter field is used to specify DD names to use for the
         extraction and may also be used to specify what data is to be extracted
         from the compressed archive.&nbsp; The format of the parameter field
         is:
         </p>
         <blockquote>
         <p>[{-L | -V}] inputDD outputDD [name]
         </p>
         </blockquote>
         <p>The values and their function are:</p>
         <blockquote>
          <p>[{-L | -V}]</p>
          <blockquote>
            <p>If one of these options is specified, a list of the archive contents is
            produced, but no datasets are extracted.&nbsp; The inputDD is required,
            but the outputDD may point to a DUMMY DD statement.&nbsp; Both
            options will list the contents of the archive, -V will also include
            the comment that is added when an archive is created under MVS, by
            the program MINIZIP; the
            comment indicates whether the data was stored as EBCDIC or converted
            to ASCII, plus the RECFM and LRECL of the data records.</p>
          </blockquote>
          <p>inputDD</p>
          <blockquote>
            <p>Specifies the name of the DD statement to be used to read the compressed archive.</p>
          </blockquote>
          <p>outputDD</p>
          <blockquote>
            <p>Specifies the name of the DD statement to be used to write the extracted records.&nbsp;
            If the -L or -V option is used, this DD may be specified as
            DUMMY.&nbsp; If the [name] parameter is omitted, the DD must specify a
            partitioned dataset, into which all members of the archive are
            extracted.&nbsp; If the [name] parameter is specified, the DD must specify a
            sequential dataset, into which only the single member is extracted.</p>
          </blockquote>
          <p>[name]</p>
          <blockquote>
            <p>Specifies the single member to be extracted from the archive.</p>
          </blockquote>
         </blockquote>
      </blockquote>
      <p>&nbsp;</p>
      <h3>Control Statements</h3>
      <blockquote>
         <p>There are no control statements for MINIUNZ.
         </p>
      </blockquote>
      <p>&nbsp;</p>
      <h3>Examples</h3>
      <blockquote>
         <table width="75%" cellspacing="1" border="1">
            <tbody><tr>
               <td width="33%">
                  <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="MINIUNZj01"></a>List
                  contents of archive
               </p></td>
            </tr>
            <tr>
               <td>
                  <pre><b>//UNZIP    JOB 1,'MINI UNZIP 1',CLASS=A,MSGCLASS=X   
//MINIUNZ EXEC PGM=MINIUNZ,REGION=7M,              
//             PARM='-L ZIPFILE PDSOUT'            
//STDOUT    DD SYSOUT=*                            
//ZIPFILE   DD DISP=SHR,DSN=JAY01.ISAMCOB.ZIP      
//PDSOUT    DD DUMMY                               
//                                                  </b></pre>
               </td>
            </tr>
            <tr>
               <td width="33%">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="MINIUNZj02"></a>Extract
                entire contents of archive to a partitioned dataset
               </td>
            </tr>
            <tr>
               <td width="33%">
                  <pre><b>//UNZIP    JOB 1,'MINI UNZIP 2',CLASS=A,MSGCLASS=X             
//MINIUNZ EXEC PGM=MINIUNZ,REGION=7M,                        
//             PARM='ZIPFILE PDSOUT'                         
//STDOUT    DD SYSOUT=*                                      
//ZIPFILE   DD DISP=SHR,DSN=JAY01.ISAMCOB.ZIP                
//PDSOUT    DD DISP=(,CATLG,DELETE),DSN=JAY01.ISAMCO.UNZIP2, 
//             UNIT=SYSDA,VOL=SER=MVS381,                    
//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=23440),        
//             SPACE=(CYL,(10,1,50),RLSE)                    
//                                                  </b></pre>
               </td>
            </tr>
            <tr>
               <td width="33%">
                  <b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="MINIUNZj03"></a></b>Extract
                  a single member from an archive to a sequential dataset
               </td>
            </tr>
            <tr>
               <td width="33%">
                  <pre><b>//UNZIP    JOB 1,'MINI UNZIP 3',CLASS=A,MSGCLASS=X                     
//MINIUNZ EXEC PGM=MINIUNZ,REGION=7M,                                
//             PARM='ZIPFILE SEQOUT SORTNAME'                        
//STDOUT    DD SYSOUT=*                                              
//ZIPFILE   DD DISP=SHR,DSN=JAY01.ISAMCOB.ZIP                        
//SEQOUT    DD DISP=(,CATLG,DELETE),DSN=JAY01.ISAMCO.SORTNAME.COBOL, 
//             UNIT=SYSDA,VOL=SER=MVS381,                            
//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=23440),                
//             SPACE=(CYL,(10,1),RLSE)                               </b><b>
//                                                 </b></pre>
               </td>
            </tr>
         </tbody></table>
      </blockquote>
      <hr size="8" noshade="noshade">
      <h2><a name="MINIZIP"></a>MINIZIP <font size="2">[distributed by Greg
      Price, located in SYSC.LINKLIB]</font>
      </h2>
      <p>Used for compressing the contents of:&nbsp; 1) one or more sequential
      datasets or members of partitioned datasets; or 2) all the members of a
      one or more partitioned datasets, to create a smaller, portable copy of
      the original data.&nbsp; Datasets created by MINIZIP may be processed by
      compression utilities commonly used on PCs and by the companion program
      MINIUNZ to reconstruct the original datasets.&nbsp;
      </p>
      <p><b>Note:&nbsp;</b> Datasets created by MINIZIP may be viewed with
      REVIEW's Browse function, which will expand the compressed output an
      present it in a viewable format.
      </p>
      <p>MINIZIP was written in the C-language and has been ported to MVS using
      the compiler JCC, from Jason Winter, which produces Assembler language
      output and requires no runtime libraries.&nbsp; This version is from File
      #135 of the CBT tape (version 502, 11/2021).
      </p>
      <p>MINIZIP
         requires the following DD statements:
      </p>
      <ul>
         <li>STDOUT - defines a sequential output message dataset.</li>
         <li>SYSUT1 - defines a work dataset.</li>
         <li>inputDD - defines the partitioned or sequential input dataset
          containing the data records to be compressed.</li>
         <li>outputDD - defines the sequential output dataset that will contain
          the compressed data records.</li>
      </ul>
      <h3>&nbsp;</h3>
      <h3>Program Parameter (PARM= on EXEC statement)</h3>
      <blockquote>
         <p>The parameter field is used to specify DD names to use for the
         compression.&nbsp; The format of the parameter field is:
         </p>
        <blockquote>
         <p>[-O] outputDD inputDD[ inputDD...]
         </p>
        </blockquote>
      </blockquote>
      <p>The values and their function are:</p>
      <blockquote>
        <p>[-O]</p>
        <blockquote>
          <p>Specifies that all inputDD statements refer to partitioned datasets
          and all members of each dataset are to be added to the archive.</p>
        </blockquote>
        <p>outputDD</p>
        <blockquote>
          <p>Specifies the name of the DD statement to be used to write the compressed archive.</p>
        </blockquote>
        <p>inputDD[ inputDD...]</p>
        <blockquote>
          <p>Specifies the names of one or more DD statements from which data records are to be
          read and placed into the archive.</p>
        </blockquote>
      </blockquote>
      <p>&nbsp;</p>
      <h3>Control Statements</h3>
      <blockquote>
         <p>There are no control statements for MINIZIP.
         </p>
      </blockquote>
      <p>&nbsp;</p>
      <h3>Examples</h3>
      <blockquote>
         <table width="75%" cellspacing="1" border="1">
            <tbody><tr>
               <td width="33%">
                  <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="MINIZIPj01"></a>Compress
                  all members of a partitioned dataset to archive
               </p></td>
            </tr>
            <tr>
               <td>
                  <pre><b>//ZIP      JOB 1,'MINI ZIP 1',CLASS=A,MSGCLASS=X                
//MINIZIP EXEC PGM=MINIZIP,REGION=7M,                         
//             PARM='-o ZIPFILE PDSIN'                        
//STDOUT    DD SYSOUT=*                                       
//SYSUT1    DD UNIT=SYSDA,SPACE=(CYL,(30,30)),                
//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=3120)           
//ZIPFILE   DD DISP=(NEW,CATLG,DELETE),DSN=JAY01.ISAMCOB.ZIP, 
//             UNIT=SYSDA,VOL=SER=MVS381,                     
//             SPACE=(TRK,(60,15),RLSE),                      
//             DCB=(DSORG=PS,RECFM=FB,LRECL=80,BLKSIZE=27920) 
//PDSIN     DD DISP=SHR,DSN=JAY01.ISAM.COBOL                  </b><b>
//                                                  </b></pre>
               </td>
            </tr>
            <tr>
               <td width="33%">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="MINIZIPj02"></a>Compress
                all members of three partitioned datasets to archive
               </td>
            </tr>
            <tr>
               <td width="33%">
                  <pre><b>//ZIP      JOB 1,'MINI ZIP 2',CLASS=A,MSGCLASS=X               
//MINIZIP EXEC PGM=MINIZIP,REGION=7M,                        
//             PARM='-o ZIPFILE PDSIN1 PDSIN2 PDSIN3'        
//STDOUT    DD SYSOUT=*                                      
//SYSUT1    DD UNIT=SYSDA,SPACE=(CYL,(30,30)),               
//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=3120)          
//ZIPFILE   DD DISP=(NEW,CATLG,DELETE),DSN=JAY01.BASE.ZIP,   
//             UNIT=SYSDA,VOL=SER=MVS381,                    
//             SPACE=(TRK,(60,15),RLSE),                     
//             DCB=(DSORG=PS,RECFM=FB,LRECL=80,BLKSIZE=27920)
//PDSIN1    DD DISP=SHR,DSN=JAY01.CLIST                      
//PDSIN2    DD DISP=SHR,DSN=JAY01.CNTL                       
//PDSIN3    DD DISP=SHR,DSN=JAY01.EXEC                       </b><b>
//                                                  </b></pre>
               </td>
            </tr>
            <tr>
               <td width="33%">
                  <b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="MINIZIPj03"></a></b>Compress
                  three sequential datasets to archive
               </td>
            </tr>
            <tr>
               <td width="33%">
                  <pre><b>//ZIP      JOB 1,'MINI ZIP 3',CLASS=A,MSGCLASS=X                   
//MINIZIP EXEC PGM=MINIZIP,REGION=7M,                            
//             PARM='ZIPFILE SEQIN1 SEQIN2 SEQIN3'               
//STDOUT    DD SYSOUT=*                                          
//SYSUT1    DD UNIT=SYSDA,SPACE=(CYL,(30,30)),                   
//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=3120)              
//ZIPFILE   DD DISP=(NEW,CATLG,DELETE),DSN=JAY01.IERAM1.ZIP,     
//             UNIT=SYSDA,VOL=SER=MVS381,                        
//             SPACE=(TRK,(60,15),RLSE),                         
//             DCB=(DSORG=PS,RECFM=FB,LRECL=80,BLKSIZE=27920)    
//SEQIN1    DD DISP=SHR,DSN=SYSP.MVT.IERAM1.CNTL                 
//SEQIN2    DD DISP=SHR,DSN=SYSP.MVT.IERAM1.OBJECT               
//SEQIN3    DD DISP=SHR,DSN=SYSP.MVT.IERCMZ.CNTL                 </b><b>
//                                                 </b></pre>
               </td>
            </tr>
            <tr>
               <td width="33%">
                  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="MINIZIPj04"></a>Compress
                  four members of a partitioned dataset to archive
               </td>
            </tr>
            <tr>
               <td width="33%">
                  <pre><b>//ZIP      JOB 1,'MINI ZIP 4',CLASS=A,MSGCLASS=X                   
//MINIZIP EXEC PGM=MINIZIP,REGION=7M,                            
//             PARM='ZIPFILE PDSIN1 PDSIN2 PDSIN3 PDSIN4'        
//STDOUT    DD SYSOUT=*                                          
//SYSUT1    DD UNIT=SYSDA,SPACE=(CYL,(30,30)),                   
//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=3120)              
//ZIPFILE   DD DISP=(NEW,CATLG,DELETE),DSN=JAY01.RESTORE.ZIP,    
//             UNIT=SYSDA,VOL=SER=MVS381,                        
//             SPACE=(TRK,(60,15),RLSE),                         
//             DCB=(DSORG=PS,RECFM=FB,LRECL=80,BLKSIZE=27920)    
//PDSIN1    DD DISP=SHR,DSN=SYSP.RESTORE.LOCAL.CNTL(UCSYSP01)    
//PDSIN2    DD DISP=SHR,DSN=SYSP.RESTORE.LOCAL.CNTL(ADDUSERS)    
//PDSIN3    DD DISP=SHR,DSN=SYSP.RESTORE.LOCAL.CNTL(S3LLIB)      
//PDSIN4    DD DISP=SHR,DSN=SYSP.RESTORE.LOCAL.CNTL(RESTORE)     
//                                             </b></pre>
               </td>
            </tr>
         </tbody></table>
      </blockquote>
      <hr size="8" noshade="noshade">
      <h2><a name="OFFLOAD"></a>OFFLOAD <font size="2">[written by David B. Cole, located in
      SYSC.LINKLIB]</font>
      </h2>
      <p>Used for sequentializing a partitioned dataset.&nbsp; Either all or a
         specified subset of the members of a partitioned dataset are used to create a
         sequential dataset; each member is preceded by an ADD control statement.&nbsp;
         The resulting file may then be input to PDSLOAD to construct a new partitioned
         dataset containing the offloaded members.&nbsp; This is a batch implementation
         of the Offload function provided in Greg Price's REVIEW.
      </p>
      <p>The most recent version of OFFLOAD is located in File #093 of the CBT
         tape.&nbsp; The program was originally written by David B. Cole.&nbsp; OFFLOAD
         requires the following DD statements:
      </p>
      <ul>
         <li>SYSPRINT - defines a sequential output message dataset.</li>
         <li>SYSIN - defines a sequential input dataset that contains control statements.</li>
         <li>anyname1 - defines the input partitioned dataset.</li>
         <li>anyname2 - defines the output sequential dataset.</li>
      </ul>
      <h3><b><font color="#0000FF">I would also suggest taking a look at UNUPDTE.</font></b></h3>
      <p>&nbsp;</p>
      <h3>Control Statements</h3>
      <blockquote>
         <p>The control statements are modeled after the control statements for the
            IEBCOPY utility program.&nbsp; There are three control statements; the control
            statement function, as well as all of the operands, may
            identified by the minimal possible abbreviation, one character:&nbsp; O for
            Offload, S for Select and E for Exclude.&nbsp;&nbsp;
         </p>
         <p> The Offload control statement has
            three sub-operands:&nbsp; I for Input
            ddname, O for Output ddname, and T for Type.&nbsp;&nbsp;
         </p>
         <p> Both the Select and Exclude
            control statements each have a single sub-operand:&nbsp; M for Member.&nbsp;
         </p>
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="5%">
                  <pre><a name="OFFLOADoffload"></a>O</pre>
               </td>
               <td width="95%">
                  <pre>I=ddname</pre>
               </td>
            </tr>
            <tr>
               <td width="5%">
                  <pre></pre>
               </td>
               <td width="95%">
                  <pre>,O=ddname</pre>
               </td>
            </tr>
            <tr>
               <td width="5%">
                  <pre></pre>
               </td>
               <td width="95%">
                  <pre>,T={IEBUPDTE | IEBUPDAT}</pre>
               </td>
            </tr>
         </tbody></table>
         <p>The Offload control statement specifies the input and output DD names and the type of ADD control
            statement to insert ahead of each members data records.&nbsp; The operands
            are:
         </p>
         <blockquote>
            <p>I=ddname</p>
            <blockquote>
               <p>Specifies the DD name from which the partitioned dataset is read.</p>
            </blockquote>
            <p>O=ddname</p>
            <blockquote>
               <p>Specifies the DD name to which the sequential dataset is written.</p>
            </blockquote>
            <p>T={IEBUPDTE | IEBUPDAT}</p>
            <blockquote>
               <p>Specifies that an ADD control statement is to be written preceding each
                  members data records.&nbsp; If this sub-operand is omitted, no ADD statement
                  will be written.&nbsp; The values that may be specified for T are:
               </p>
               <ul>
                  <li>IEBUPDTE - Specifies the ADD control statements are to be in IEBUPDTE format.</li>
                  <li>IEBUPDAT - Specifies the ADD control statements are to be in IEBUPDAT format.</li>
               </ul>
            </blockquote>
         </blockquote>
         <hr color="#808080">
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="5%">
                  <pre><a name="OFFLOADselect"></a>S</pre>
               </td>
               <td width="95%">
                  <pre>M={membername | (membername1[,membername2]...)}</pre>
               </td>
            </tr>
         </tbody></table>
         <p>The Select control statement specifies that only these named members are to be processed - Selected -
            from the partitioned dataset.&nbsp; As many Select control statements may be
            used as necessary; subsequent control statements are processed as a
            continuation of the initial control statement.
         </p>
         <blockquote>
            <p>M={membername | (membername1[,membername2]...)}</p>
            <blockquote>
               <p>Specifies one or a list of names of members to be processed.&nbsp; If
                  only a single member name is used, it need not be enclosed in parentheses.
               </p>
            </blockquote>
         </blockquote>
         <hr color="#808080">
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="5%">
                  <pre><a name="OFFLOADexclude"></a>E</pre>
               </td>
               <td width="95%">
                  <pre>M={membername | (membername1[,membername2]...)}</pre>
               </td>
            </tr>
         </tbody></table>
         <p>The Exclude control statement specifies that these named members are not to be processed - Excluded - and
            all other members are processed from the partitioned dataset.&nbsp; As many
            Exclude control statements may be used as necessary; subsequent control
            statements are processed as a continuation of the initial control statement.
         </p>
         <blockquote>
            <blockquote>
               <p>M={membername | (membername1[,membername2]...)}</p>
               <blockquote>
                  <p>Specifies one or a list of names of members to be excluded.&nbsp; If
                     only a single member name is used, it need not be enclosed in
                     parentheses.
                  </p>
               </blockquote>
            </blockquote>
         </blockquote>
         <p>If no Select or Exclude control statements are provided, all members of the
            partitioned dataset are processed.
         </p>
         <p>The Select and Exclude control statements are mutually exclusive; only one
            may be used in a single execution of OFFLOAD.
         </p>
      </blockquote>
      <h3>&nbsp;</h3>
      <h3>Examples</h3>
      <blockquote>
         <table width="75%" cellspacing="1" border="1">
            <tbody><tr>
               <td width="33%">
                  <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="OFFLOADj01"></a>Offload
                     selected members of a partitioned dataset
               </p></td>
            </tr>
            <tr>
               <td>
                  <pre><b>//OFFLOAD  JOB (01),'OFFLOAD PO',CLASS=S,MSGCLASS=X               
//OFFLOAD EXEC PGM=OFFLOAD                                        
//SYSPRINT DD  SYSOUT=*                                           
//SYSUT1   DD  DISP=SHR,DSN=SYSC.VSAMIOP.SOURCE                   
//SYSUT2   DD  DISP=(,CATLG,DELETE),DSN=JAY01.VSAMIOP.OFFLOAD,    
//             UNIT=SYSDA,SPACE=(CYL,(5,2),RLSE),VOL=SER=PUB001,  
//             DCB=(DSORG=PS,RECFM=FB,LRECL=80,BLKSIZE=3120)      
//SYSIN    DD  *                                                  
  O I=SYSUT1,O=SYSUT2,T=IEBUPDTE                                  
  S M=(ESDSADDT,ESDSLOAD,ESDSREAD,ESDSUPDT,KSDSLOAD,KSDSRAND)     
  S M=(KSDSREAD,KSDSSSEQ,KSDSUPDT,RRDSLODR,RRDSLODS,RRDSRAND)     
  S M=(RRDSREAD,RRDSSSEQ,RRDSUPDT)                                
/*                                                                
//                                                                </b></pre>
               </td>
            </tr>
            <tr>
               <td width="33%">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="OFFLOADj02"></a>Offload
                  all but excluded member of a partitioned dataset
               </td>
            </tr>
            <tr>
               <td width="33%">
                  <pre><b>//OFFLOAD  JOB (01),'OFFLOAD PO',CLASS=S,MSGCLASS=X               
//OFFLOAD EXEC PGM=OFFLOAD                                        
//SYSPRINT DD  SYSOUT=*                                           
//SYSUT1   DD  DISP=SHR,DSN=SYSC.VSAMIOP.SOURCE                   
//SYSUT2   DD  DISP=(,CATLG,DELETE),DSN=JAY01.VSAMIOP.OFFLOAD,    
//             UNIT=SYSDA,SPACE=(CYL,(5,2),RLSE),VOL=SER=PUB001,  
//             DCB=(DSORG=PS,RECFM=FB,LRECL=80,BLKSIZE=3120)      
//SYSIN    DD  *                                                  
  O I=SYSUT1,O=SYSUT2,T=IEBUPDTE                                  
  E M=$INDEX
/*                                                                
//                                                                </b></pre>
               </td>
            </tr>
            <tr>
               <td width="33%">
                  <b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="OFFLOADj03"></a></b>Offload
                  all members of a partitioned dataset
               </td>
            </tr>
            <tr>
               <td width="33%">
                  <pre><b>//OFFLOAD  JOB (01),'OFFLOAD PO',CLASS=S,MSGCLASS=X               
//OFFLOAD EXEC PGM=OFFLOAD                                        
//SYSPRINT DD  SYSOUT=*                                           
//SYSUT1   DD  DISP=SHR,DSN=JAY01.ISAM.COBOL 
//SYSUT2   DD  DISP=(,CATLG,DELETE),DSN=JAY01.ISAMCOB.OFFLOAD,    
//             UNIT=SYSDA,SPACE=(CYL,(5,2),RLSE),VOL=SER=PUB001,  
//             DCB=(DSORG=PS,RECFM=FB,LRECL=80,BLKSIZE=3120)      
//SYSIN    DD  *                                                  
  O I=SYSUT1,O=SYSUT2,T=IEBUPDTE                                  
/*                                                                
//</b></pre>
               </td>
            </tr>
         </tbody></table>
      </blockquote>
      <hr size="8" noshade="noshade">
      <h2><a name="PDSLOAD"></a>PDSLOAD <font size="2">[written by Bill Godfrey, located in
         SYSC.LINKLIB]</font>
      </h2>
      <p>Used for recreating a partitioned dataset from a sequential dataset
      that contains control statements interspersed with data records.
      </p>
      <p>The most recent version of PDSLOAD is located in File #093 of the CBT
         tape.&nbsp; The program was originally written by Bill Godfrey.&nbsp; PDSLOAD
         requires the following DD statements:
      </p>
      <ul>
         <li>SYSPRINT - defines a sequential output message dataset.</li>
         <li>SYSIN - defines a sequential input dataset that contains control statements and
            data when PARM=NEW.
         </li>
         <li>SYSUT1 - defines the input sequential dataset.</li>
         <li>SYSUT2 - defines the output partitioned dataset.</li>
      </ul>
      <h3><b><font color="#0000FF">I would also suggest taking a look at UPDTE.</font></b></h3>
      <p>&nbsp;</p>
      <h3>Program Parameter (PARM= on EXEC statement)</h3>
      <blockquote>
         <p>The operation of PDSLOAD is controlled by options which are entered as keywords
            in the parameter field.&nbsp;
            The keywords and their function are:
         </p>
         <blockquote>
            <p><a name="PDSLOADnew"></a>NEW</p>
            <blockquote>
               <p>If specified, SYSUT1 is not opened and SYSIN is assumed to specify the
                  input file.&nbsp; NEW must be the first or only option in the PARM field.
               </p>
            </blockquote>
            <p><a name="PDSLOADspf"></a>SPF</p>
            <blockquote>
               <p>Specifies that SPF statistics are to be generated for the members of
                  the partitioned dataset.
               </p>
            </blockquote>
            <p><a name="PDSLOADs"></a>S(namemask)</p>
            <blockquote>
               <p>Specifies that only the members matching namemask will be written to
                  the partitioned dataset.&nbsp; In namemask, the characters '*', '%', and
                  '?' are treated the same and match any character.
               </p>
            </blockquote>
            <p><a name="PDSLOADupdte"></a>UPDTE(xx)</p>
            <blockquote>
               <p>Specifies that all occurrences of the two characters in parentheses, if
                  found in columns 1-2 of the data records within the members, will be
                  changed to './' before being written to the partitioned dataset.&nbsp;
                  This is used in conjunction with OFFLOAD, which changes all occurrences of
                  './' in columns 1-2 of the data records within the members to another
                  constant so that IEBUPDTE and this program will not treat the data records
                  as control statements.&nbsp; IEBUPDTE does not change the data back, but
                  PDSLOAD does.
               </p>
            </blockquote>
            <p><a name="PDSLOADctl"></a>CTL(xx)</p>
            <blockquote>
               <p>Specifies that all occurrences of the two characters in parentheses
                  will be used to search for the ADD and ALIAS control statements.
               </p>
            </blockquote>
            <p><a name="PDSLOADname"></a>NAME={CHK | ASIS | IBM}</p>
            <blockquote>
               <p>Specifies validation of member names.&nbsp; The values that may be
                  coded are:
               </p>
               <ul>
                  <li>CHK - Allows all printable characters, except comma, using CODEPAGE 037.</li>
                  <li>ASIS - Bypass all checks.&nbsp; The default is ASIS.</li>
                  <li>IBM - Enforce strict IBM JCL standards. 'JCL' is a synonym for IBM.</li>
               </ul>
            </blockquote>
            <p><a name="PDSLOADck3"></a>CK3</p>
            <blockquote>
               <p>When UPDTE(xx) is specified, verifies that column three is blank before
                  changing the specified characters to './'.
               </p>
            </blockquote>
         </blockquote>
         <p>If SPF is specified, it must be the first parameter, unless NEW is specified,
            then it must be the second parameter..
         </p>
         <p>If UPDTE(&gt;&lt;) is specified, it must be the last parameter.</p>
         <p>&nbsp;</p>
      </blockquote>
      <h3>Control Statements</h3>
      <blockquote>
         <p>There are no control statements.&nbsp; If specific members of a
            partitioned dataset are to be selected or excluded, their names are included
            in SYSIN.&nbsp; The names specified are separated by commas.&nbsp; As many
            statements as are required may be included in a single execution.
         </p>
      </blockquote>
      <h3>&nbsp;</h3>
      <h3>Examples</h3>
      <blockquote>
         <table width="75%" cellspacing="1" border="1">
            <tbody><tr>
               <td width="33%">
                  <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="PDSLOADj01"></a>Load
                     partitioned dataset from OFFLOADed dataset
               </p></td>
            </tr>
            <tr>
               <td>
                  <pre><b>//PDSLOAD  JOB (SYS),'PDSLOAD-1',CLASS=A,MSGCLASS=X             
//PDSLOAD EXEC PGM=PDSLOAD,PARM='NEW,SPF'                       
//SYSPRINT DD  SYSOUT=*                                         
//SYSIN    DD  DISP=SHR,DSN=HMVS01.VSAMIO.OFFLOAD,               
//SYSUT2   DD  DISP=(,CATLG,DELETE),DSN=HMVS02.VSAMIO.SOURCE     
//             DCB=(DSORG=PO,RECFM=FB,LRECL=80,BLKSIZE=23440),  
//             UNIT=SYSDA,VOL=SER=MVS381,                       
//             SPACE=(CYL,(2,1,15),RLSE)                        
//                                                                                                                              </b></pre>
               </td>
            </tr>
            <tr>
               <td width="33%">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="PDSLOADj02"></a>Load
                  partitioned dataset using mask to select members
               </td>
            </tr>
            <tr>
               <td width="33%">
                  <pre><b>//PDSLOAD  JOB (SYS),'PDSLOAD-2',CLASS=A,MSGCLASS=X           
//PDSLOAD EXEC PGM=PDSLOAD,PARM='NEW,SPF,S(%%DS%%%%)'         
//SYSPRINT DD  SYSOUT=*                                       
//SYSIN    DD  DISP=SHR,DSN=HMVS01.VSAMIO.OFFLOAD             
//SYSUT2   DD  DISP=(,CATLG,DELETE),DSN=HMVS02.VSAMIO.COBOL,    
//             DCB=(DSORG=PO,RECFM=FB,LRECL=80,BLKSIZE=23440),
//             UNIT=SYSDA,VOL=SER=MVS381,                     
//             SPACE=(CYL,(2,1,15))                      
//                                                            </b><b> </b></pre>
               </td>
            </tr>
            <tr>
               <td width="33%">
                  <b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="PDSLOADj03"></a></b>Add
                  members to partitioned dataset from OFFLOADed dataset
               </td>
            </tr>
            <tr>
               <td width="33%">
                  <pre><b>//PDSLOAD  JOB (SYS),'PDSLOAD-3',CLASS=A,MSGCLASS=X    
//PDSLOAD EXEC PGM=PDSLOAD,PARM='SPF,S(VSAMIO%%)'      
//SYSPRINT DD  SYSOUT=*                                
//SYSUT1   DD  DISP=SHR,DSN=HMVS01.VSAMIO.OFFLOAD      
//SYSUT2   DD  DISP=MOD,DSN=HMVS02.VSAMIO.COBOL                
//                                                     </b></pre>
               </td>
            </tr>
         </tbody></table>
      </blockquote>
      <hr size="8" noshade="noshade">
      <h2><a name="PDSMATCH"></a>PDSMATCH <font size="2">[written by Bill Godfrey,
         updated by Carl Hafner, located in SYSC.LINKLIB]</font>
      </h2>
      <p>Used for comparing two partitioned datasets.&nbsp; PDSMATCH compares the
         directories of the two datasets and prints a report showing which members match,
         which members do not match, or members that are not present in both directories.
      </p>
      <p>The most recent version of PDSMATCH is located in File #357 of the CBT
         tape.&nbsp; This version of the program was modified by Carl Hafner; Steli,
         Inc.&nbsp; PDSMATCH
         requires the following DD statements:
      </p>
      <ul>
         <li>SYSPRINT - defines a sequential output message dataset.</li>
         <li>SYSLIB1 - defines the first partitioned dataset.</li>
         <li>SYSLIB2 - defines the second partitioned dataset.</li>
      </ul>
      <h3>&nbsp;</h3>
      <h3>Program Parameter (PARM= on EXEC statement)</h3>
      <blockquote>
         <p>The operation of PDSMATCH is controlled by options which are entered as keywords
            in the parameter field.&nbsp;
            The keywords and their function are:
         </p>
         <blockquote>
            <p>EQO</p>
            <blockquote>
               <p>Specifies that only members that match are to be listed.</p>
            </blockquote>
            <p>NEO</p>
            <blockquote>
               <p>Specifies that only members that do not match are to be listed.</p>
            </blockquote>
            <p>USER</p>
            <blockquote>
               <p>Specifies that members match only if they have the same name and all the
                  statistics match.&nbsp; Statistics of up to 62 bytes of data in the
                  directory entry are compared.&nbsp; This includes data placed in the
                  directory entry linkage editor, SPF edit, etc.&nbsp; Note:&nbsp; If two
                  members have the same name and neither has any userdata, they are treated as
                  unequal.
               </p>
            </blockquote>
            <p>DATA</p>
            <blockquote>
               <p>Specifies that members match only if all their data records are the
                  same.&nbsp; Note:&nbsp; If two members have the same name and both are empty,
                  they are treated as unequal.
               </p>
            </blockquote>
         </blockquote>
         <p>If no PARM is supplied, only the directories are compared to report members
            present in both, or only one, of the datasets.
         </p>
      </blockquote>
      <p>&nbsp;</p>
      <h3>Control Statements</h3>
      <blockquote>
         <p>There are no control statements.&nbsp; If specific members of a
            partitioned dataset are to be selected or excluded, their names are included
            in SYSIN.&nbsp; The names specified are separated by commas.&nbsp; As many
            statements as are required may be included in a single execution.
         </p>
      </blockquote>
      <p>&nbsp;</p>
      <h3>Examples</h3>
      <blockquote>
         <table width="75%" cellspacing="1" border="1">
            <tbody><tr>
               <td width="33%">
                  <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="PDSMATCHj01"></a>Compare
                     two partitioned datasets, names only
               </p></td>
            </tr>
            <tr>
               <td>
                  <pre><b>//PDSMATCH JOB (1),'PDSMATCH-1',CLASS=A,MSGCLASS=X  
//PDSMATCH EXEC PGM=PDSMATCH,REGION=4M,             
//             PARM=''                              
//SYSPRINT  DD SYSOUT=*                             
//SYSLIB1   DD DISP=SHR,DSN=HMVS02.VSAMIO.COBOL          
//SYSLIB2   DD DISP=SHR,DSN=HMVS01.VSAMIO.SOURCE     
//                                                  </b></pre>
               </td>
            </tr>
            <tr>
               <td width="33%">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="PDSMATCHj02"></a>Compare
                  two partitioned datasets, names and userdata
               </td>
            </tr>
            <tr>
               <td width="33%">
                  <pre><b>//PDSMATCH JOB (1),'PDSMATCH-2',CLASS=A,MSGCLASS=X  
//PDSMATCH EXEC PGM=PDSMATCH,REGION=4M,             
//             PARM='NEO,USER'                      
//SYSPRINT  DD SYSOUT=*                             
//SYSLIB1   DD DISP=SHR,DSN=SYS2.LINKLIB            
//SYSLIB2   DD DISP=SHR,DSN=SYSC.LINKLIB            
//                                                  </b></pre>
               </td>
            </tr>
            <tr>
               <td width="33%">
                  <b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="PDSMATCHj03"></a></b>Compare
                  two partitioned datasets, names and actual data records
               </td>
            </tr>
            <tr>
               <td width="33%">
                  <pre><b>//PDSMATCH JOB (1),'PDSMATCH-1',CLASS=A,MSGCLASS=X 
//PDSMATCH EXEC PGM=PDSMATCH,REGION=4M,            
//             PARM='NEO,DATA'                     
//SYSPRINT  DD SYSOUT=*                            
//SYSLIB1   DD DISP=SHR,DSN=JAY01.OLD.PTFS         
//SYSLIB2   DD DISP=SHR,DSN=JAY01.NEW.PTFS         
//                                                 </b></pre>
               </td>
            </tr>
         </tbody></table>
      </blockquote>
      <hr size="8" noshade="noshade">
      <h2><a name="PDSPRINT"></a>PDSPRINT <font size="2">[written by Jim Marshall, located in
         SYSC.LINKLIB]</font>
      </h2>
      <p>Used for printing or punching members from a partitioned dataset.</p>
      <p>PDSPRINT is located in File #316 of the CBT
         tape.&nbsp; PDSPRINT
         requires the following DD statements:
      </p>
      <ul>
         <li>SYSPRINT - defines a sequential output message dataset.</li>
         <li>SYSIN - defines the optional sequential input dataset that contains
            PDSPRINT control statements.
         </li>
         <li>SYSUT1 - defines the input partitioned dataset.</li>
         <li>SYSUT2 - defines the sequential output dataset.</li>
      </ul>
      <h3>&nbsp;</h3>
      <h3>Program Parameter (PARM= on EXEC statement)</h3>
      <blockquote>
         <p>A program parameter may be supplied to PRINT or PUNCH an entire dataset, in
            which case it is not necessary to supply control statements and the SYSIN DD
            may be omitted or DUMMY.&nbsp; If SYSIN is provided, the PARM is
            ignored.&nbsp; The keywords and their function are:
         </p>
         <blockquote>
            <p>PRINT</p>
            <blockquote>
               <p>Specifies that all members of the dataset are to be printed.</p>
            </blockquote>
            <p>PUNCH</p>
            <blockquote>
               <p>Specifies that all members of the dataset are to be punched.&nbsp; The
                  data records for each member are preceded by an IEBUPDTE ADD control
                  statement.
               </p>
            </blockquote>
         </blockquote>
      </blockquote>
      <p>&nbsp;</p>
      <h3>Control Statements</h3>
      <blockquote>
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="9%">
                  <pre><a name="PDSPRINTprint"></a>PRINT  </pre>
               </td>
               <td width="91%">
                  <pre>MEMBER=(name[,name]...) | SCAN=(namemask)</pre>
               </td>
            </tr>
         </tbody></table>
         <p>The PRINT control statement specifies that members are to be selected and printed.&nbsp; The mutually
            exclusive parameters are:
         </p>
         <blockquote>
            <p>MEMBER=(name[,name]...)</p>
            <blockquote>
               <p>Specifies that the named members are to be selected.&nbsp; The list of
                  names is enclosed in parentheses and separated by commas.&nbsp; The list
                  may be continued to as many cards as required by stopping with a comma
                  before column 72 and continuing the list on a subsequent card in any
                  column before 72.
               </p>
            </blockquote>
            <p>SCAN(namemask)</p>
            <blockquote>
               <p>Specifies that the directory names will be compared with the mask
                  supplied and any matching member will be selected.
               </p>
            </blockquote>
         </blockquote>
         <hr color="#808080">
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="9%">
                  <pre><a name="PDSPRINTpunch"></a>PUNCH  </pre>
               </td>
               <td width="91%">
                  <pre>MEMBER=(name[,name]...) | SCAN=(namemask)</pre>
               </td>
            </tr>
         </tbody></table>
         <p>The PUNCH control statement specifies that members are to be selected and punched.&nbsp; The data
            records for each member are preceded by an IEBUPDTE ADD control
            statement.&nbsp; The mutually exclusive parameters are:
         </p>
         <blockquote>
            <p>MEMBER=(name[,name]...)</p>
            <blockquote>
               <p>Specifies that the named members are to be selected.&nbsp; The list of
                  names is enclosed in parentheses and separated by commas.&nbsp; The list
                  may be continued to as many cards as required by stopping with a comma
                  before column 72 and continuing the list on a subsequent card in any
                  column before 72.
               </p>
            </blockquote>
            <p>SCAN(namemask)</p>
            <blockquote>
               <p>Specifies that the directory names will be compared with the mask
                  supplied and any matching member will be selected.
               </p>
            </blockquote>
         </blockquote>
      </blockquote>
      <p>&nbsp;</p>
      <h3>Examples</h3>
      <blockquote>
         <table width="75%" cellspacing="1" border="1">
            <tbody><tr>
               <td width="33%">
                  <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="PDSPRINTj01"></a>Punch
                     all members with IEBUPDTE ADD cards
               </p></td>
            </tr>
            <tr>
               <td>
                  <pre><b>//PDSPRINT JOB (001),'PDSPRINT-1',CLASS=A,MSGCLASS=X       
//PDSPRINT EXEC PGM=PDSPRINT,REGION=256K,PARM='PUNCH'      
//SYSPRINT DD  SYSOUT=*                   
//SYSUT1   DD  DSN=SYSC.PROCLIB,DISP=SHR  
//SYSUT2   DD  SYSOUT=B                   
//                                                         </b></pre>
               </td>
            </tr>
            <tr>
               <td width="33%">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="PDSPRINTj02"></a>Print
                  selected members
               </td>
            </tr>
            <tr>
               <td width="33%">
                  <pre><b>//PDSPRINT JOB (001),'PDSPRINT-2',CLASS=A,MSGCLASS=X 
//PDSPRINT EXEC PGM=PDSPRINT,REGION=256K,PARM=''     
//SYSPRINT DD  SYSOUT=*                              
//SYSUT1   DD  DSN=SYSC.PROCLIB,DISP=SHR             
//SYSUT2   DD  SYSOUT=*                              
//SYSIN    DD  *                                     
  PRINT MEMBER=(ASMXC,ASMXCL)                        
//                                                   </b></pre>
               </td>
            </tr>
            <tr>
               <td width="33%">
                  <b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="PDSPRINTj03"></a></b>Punch
                  long list of selected members
               </td>
            </tr>
            <tr>
               <td width="33%">
                  <pre><b>//PDSPRINT JOB (001),'PDSPRINT-3',CLASS=A,MSGCLASS=X                   
//PDSPRINT EXEC PGM=PDSPRINT,REGION=256K,PARM=''                       
//SYSPRINT DD  SYSOUT=*                                                
//SYSUT1   DD  DISP=SHR,DSN=SYSC.VSAMIO.SOURCE                         
//SYSUT2   DD  SYSOUT=*                                                
//SYSIN    DD  *                                                       
  PUNCH MEMBER=(ESDSADDT,ESDSLOAD,ESDSUPDT,ESDSREAD,                   
                KSDSMULT,KSDSLVAR,KSDSRAND,KSDSREAD,KSDSSSEQ,KSDSUPDT) 
//                                                                     </b></pre>
               </td>
            </tr>
            <tr>
               <td width="33%">
                  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="PDSPRINTj04"></a>Print
                  members selected with name pattern
               </td>
            </tr>
            <tr>
               <td width="33%">
                  <pre><b>//PDSPRINT JOB (001),'PDSPRINT-4',CLASS=A,MSGCLASS=X 
//PDSPRINT EXEC PGM=PDSPRINT,REGION=256K,PARM=''     
//SYSPRINT DD  SYSOUT=*                              
//SYSUT1   DD  DISP=SHR,DSN=SYSC.PROCLIB             
//SYSUT2   DD  SYSOUT=*                              
//SYSIN    DD  *                                     
  PRINT SCAN=(PL1)                                   
//                                                   </b></pre>
               </td>
            </tr>
         </tbody></table>
      </blockquote>
      <hr size="8" noshade="noshade">
      <h2><a name="PDSPROGM"></a>PDSPROGM <font size="2">[written by Bill Godfrey, located in
         SYSC.LINKLIB]</font>
      </h2>
      <p>Used for maintenance on partitioned datasets.&nbsp; PDSPROGM can be used to:</p>
      <ul>
         <li>
            <p align="LEFT">Delete a member.
         </p></li>
         <li>
            <p align="LEFT">Rename a member.
         </p></li>
         <li>
            <p align="LEFT">Create an alias for a member.
         </p></li>
      </ul>
      <p>PDSPROGM is located in File #316 of the CBT
         tape.&nbsp; PDSPROGM
         requires the following DD statements:
      </p>
      <ul>
         <li>SYSPRINT - defines a sequential output message dataset.</li>
         <li>SYSIN - defines the sequential input dataset that contains PDSPROGM
            control statements.
         </li>
         <li>SYSLIB - defines the partitioned dataset.</li>
         <li>anyname - may be used to define the partitioned dataset when the FILE
            control statement is used.
         </li>
      </ul>
      <h3>&nbsp;</h3>
      <h3>Program Parameter (PARM= on EXEC statement)</h3>
      <blockquote>
         <p>A program parameter may be supplied to modify overall operation of PDSPROGM.&nbsp;
            The keywords and their function are:
         </p>
         <blockquote>
            <p>NL</p>
            <blockquote>
               <p>Specifies that control statements will not be logged to SYSPRINT.</p>
            </blockquote>
            <p>NM</p>
            <blockquote>
               <p>Specifies that normal messages will not be logged to SYSPRINT, only
                  errors.
               </p>
            </blockquote>
            <p>NF</p>
            <blockquote>
               <p>Specifies that encountering an error will not cause flushing of SYSIN.</p>
            </blockquote>
            <p>NR</p>
            <blockquote>
               <p>Specifies that there will be no enforcement of characters used in a new
                  member name.
               </p>
            </blockquote>
            <p>NC</p>
            <blockquote>
               <p>Specifies that no capitalization will be done on new member names.</p>
            </blockquote>
         </blockquote>
      </blockquote>
      <p>&nbsp;</p>
      <h3>Control Statements</h3>
      <blockquote>
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="10%">
                  <pre><a name="PDSPROGMdelete"></a>DELETE  </pre>
               </td>
               <td width="90%">
                  <pre>membername</pre>
               </td>
            </tr>
         </tbody></table>
         <blockquote>
            <p>The DELETE control statement specifies that the named member is to be deleted.&nbsp; DELETE may be
               abbreviated DEL or D, and has the synonyms SCRATCH and SCR.
            </p>
         </blockquote>
         <hr color="#808080">
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="10%">
                  <pre><a name="PDSPROGMrename"></a>RENAME  </pre>
               </td>
               <td width="90%">
                  <pre>membername</pre>
               </td>
            </tr>
            <tr>
               <td width="10%">
                  <pre></pre>
               </td>
               <td width="90%">
                  <pre>newname</pre>
               </td>
            </tr>
         </tbody></table>
         <blockquote>
            <p>The RENAME control statement specifies that the named member is to be renamed.&nbsp; RENAME may be
               abbreviated REN or R.
            </p>
         </blockquote>
         <hr color="#808080">
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="9%">
                  <pre><a name="PDSPROGMalias"></a>ALIAS  </pre>
               </td>
               <td width="91%">
                  <pre>membername</pre>
               </td>
            </tr>
            <tr>
               <td width="9%">
                  <pre></pre>
               </td>
               <td width="91%">
                  <pre>newname</pre>
               </td>
            </tr>
         </tbody></table>
         <blockquote>
            <p>The ALIAS control statement specifies that an alias is to be created for the named member.&nbsp; ALIAS
               may be abbreviated ALI or A.&nbsp;
            </p>
         </blockquote>
         <hr color="#808080">
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="10%">
                  <pre><a name="PDSPROGMoption"></a>OPTION  </pre>
               </td>
               <td width="90%">
                  <pre>[{LOG | NOLOG}]</pre>
               </td>
            </tr>
            <tr>
               <td width="10%">
                  <pre></pre>
               </td>
               <td width="90%">
                  <pre>[{MSG | NOMSG}]</pre>
               </td>
            </tr>
            <tr>
               <td width="10%">
                  <pre></pre>
               </td>
               <td width="90%">
                  <pre>[FLUSH | NOFLUSH}]</pre>
               </td>
            </tr>
         </tbody></table>
         <blockquote>
            <p>The OPTION control statement specifies options that modify PDSPROGM operations.&nbsp; The parameters
               are:
            </p>
            <blockquote>
               <p>LOG | NOLOG</p>
               <ul>
                  <li>LOG - Specifies that control statements will be logged to SYSPRINT.&nbsp;
                     The default is LOG.
                  </li>
                  <li>NOLOG - Specifies that control statements will not be logged to
                     SYSPRINT.
                  </li>
               </ul>
               <p>MSG | NOMSG</p>
               <ul>
                  <li>MSG - Specifies that normal messages will not be logged to SYSPRINT, only
                     errors.&nbsp; The default is MSG.
                  </li>
                  <li>NOMSG - Specifies that normal messages will not be logged to SYSPRINT, only
                     errors.
                  </li>
               </ul>
               <p>FLUSH | NOFLUSH</p>
               <ul>
                  <li>FLUSH - Specifies that encountering an error will cause flushing of
                     SYSIN.&nbsp;
                     The default is FLUSH.
                  </li>
                  <li>NOFLUSH - Specifies that encountering an error will not cause flushing of
                     SYSIN.
                  </li>
               </ul>
            </blockquote>
         </blockquote>
         <hr color="#808080">
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="10%">
                  <pre><a name="PDSPROGMfile"></a>FILE</pre>
               </td>
               <td width="90%">
                  <pre> ddname</pre>
               </td>
            </tr>
         </tbody></table>
         <blockquote>
            <p>The FILE control statement specifies that any subsequent operations are to be performed against the
               dataset referenced by ddname.&nbsp; This allows multiple partitioned datasets
               to be processed in a single execution.&nbsp; FILE may be abbreviated FIL or F.
            </p>
         </blockquote>
      </blockquote>
      <h3>&nbsp;</h3>
      <h3>Examples</h3>
      <blockquote>
         <table width="75%" cellspacing="1" border="1">
            <tbody><tr>
               <td width="33%">
                  <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="PDSPROGMj01"></a>Partitioned
                     dataset maintenance
               </p></td>
            </tr>
            <tr>
               <td>
                  <pre><b>//PDSPROGM JOB (001),'PDSPROGM-1',CLASS=S,MSGCLASS=X 
//PDSPROGM EXEC PGM=PDSPROGM                         
//SYSPRINT DD  SYSOUT=*                              
//SYSLIB   DD  DISP=SHR,DSN=SYSP.VSAMIO.SOURCE     
//SYSLIB2  DD  DISP=SHR,DSN=SYSP.VSAMIOP.SOURCE         
//SYSIN    DD  *                                     
  OPTION NOFLUSH                                     
  ALIAS KSDSLVAR KSDSVARL                            
  DELETE $INDEX                                      
  RENAME ESDSUPDT ESDSUPDA                           
  FILE SYSLIB2                                       
  RENAME ESDSUPDT ESDSUPDA           <font color="#0000FF">&lt;- this statement will be applied to the dataset specified by the SYSLIB2 DD</font>                
//                                                   </b></pre>
               </td>
            </tr>
         </tbody></table>
      </blockquote>
      <hr size="8" noshade="noshade">
      <h2><a name="PDSSCAN"></a>PDSSCAN <font size="2">[written by Rick Fochtman, located in
         SYSC.LINKLIB]</font>
      </h2>
      <p>Used to scan all members of one or more partitioned datasets, searching for
         specified strings.&nbsp; Note:&nbsp; Does not update partitioned datasets, only
         reports datasets/members where strings are found.&nbsp; PDSSCAN is located in File
         #684 of the CBT
         tape.&nbsp; PDSSCAN
         requires the following DD statements:
      </p>
      <ul>
         <li>SYSPRINT - defines a sequential output message dataset.</li>
         <li>SYSIN - defines the sequential input dataset that contains strings to scan
            for.
         </li>
         <li>@anyname - defines the partitioned dataset(s) to be scanned.</li>
      </ul>
      <blockquote>
         <p>The number of DD statements may be from one to the MVS limit for a
            step.&nbsp; Any name is allowed, as long as the name begins with '@'.
         </p>
      </blockquote>
      <p>&nbsp; <b><font color="#0000FF">I would also suggest taking a look at
         PDSUPDTE.</font></b>
      </p>
      <h3>&nbsp;</h3>
      <h3>Program Parameter (PARM= on EXEC statement)</h3>
      <blockquote>
         <p>If any parameter is supplied, PDSSCAN will print a brief description of the
            program use instructions.
         </p>
      </blockquote>
      <p>&nbsp;</p>
      <h3>Control Statements</h3>
      <blockquote>
         <p>The control statements are simply the list of strings to be searched for in
            each partitioned dataset.&nbsp; Each statement read from SYSIN may contain a
            single string.&nbsp; A string begins at the first non-blank character and is
            terminated by the first blank; i.e., no embedded blanks are allowed.
         </p>
      </blockquote>
      <h3>&nbsp;</h3>
      <h3>Examples</h3>
      <blockquote>
         <table width="75%" cellspacing="1" border="1">
            <tbody><tr>
               <td width="33%">
                  <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="PDSSCANj01"></a>Scan
                     two partitioned datasets searching for strings
               </p></td>
            </tr>
            <tr>
               <td>
                  <pre><b>//PDSSCAN  JOB 1,'SCAN PDS',CLASS=A,MSGCLASS=X      
//PDSSCAN  EXEC PGM=PDSSCAN,REGION=1024K            
//SYSPRINT DD  SYSOUT=*                             
//@DD1     DD  DISP=SHR,DSN=SYSP.SETUP.LOCAL.CNTL   
//@DD2     DD  DISP=SHR,DSN=SYSC.CBT.SOURCE         
//SYSIN    DD  *                                    
  SYS2.LINKLIB                                      
  SYSC.LINKLIB                                      
//                                                   </b></pre>
               </td>
            </tr>
         </tbody></table>
      </blockquote>
      <hr size="8" noshade="noshade">
      <h2><a name="PDSUPDTE"></a>PDSUPDTE <font size="2">[located in SYSC.LINKLIB]</font></h2>
      <p>Used to scan all members of one or more partitioned datasets, searching for
         specified strings.&nbsp; If a string is found and operating mode is UPDATE, each
         string that is found is changed to the supplied second string.&nbsp; PDSUPDTE
         was created by disassembling IPOUPDTE, an IBM installation aid.&nbsp; PDSUPDTE is located in File
         #065 of the CBT Overflow tape.&nbsp; PDSUPDTE
         requires the following DD statements:
      </p>
      <ul>
         <li>SYSPRINT - defines a sequential output message dataset.</li>
         <li>SYSIN - defines the sequential input dataset that contains strings to scan
            for.
         </li>
         <li>@anyname - defines the partitioned dataset(s) to be scanned.</li>
      </ul>
      <blockquote>
         <p>The number of DD statements may be from one to the MVS limit for a
            step.&nbsp; Any name is allowed, as long as the name begins with '@'.
         </p>
      </blockquote>
      <p>&nbsp; <font color="#0000FF"><b>I would also suggest taking a look at PDSSCAN.&nbsp;
         </b></font>There is a detailed user's guide for PDSUPDTE available for download
         from this site at:&nbsp; <a href="http://www.jaymoseley.com/hercules/downloads/pdf/pdsupdte.pdf" target="_blank">../downloads/pdf/pdsupdte.pdf</a>.
      </p>
      <h3>&nbsp;</h3>
      <h3>Program Parameter (PARM= on EXEC statement)</h3>
      <blockquote>
         <p>A keyword supplied in the PARM determines the operating mode of PDSUPDTE:</p>
         <blockquote>
            <p>CHECK</p>
            <blockquote>
               <p>Specifies that the report will be produced showing all successful
                  searches for strings and what the updated data record would be, but no
                  updates are written to the partitioned dataset(s).
               </p>
            </blockquote>
            <p>UPDATE&nbsp;</p>
            <blockquote>
               <p>Specifies that all changes will be written to the partitioned dataset(s).</p>
            </blockquote>
         </blockquote>
      </blockquote>
      <p>&nbsp;</p>
      <h3>Control Statements</h3>
      <blockquote>
         <p>The control statements supply the string to search for and the string to
            replace.&nbsp; The format is:
         </p>
         <blockquote>
            <pre>search&lt;replace&lt;[limiter&lt;]</pre>
         </blockquote>
         <p>The delimiter for each string value is the less than symbol
            '&lt;'.&nbsp;&nbsp;
         </p>
         <p>The optional third string, shown as limiter above, allows the specification
            of a second search value, which must be present in the unmodified data record
            where the search string is found before the replacement will be made.
         </p>
         <p>Comments are allowed following the search/replace strings; comments must be
            separated from strings by at least one blank.
         </p>
      </blockquote>
      <h3>&nbsp;</h3>
      <h3>Examples</h3>
      <blockquote>
         <table width="75%" cellspacing="1" border="1">
            <tbody><tr>
               <td width="33%">
                  <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="PDSUPDTEj01"></a>Scan
                     two partitioned datasets searching for strings, check only
               </p></td>
            </tr>
            <tr>
               <td>
                  <pre><b>//PDSUPDTE JOB 1,'PDSUPDTE-1',CLASS=A,MSGCLASS=X         
//PDSUPDTE EXEC PGM=PDSUPDTE,REGION=1024K,PARM=CHECK     
//SYSPRINT DD  SYSOUT=*                                  
//@DD1     DD  DISP=SHR,DSN=SYSP.SETUP.LOCAL.CNTL   
//@DD2     DD  DISP=SHR,DSN=SYSC.CBT.SOURCE         
//SYSIN    DD  *                                    
SYS2.LINKLIB&lt;SYSC.LINKLIB&lt;   Change target library                                                             
//                                                   </b></pre>
               </td>
            </tr>
            <tr>
               <td>
                  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="PDSUPDTEj02"></a>Scan
                  a partitioned dataset, two matchings strings required, update if found
               </td>
            </tr>
            <tr>
               <td>
                  <pre><b>//PDSUPDTE JOB 1,'PDSUPDTE-2',CLASS=A,MSGCLASS=X         
//PDSUPDTE EXEC PGM=PDSUPDTE,REGION=1024K,PARM=UPDATE     
//SYSPRINT DD  SYSOUT=*                                  
//@DD1 DD DISP=SHR,DSN=HMVS01.VSAMIO.SOURCE               
//SYSIN    DD  *                                         
PUB001&lt;MVS380&lt;GO&lt;            Change volser on GO steps                            
//                                                       </b></pre>
               </td>
            </tr>
         </tbody></table>
      </blockquote>
      <hr size="8" noshade="noshade">
      <h2><a name="PDSUR"></a>PDSUR <font size="2">[written by Gene Czarcinski,
         located in
         SYSC.LINKLIB]</font>
      </h2>
      <p>Used to copy partitioned datasets from DASD to tape (unload) and from tape to
         DASD (reload); the tape datasets are in IEHMOVE format and PDSUR will restore
         tapes created with IEHMOVE.&nbsp;&nbsp; PDSUPDTE was written by Gene Czarcinski
         and is located in File #949 of the CBT
         tape.&nbsp; PDSUPDTE
         requires the following DD statements:
      </p>
      <ul>
         <li>SYSPRINT - defines a sequential output message dataset.</li>
         <li>SYSIN - defines the sequential input dataset that contains PDSUR Control
            statements.
         </li>
         <li>anyname - defines the partitioned dataset.</li>
         <li>anyname - defines the tape dataset.</li>
      </ul>
      <h3>&nbsp;</h3>
      <h3>Control Statements</h3>
      <blockquote>
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="12%">
                  <pre><a name="PDSURunload"></a>UNLOAD</pre>
               </td>
               <td width="88%">
                  <pre>FROMDD=ddname</pre>
               </td>
            </tr>
            <tr>
               <td width="12%">
                  <pre></pre>
               </td>
               <td width="88%">
                  <pre>,TODD=ddnamel</pre>
               </td>
            </tr>
            <tr>
               <td width="12%">
                  <pre></pre>
               </td>
               <td width="88%">
                  <pre>[,SELECT]</pre>
               </td>
            </tr>
            <tr>
               <td width="12%">
                  <pre></pre>
               </td>
               <td width="88%">
                  <pre>[,EXCLUDE]</pre>
               </td>
            </tr>
         </tbody></table>
         <p>The UNLOAD control statement specifies that an unload (backup creation) operation is to be
            performed.&nbsp; UNLOAD may be abbreviated U.&nbsp; The parameters are:
         </p>
         <blockquote>
            <blockquote>
               <p>FROMDD=ddname</p>
               <blockquote>
                  <p>Specifies the ddname of the partitioned dataset.&nbsp; FROMDD may be
                     abbreviated F.
                  </p>
               </blockquote>
               <p>TODD=ddname</p>
               <blockquote>
                  <p>Specifies the ddname of the tape dataset.&nbsp; TODD may be abbreviated
                     T.
                  </p>
               </blockquote>
               <p>SELECT</p>
               <blockquote>
                  <p>Specifies that only the members named on the following MEMBER control
                     statements are to be processed.&nbsp; SELECT may be abbreviated S.
                  </p>
               </blockquote>
               <p>EXCLUDE</p>
               <blockquote>
                  <p>Specifies that all members in the partitioned dataset, except for the
                     members named on the following MEMBER control statements, are to be
                     processed.&nbsp; EXCLUDE may be abbreviated E.
                  </p>
               </blockquote>
            </blockquote>
         </blockquote>
         <hr color="#808080">
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="12%">
                  <pre><a name="PDSURreload"></a>RELOAD</pre>
               </td>
               <td width="88%">
                  <pre>FROMDD=ddname</pre>
               </td>
            </tr>
            <tr>
               <td width="12%">
                  <pre></pre>
               </td>
               <td width="88%">
                  <pre>,TODD=ddname</pre>
               </td>
            </tr>
            <tr>
               <td width="12%">
                  <pre></pre>
               </td>
               <td width="88%">
                  <pre>[,SELECT]</pre>
               </td>
            </tr>
            <tr>
               <td width="12%">
                  <pre></pre>
               </td>
               <td width="88%">
                  <pre>[,EXCLUDE]</pre>
               </td>
            </tr>
            <tr>
               <td width="12%">
                  <pre></pre>
               </td>
               <td width="88%">
                  <pre>[,REPLACE]</pre>
               </td>
            </tr>
            <tr>
               <td width="12%">
                  <pre></pre>
               </td>
               <td width="88%">
                  <pre>[,LEAVE]</pre>
               </td>
            </tr>
         </tbody></table>
         <p>The RELOAD control statement specifies that a reload (restore from backup) operation is to be
            performed.&nbsp; RELOAD may be abbreviated R.&nbsp; The parameters are:
         </p>
         <blockquote>
            <blockquote>
               <p>FROMDD</p>
               <blockquote>
                  <p>Specifies the ddname of the tape dataset.&nbsp; FROMDD may be
                     abbreviated F.
                  </p>
               </blockquote>
               <p>TODD</p>
               <blockquote>
                  <p>Specifies the ddname of the partitioned dataset.&nbsp; TODD may be
                     abbreviated T.
                  </p>
               </blockquote>
               <p>SELECT</p>
               <blockquote>
                  <p>Specifies that only the members named on the following MEMBER control
                     statements are to be restored.&nbsp; SELECT may be abbreviated S.
                  </p>
               </blockquote>
               <p>EXCLUDE</p>
               <blockquote>
                  <p>Specifies that all members in the partitioned dataset, except for the
                     members named on the following MEMBER control statements, are to be
                     restored.&nbsp; EXCLUDE may be abbreviated E.
                  </p>
               </blockquote>
               <p>REPLACE</p>
               <blockquote>
                  <p>Specifies that if a member being restored already exists in the
                     partitioned dataset, it is to be replaced with the member from the
                     backup.&nbsp;
                  </p>
               </blockquote>
               <p>LEAVE</p>
               <blockquote>
                  <p>Specifies that at the end of the specified operation the tape file is
                     closed and left mounted, even if DISP=(OLD,KEEP) is specified.
                  </p>
               </blockquote>
            </blockquote>
         </blockquote>
         <hr color="#808080">
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="12%">
                  <pre><a name="PDSURlist"></a>LIST</pre>
               </td>
               <td width="88%">
                  <pre>FROMDD=ddname</pre>
               </td>
            </tr>
            <tr>
               <td width="12%"></td>
               <td width="88%">
                  <pre>[,LEAVE]</pre>
               </td>
            </tr>
         </tbody></table>
         <p>The LIST control statement specifies that the contents of an unloaded dataset are to be read and
            listed.&nbsp; The parameters are:
         </p>
         <blockquote>
            <blockquote>
               <p>FROMDD</p>
               <blockquote>
                  <p>Specifies the ddname of the tape dataset.&nbsp; FROMDD may be
                     abbreviated F.
                  </p>
               </blockquote>
               <p>LEAVE</p>
               <blockquote>
                  <p>Specifies that at the end of the specified operation the tape file is
                     closed and left mounted, even if DISP=(OLD,KEEP) is specified.
                  </p>
               </blockquote>
            </blockquote>
         </blockquote>
         <hr color="#808080">
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="12%">
                  <pre><a name="PDSURmember"></a>MEMBER</pre>
               </td>
               <td width="88%">
                  <p>membername[,membername...]</p>
               </td>
            </tr>
         </tbody></table>
         <p>The MEMBER control statement specifies member names for the SELECT or EXCLUDE option specified on the
            previous UNLOAD or RELOAD control statement.&nbsp; More than one member
            control statement may follow an UNLOAD or RELOAD statement, so that many names
            can be specified.&nbsp; The operand field must contain one or more member
            names separated by commas.
         </p>
      </blockquote>
      <h3>&nbsp;</h3>
      <h3>Examples</h3>
      <blockquote>
         <table width="75%" cellspacing="1" border="1">
            <tbody><tr>
               <td width="33%">
                  <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="PDSURj01"></a>Unload
                     two partitioned datasets
               </p></td>
            </tr>
            <tr>
               <td>
                  <pre><b>//PDSUR    JOB (1),'PDSUR-1',CLASS=A,MSGCLASS=X          
//PDSUR    PROC OUT=A,BLK=3509,REG=4M                    
//PDSUR    EXEC PGM=PDSUR,REGION=&amp;REG                    
//SYSPRINT  DD SYSOUT=&amp;OUT,DCB=BLKSIZE=&amp;BLK              
//SYSIN     DD DCB=(BLKSIZE=800,BUFNO=1)                 
//         PEND                                          
//         EXEC PDSUR                                    
//SYSIN     DD *                                         
UNLOAD FROMDD=DISK,TODD=TAPE                             
U F=D2,T=T2                                              
//DISK      DD DISP=SHR,DSN=SYS2.PROCLIB                 
//D2        DD DISP=SHR,DSN=SYS2.LINKLIB                 
//TAPE      DD DISP=(,KEEP),DSN=A,LABEL=1,UNIT=TAPE,     
//             VOL=SER=22007A                            
//T2        DD DISP=(,KEEP),DSN=B,LABEL=2,VOL=REF=*.TAPE 
//                                                       </b></pre>
               </td>
            </tr>
            <tr>
               <td width="33%">
                  <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="PDSURj02"></a>Reload
                     a partitioned dataset
               </p></td>
            </tr>
            <tr>
               <td>
                  <pre><b>//PDSUR    JOB (1),'PDSUR-2',CLASS=A,MSGCLASS=X                
//PDSUR    PROC OUT=A,BLK=3509,REG=50K                         
//PDSUR    EXEC PGM=PDSUR,REGION=&amp;REG                          
//SYSPRINT  DD SYSOUT=&amp;OUT,DCB=BLKSIZE=&amp;BLK                    
//SYSIN     DD DCB=(BLKSIZE=800,BUFNO=1)                       
//         PEND                                                
//         EXEC PDSUR                                          
//SYSIN     DD *                                               
RELOAD FROMDD=DD1,T=DD2,R                                      
//DD1       DD UNIT=TAPE,DISP=OLD,DSN=HMVS01.A,VOL=SER=22007B  
//DD2       DD DISP=(NEW,KEEP),DSN=HMVS01.CNTL.R,              
//             UNIT=SYSDA,VOL=SER=MVS380,                      
//             DCB=(HMVS01.CNTL),                              
//             SPACE=(CYL,(1,1,5))                             
//                                                             </b></pre>
               </td>
            </tr>
            <tr>
               <td>
                  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="PDSURj03"></a>Unload
                  and reload a partitioned dataset in one step
               </td>
            </tr>
            <tr>
               <td>
                  <pre><b>//PDSUR    JOB (1),'PDSUR-3',CLASS=A,MSGCLASS=X</b><b>
//PDSUR    PROC OUT=A,BLK=3509,REG=50K
//PDSUR    EXEC PGM=PDSUR,REGION=&amp;REG
//STEPLIB   DD DISP=SHR,DSN= ... (POINT AT LIBRARY FOR PDSUR PGM)
//SYSPRINT  DD SYSOUT=&amp;OUT,DCB=BLKSIZE=&amp;BLK
//SYSIN     DD DCB=(BLKSIZE=800,BUFNO=1)
//         PEND
//         EXEC PDSUR
//SYSIN     DD *
UNLOAD FROMDD=DD1,TODD=DD2
RELOAD FROMDD=DD3,TODD=DD1
//DD1       DD DISP=OLD,DSN=M2.USRID.LINKLIB
//DD2       DD DISP=(,KEEP),DSN=M2.USRID.BAKUP,LABEL=3,
//             UNIT=TAPE,VOL=SER=22007C
//DD3       DD DISP=OLD,DSN=M2.USRID.OLDTAP,LABEL=10,
//             UNIT=TAPE,VOL=SER=21250C
//</b></pre>
               </td>
            </tr>
            <tr>
               <td width="33%">
                  <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="PDSURj04"></a>List
                     three unloaded partitioned datasets
               </p></td>
            </tr>
            <tr>
               <td>
                  <pre><b>//PDSUR    JOB (1),'PDSUR-4',CLASS=A,MSGCLASS=X       
//PDSUR    PROC OUT=A,BLK=3509,REG=50K                
//PDSUR    EXEC PGM=PDSUR,REGION=&amp;REG                 
//SYSPRINT  DD SYSOUT=&amp;OUT,DCB=BLKSIZE=&amp;BLK           
//SYSIN     DD DCB=(BLKSIZE=800,BUFNO=1)              
//         PEND                                       
//         EXEC PDSUR                                 
//SYSIN     DD *                                      
LIST FROMDD=DD1,LEAVE                                 
LIST F=DD2,LEAVE                                      
L FROMDD=DD3,L                                        
//DD1       DD DISP=OLD,DSN=A,LABEL=1,UNIT=TAPE,      
//             VOL=SER=22007D                         
//DD2       DD DISP=OLD,DSN=E,LABEL=5,VOL=REF=*.DD1   
//DD3       DD DISP=OLD,DSN=I,LABEL=9,VOL=REF=*.DD1   
//                                                    </b></pre>
               </td>
            </tr>
            <tr>
               <td>
                  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="PDSURj05"></a>Unload
                  with selects and excludes
               </td>
            </tr>
            <tr>
               <td>
                  <pre><b>//PDSUR    JOB (1),'PDSUR-5',CLASS=A,MSGCLASS=X                  
//PDSUR    PROC OUT=A,BLK=3509,REG=50K                           
//PDSUR    EXEC PGM=PDSUR,REGION=&amp;REG                            
//SYSPRINT  DD SYSOUT=&amp;OUT,DCB=BLKSIZE=&amp;BLK                      
//SYSIN     DD DCB=(BLKSIZE=800,BUFNO=1)                         
//         PEND                                                  
//         EXEC PDSUR                                            
//SYSIN     DD *                                                 
UNLOAD FROMDD=DD1,TODD=DD2,S                                     
MEMBER ASMGASM,BASIC360,PASCAL                                   
UNLOAD FROMDD=DD1,TODD=DD3,E                                     
MEMBER ASMGASM,BASIC360,PASCAL                                   
//DD1       DD DISP=SHR,DSN=SYSC.LINKLIB                         
//DD2       DD DISP=(,KEEP),DSN=USRID.X1,LABEL=1,UNIT=TAPE,      
//             VOL=(PRIVATE,RETAIN,SER=22007E)                   
//DD3       DD DISP=(,KEEP),DSN=USRID.X2,LABEL=2,VOL=REF=*.DD2   
//                                                               </b></pre>
               </td>
            </tr>
            <tr>
               <td width="33%">
                  <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="PDSURj06"></a>Reload
                     with selects and excludes
               </p></td>
            </tr>
            <tr>
               <td>
                  <pre><b>//PDSUR    JOB (1),'PDSUR-6',CLASS=A,MSGCLASS=X</b><b>
//PDSUR    PROC OUT=A,BLK=3509,REG=50K
//PDSUR    EXEC PGM=PDSUR,REGION=&amp;REG
//SYSPRINT  DD SYSOUT=&amp;OUT,DCB=BLKSIZE=&amp;BLK
//SYSIN     DD DCB=(BLKSIZE=800,BUFNO=1)
//         PEND
//         EXEC PDSUR
//SYSIN     DD *
RELOAD FROMDD=DD1,TODD=DD2,LEAVE,S
MEMBER PROG1,PROG2
RELOAD FROMDD=DD1,TODD=DD3,EXCLUDE
MEMBER PROG3,PROG4
MEMBER PROG5,PROGA
//DD1       DD DISP=OLD,DSN=M2.USRID.T,LABEL=5,UNIT=2400-4,
//             VOL=SER=BKPTAP
//DD2       DD DISP=OLD,DSN=M2.USRID.LIB1
//DD3       DD DISP=OLD,DSN=M2.USRID.LIB2
//</b></pre>
               </td>
            </tr>
         </tbody></table>
      </blockquote>
      <hr size="8" noshade="noshade">
      <h2><a name="RECV370"></a>RECV370 <font size="2">[written by Jim Morrison,
         located in SYSC.LINKLIB]</font>
      </h2>
      <p>Used to process XMIT files produced by either the TSO/E TRANSMIT command
         processor, the XMIT370 batch program, or a similar facility.&nbsp; RECV370 was written by
         Jim Morrison
         and is located in File #571 of the CBT
         tape.&nbsp; RECV370
         requires the following DD statements:
      </p>
      <ul>
         <li>SYSPRINT - defines a sequential output message dataset (IEBCOPY messages).</li>
         <li>RECVLOG - defines a sequential output message dataset (RECV370 messages).</li>
         <li>SYSIN - unused, but required by IEBCOPY.</li>
         <li>SYSUT1 - work dataset.</li>
         <li>SYSUT2 - defines the output dataset.</li>
         <li>XMITIN - defines sequential input dataset, BLKSIZE must be 80 (XMIT file).</li>
      </ul>
      <h3>&nbsp;</h3>
      <h3>Control Statements</h3>
      <blockquote>
         <p>RECV370 uses no control statements.</p>
      </blockquote>
      <h3>&nbsp;</h3>
      <h3>Examples</h3>
      <blockquote>
         <table width="75%" cellspacing="1" border="1">
            <tbody><tr>
               <td width="33%">
                  <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="RECV370j01"></a>Unpack
                     XMIT to create PDS
               </p></td>
            </tr>
            <tr>
               <td>
                  <pre><b>//RECV370  JOB (001),'RECV370',CLASS=A,MSGCLASS=X                    
//RECV370  PROC                                                      
//RECV370  EXEC PGM=RECV370,REGION=1024K                             
//RECVLOG   DD SYSOUT=*                     RECV370 OUTPUT MESSAGES  
//SYSPRINT  DD SYSOUT=*                     IEBCOPY OUTPUT MESSAGES  
//SYSIN     DD DUMMY                        IEBCOPY REQUIRES         
//SYSUT1    DD UNIT=SYSDA,                  WORK DATASET             
//             SPACE=(CYL,(10,10)),                                  
//             DCB=BLKSIZE=5600                                      
//XMITIN    DD DDNAME=XMITIN                INPUT DATASET            
//SYSUT2    DD DDNAME=XMITOUT               OUTPUT DATASET           
//         PEND                                                      
//RECV1    EXEC RECV370                                               
//XMITIN   DD  UNIT=01C,DCB=BLKSIZE=80           &lt;- INPUT            
//SYSUT2   DD  DSN=HMVS01.FILE571.PDS,           &lt;- OUTPUT           
//             VOL=SER=PUB001,UNIT=SYSDA,                            
//             SPACE=(TRK,(200,,40),RLSE),                           
//             DISP=(,CATLG)                                         
//                                                                                                                         </b></pre>
               </td>
            </tr>
         </tbody></table>
      </blockquote>
      <hr size="8" noshade="noshade">
      <h2><a name="RESETDS"></a>RESETDS <font size="2">[author unknown, located in
         SYSC.LINKLIB]</font>
      </h2>
      <p>Used to reset to empty status partitioned or sequential datasets in
         preparation for a reload.&nbsp; The dataset will appear as though it had been
         scratched and reallocated, however, the overhead of scratch/allocate and
         uncatalog/catalog is avoided; additionally, the dataset will reside in the
         original location on the volume.&nbsp; The author of RESETDS is unknown; the
         source was NASPA 1986.&nbsp; RESETDS requires the following DD statements:
      </p>
      <ul>
         <li>RESET??? - defines a sequential or partitioned dataset.</li>
      </ul>
      <blockquote>
         <p>Any number of DD statements may be provided, as long as the name begins with
            'RESET'.&nbsp; RESETDS will process all DD names in a single execution.
         </p>
      </blockquote>
      <h3>Control Statements</h3>
      <blockquote>
         <p>RESETDS uses no control statements.</p>
      </blockquote>
      <h3><br>
         Examples
      </h3>
      <blockquote>
         <table width="75%" cellspacing="1" border="1">
            <tbody><tr>
               <td width="33%">
                  <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="RESETDSj01"></a>Reset
                     datasets to empty
               </p></td>
            </tr>
            <tr>
               <td>
                  <pre><b>//RESETDS  JOB (1),'RESET PDS/PS EMPTY',CLASS=A,MSGCLASS=X                                        
//RESET    EXEC PGM=RESETDS                                     
//STEPLIB   DD  DSN=SYSC.LINKLIB,DISP=SHR                       
//RESET1    DD  DISP=OLD,DSN=PDS.DATASET1                       
//RESETSEQ  DD  DISP=OLD,DSN=SEQ.DATASET                        
//RESET02   DD  DISP=OLD,DSN=PDS.DATASET2                       
//RESET003  DD  DISP=OLD,DSN=PDS.DATASET3                       
//                                                               </b></pre>
               </td>
            </tr>
         </tbody></table>
      </blockquote>
      <hr size="8" noshade="noshade">
      <h2><a name="REVLMOD"></a>REVLMOD <font size="2">[written by Greg Price, located in
         SYSC.LINKLIB]</font>
      </h2>
      <p>Used to reload load modules that have been offloaded with REVIEW's OFFLOAD
         command.&nbsp; REVLMOD was written by Greg Price
         and is located in File #134 of the CBT
         tape.&nbsp; REVLMOD
         requires the following DD statements:
      </p>
      <ul>
         <li>SYSIN - defines a sequential dataset containing the offloaded load module.</li>
         <li>SYSUT2 - defines a load library.</li>
      </ul>
      <h3>&nbsp;</h3>
      <h3>Control Statements</h3>
      <blockquote>
         <p>REVLMOD uses no control statements.</p>
      </blockquote>
      <h3><br>
         Examples
      </h3>
      <blockquote>
         <table width="75%" cellspacing="1" border="1">
            <tbody><tr>
               <td width="33%">
                  <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="REVLMODj01"></a>Reload
                     load module from sequential dataset
               </p></td>
            </tr>
            <tr>
               <td>
                  <pre><b>////REVLMOD  JOB (001),REVLMOD,CLASS=S,MSGCLASS=X            
//REVLMOD  EXEC PGM=REVLMOD,REGION=1M                      
//SYSUT2    DD DISP=MOD,DSN=SYS2.LINKLIB                   
//SYSIN     DD DISP=SHR,DSN=HMVS01.ISAMLOAD.OFFLOAD        
//                                                         </b></pre>
               </td>
            </tr>
         </tbody></table>
      </blockquote>
      <hr size="8" noshade="noshade">
      <h2><a name="SORT"></a>SORT <font size="2">[supplied by IBM, located in
         SYSC.LINKLIB]</font>
      </h2>
      <p>Used for sorting data records from one or more sequential datasets.&nbsp;&nbsp;</p>
      <p>
         This IBM program originated with OS Release 21.8, so the datasets it utilizes
         must reside on tape or 2314 DASD.&nbsp; The limitation to 2314 DASD is the
         simple fact of when this program originated, even 3330 DASD were scarce, and
         3350/3375/3380/3390 did not exist.&nbsp; But now that I have stated the
         limitation, I will say that I have found that there are times when SORT will
         read SORTIN from, and write SORTOUT to, a dataset on a DASD type later than
         2314, as can be seen in some of my example jobstreams below.&nbsp; There were
         efforts discussed on the Hercules' forums, years ago, to rewrite the SORT
         program, using the source code available, and upgrade the program to use all of
         the types of DASD we have available now for MVS 3.8 running under
         Hercules.&nbsp; There was even a brute force modification made to the program
         that allowed it to use the later types, but nothing was done to update the
         algorithms that balance and optimize the sort, so I don't think that is a
         solution that appeals to many.&nbsp; As it is, the program will work just fine,
         as long as you keep some 2314 DASD defined for it to use as sort work datasets,
         which hold the various sequence sets that are merged in the final phase to
         produce the output dataset.
      </p>
      <p> SORT requires the following DD statements:</p>
      <ul>
         <li>SYSOUT - defines a sequential output message dataset (output from MSG=AP
            or MSG=CP).
         </li>
         <li>SORTLIB - defines the partitioned input dataset containing the Sort/Merge
            external modules.
         </li>
         <li>SORTIN - defines the data records to be sorted.
         </li>
      </ul>
      <blockquote>
         <p>When using the SORT control statement, SORTIN is the DD name.&nbsp; When
            using the MERGE control statement, SORTIN01 through SORTIN16 are the DD names
            to use.
         </p>
      </blockquote>
      <ul>
         <li>SORTWKnn - defines external work datasets; used only when using the SORT
            control statement.&nbsp; The first work dataset is SORTWK01; additional
            datasets may be provided, up to SORTWK32.
         </li>
         <li>SORTOUT - defines the sequential output dataset.
         </li>
         <li>SORTCKPT - defines a dataset for checkpoint records.&nbsp; If you are not
            using the checkpoint facility this statement is not required.
         </li>
         <li>SYSIN - defines a sequential input dataset that contains SORT/MERGE control
            statements.
         </li>
      </ul>
      <h3>&nbsp;</h3>
      <h3>Control Statements</h3>
      <blockquote>
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="12%">
                  <pre><a name="SORTsort"></a>SORT</pre>
               </td>
               <td width="88%">
                  <pre>FIELDS={(p1,m1,f1,s1...p64,m64,f64,s64) | (p1,m1,s1...p64,m64,s64),FORMAT=xx}</pre>
               </td>
            </tr>
            <tr>
               <td width="12%">
                  <pre></pre>
               </td>
               <td width="88%">
                  <pre>[,SIZE=y]</pre>
               </td>
            </tr>
            <tr>
               <td width="12%">
                  <pre></pre>
               </td>
               <td width="88%">
                  <pre>[,SKIPREC=z]</pre>
               </td>
            </tr>
            <tr>
               <td width="12%">
                  <pre></pre>
               </td>
               <td width="88%">
                  <pre>[,CKPT]</pre>
               </td>
            </tr>
         </tbody></table>
         <p>The SORT control statement specifies a SORT operation.&nbsp; The parameters are:</p>
         <blockquote>
            <p>FIELDS=(p1,m1,f1,s1...p64,m64,f64,s64) <b>or<br>
               </b>FIELDS=(p1,m1,s1...p64,m64,s64),FORMAT=xx
            </p>
            <blockquote>
               <p>p1 (...p64) - specifies the beginning (high-order 
location) of a control field relative to
                  the beginning of the record which contains the control
 field.&nbsp; (For variable-length records, the logical record includes
                  the four-byte record length indicator, so record 
offsets must include
                  those four bytes in the offset position used.)&nbsp; 
The first (high-order) byte in a record is byte 1, the
                  second is byte 2, etc.&nbsp; All control fields, 
except binary, must begin on a
                  byte boundary.
               </p>
               <p>m1 (...m64) - specifies the length of the control field.&nbsp; All control fields except binary
                  must be a whole number of bytes long.
               </p>
               <p>f1 (...f64) - specifies the format of the data in the control field.&nbsp;
                  The valid two-character abbreviations are:
               </p>
               <blockquote>
                  <ul>
                     <li>CH - character</li>
                     <li>ZD - zoned decimal</li>
                     <li>PD - packed decimal</li>
                     <li>FI - fixed-point</li>
                     <li>BI - binary</li>
                     <li>FL - floating point<br>
                     </li>
                  </ul>
               </blockquote>
               <p>If all the control fields contain the same type of data, you can omit the f
                  parameters and use the optional FORMAT=xx operand.
               </p>
            </blockquote>
            <p>SIZE=y</p>
            <blockquote>
               <p>Specifies the number of records in the input 
dataset.&nbsp; The value y can be either the actual dataset size or an 
estimate of the size.&nbsp;
                  If you give an actual dataset size, do not include any
 records inserted in the
                  input dataset by one of your routines.&nbsp; If the 
number of records in the input
                  dataset, as counted by the sort/merge program, does 
not agree with the value of
                  the SIZE parameter, the sort terminates.&nbsp; The 
value specified in the SIZE
                  parameter is placed in the IN field of message IER047A
 or IER054I.&nbsp; If you give an
                  estimated dataset size, precede the value by E (for 
example, E5000).&nbsp;&nbsp;
               </p>
            </blockquote>
            <p>SKIPREC=z</p>
            <blockquote>
               <p>Specifies the number of records to be skipped when reading SORTIN.&nbsp;
                  If you want the sort to skip a certain number of records before starting to process the input dataset,
                  substitute the number of records you want skipped for z.
               </p>
            </blockquote>
            <p>CKPT</p>
            <blockquote>
               <p>Specifies that the sort/merge program is to activate the checkpoint facility of the operating system.&nbsp;
                  The program takes checkpoints at various points in the sort or merge
                  operation.&nbsp; You can have the program restart from the last checkpoint taken.
               </p>
            </blockquote>
         </blockquote>
         <hr color="#808080">
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="12%">
                  <pre><a name="SORTmerge"></a>MERGE</pre>
               </td>
               <td width="88%">
                  <pre>FIELDS={(p1,m1,f1,s1...p64,m64,f64,s64) | (p1,m1,s1...p64,m64,s64),FORMAT=xx}</pre>
               </td>
            </tr>
            <tr>
               <td width="12%"></td>
               <td width="88%">
                  <pre>[,SIZE=y]</pre>
               </td>
            </tr>
         </tbody></table>
         <p>The MERGE control statement specifies a MERGE operation.&nbsp; The parameters are:</p>
         <blockquote>
            <p>FIELDS=(p1,m1,f1,s1...p64,m64,f64,s64) <b>or<br>
               </b>FIELDS=(p1,m1,s1...p64,m64,s64),FORMAT=xx
            </p>
            <blockquote>
               <p>p1 (...p64) - specifies the beginning (high-order 
location) of a control field relative to
                  the beginning of the record which contains the control
 field.&nbsp; (For variable-length records, the logical record includes
                  the four-byte record length indicator, so record 
offsets must include
                  those four bytes in the offset position used.)&nbsp; 
The first (high-order) byte in a record is byte 1, the
                  second is byte 2, etc.&nbsp; All control fields, 
except binary, must begin on a
                  byte boundary.
               </p>
               <p>m1 (...m64) - specifies the length of the control field.&nbsp; All control fields except binary
                  must be a whole number of bytes long.
               </p>
               <p>f1 (...f64) - specifies the format of the data in the control field.&nbsp;
                  The valid two-character abbreviations are:
               </p>
               <blockquote>
                  <ul>
                     <li>CH - character</li>
                     <li>ZD - zoned decimal</li>
                     <li>PD - packed decimal</li>
                     <li>FI - fixed-point</li>
                     <li>BI - binary</li>
                     <li>FL - floating point<br>
                     </li>
                  </ul>
               </blockquote>
               <p>If all the control fields contain the same type of data, you can omit the f
                  parameters and use the optional FORMAT=xx operand.
               </p>
            </blockquote>
            <p>SIZE=y</p>
            <blockquote>
               <p>Specifies the number of records in the input dataset.&nbsp; The
                  value y can be either the actual dataset size or an estimate of the size.&nbsp;
                  If you give an actual dataset size, do not include any records inserted in the
                  input dataset by one of your routines.&nbsp; If the number of records in the input
                  dataset, as counted by the sort/merge program, does not agree with the value of
                  the SIZE parameter, the sort terminates.&nbsp; The value specified in the SIZE
                  parameter is placed in the IN field of message IER047A or IER054I.&nbsp; If you give an
                  estimated dataset size, precede the value by E (for example, E5000).&nbsp;
               </p>
            </blockquote>
         </blockquote>
         <hr color="#808080">
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="12%">
                  <pre><a name="SORTrecord"></a>RECORD</pre>
               </td>
               <td width="88%">
                  <pre>{TYPE=F,LENGTH=l1,l2,l3 | TYPE=V,LENGTH=l1,l2,l3,[l4,l5]}</pre>
               </td>
            </tr>
         </tbody></table>
         <p>The RECORD control statement is required only when your routines change record lengths
            during a sort/merge program run.&nbsp; The control statement statement describes the format and lengths
            of the records being sorted or merged.&nbsp; The parameters are:
         </p>
         <blockquote>
            <p>TYPE={F | V}</p>
            <ul>
               <li>F - indicates fixed-length records.</li>
               <li>V - indicates variable-length records.</li>
            </ul>
            <p>LENGTH=l1,l2,l3[,l4,l5]</p>
            <p>If your input records are fixed-length, use l1, l2, and l3 as follows:</p>
            <blockquote>
               <p>l1 is the length of each record in the input 
dataset.&nbsp; If you use the
                  RECORD control statement, you must include this 
value.&nbsp; The value should be the same
                  as the value you specified in the LRECL subparameter 
of the DCB parameter on
                  the SORTIN DD statement.&nbsp; If the values are not 
the same, sort/merge uses the value specified on the DD statement.&nbsp;
               </p>
               <p>l2 is the length of each record handled by the sort phase.&nbsp; If you do not
                  specify a value for l2 , the program assumes that it is equal to l1 as it is
                  specified on the record card.&nbsp; If you are going to change record lengths in
                  the sort phase, you must include a value for l2; you do not need l2 for a merging application.
               </p>
               <p>l3 is the length of each record in the output 
dataset.&nbsp; If you do not specify a
                  value for l3, the program assumes that l3=l2 for a 
sorting application and
                  that l3=l1 for a merging application.&nbsp; If your 
routines change record lengths
                  during the final merge phase of the program, you must 
specify a value for
                  l3.&nbsp; This value should be the same as the value 
you specified for the LRECL
                  subparameter of the DCB parameter on the SORTOUT DD 
statement.&nbsp; If the values are different, the sort/merge program
                  uses the value given on the DD statement.
               </p>
            </blockquote>
            <p>If your input records are variable-length, use l1,ll2, l3, l4, and l5 as
               follows:
            </p>
            <blockquote>
               <p>l1 is the maximum length of the records in the input dataset.&nbsp; If you use the
                  RECORD statement, you must specify a value for l1.&nbsp; The value should be the
                  same as the value you specified in the LRECL subparameter of the DCB parameter on the
                  SORTIN DD statement.&nbsp; If the values are not the same, the program uses the LRECL value.&nbsp;
               </p>
               <p>l2 is the maximum length of the records handled by the sort phase.&nbsp;
                  If you do not specify a value for l2, the program assumes it is equal to
                  l1 as it is specified on the record card.&nbsp; If you change record lengths
                  in the sort phase, you must provide a value for l2.&nbsp; You do not need
                  l2 for a merging application.
               </p>
               <p>l3 is the maximum length of each record in the output dataset.&nbsp; If you do not
                  specify a value for l3, the program assumes l3=l2 for a sort and l3=l1 for a
                  merge.&nbsp; If you include a routine that changes record lengths in the final
                  merge phase, you must specify a value for l3.&nbsp; The value should be the same
                  as the value you provided for the LRECL subparameter of the DCB parameter on
                  the SORTOUT DD statement.&nbsp; If it is not, the program uses the LRECL value.&nbsp;&nbsp;
               </p>
               <p>l4 is the minimum length of records in the input 
dataset.&nbsp; If you do not
                  specify a value for l4, the program assumes it is 
equal to the minimum record
                  size necessary to contain the control fields defined 
on the SORT or MERGE control statement, or the minimum record length 
allowed by the operating
                  system, whichever is greater.&nbsp; You need not 
specify this value for a merge.&nbsp;
               </p>
               <p>l5 is the record length that occurs most frequently in the input dataset (modal
                  length).&nbsp; You should use this value to help define a dataset biased toward a
                  particular length.&nbsp; If you do not specify a value for l5, the program assumes
                  it is equal to the average of the maximum and minimum record lengths in the
                  input dataset.&nbsp; If, for example, your dataset contains mostly small records
                  and just a few long records, the program would assume a high modal length and
                  would allocate a larger record storage area than necessary.&nbsp; Conversely, if
                  your dataset contains just a few short records and many long records, the
                  program would assume a low modal length and might not allocate a large enough
                  record storage area to sort your data.
               </p>
            </blockquote>
         </blockquote>
         <hr color="#808080">
         <p><a name="SORTmods"></a>MODS</p>
         <p>The MODS control statement is required only if you want the sort/merge program to transfer
            control to your routine (s) at various points during sort/merge execution.&nbsp;
            The statement associates your routines with specific exits in the sort/merge program
            and provides the program with basic descriptions of your routines.&nbsp; For details
            about exits in the sort/merge program and how to use them, refer to Section 3: Program
            Modification in <a href="http://http//bitsavers.org/pdf/ibm/360/os/R21.0_Mar72/GC28-6543-8_OS_Sort_Merge_Rel_21_Feb73.pdf" target="_blank">GC28-6543-8
            OS Sort/Merge Program</a>.
         </p>
         <hr color="#808080">
         <p><a name="SORTend"></a>END</p>
         <p>The END control statement marks the end of all sort/merge 
control statements and continuation statements for a particular 
sort/merge run.</p>
      </blockquote>
      <h3>&nbsp;</h3>
      <h3>Program Parameter (PARM= on EXEC statement)</h3>
      <blockquote>
         <p>The PARM parameter on the EXEC statement is used to supply optional
            parameters to the SORT program.&nbsp; The parameters are:
         </p>
         <blockquote>
            <p>[{BALN | OSCL | POLY | CRCX}]</p>
            <blockquote>
               <p>Specifies the sequence distribution technique to be used.&nbsp; <b>For
                  the majority of cases, this should be left for the program to determine
                  the optimum setting.</b>&nbsp; You should be extremely cautious when forcing the sort/merge program to use a
                  specific technique.&nbsp; The program tries to select the most efficient technique for
                  a given application. If it is forced to use another, performance may not be as
                  efficient.
               </p>
               <blockquote>
                  <p>BALN - balanced tape technique.&nbsp; If six or less work datasets
                     are provided, this is the technique used.
                  </p>
                  <p>OSCL - Oscillating tape technique.</p>
                  <p>POLY - polyphase tape technique.</p>
                  <p>CRCX - crisscross direct access technique.&nbsp; If more than six
                     work datasets are provided, this is the technique used.
                  </p>
               </blockquote>
            </blockquote>
            <p>[,CORE=xxxxxx]</p>
            <blockquote>
               <p>An optional main storage value which will override the storage
                  allocation set up when the sort/merge program was installed.
               </p>
            </blockquote>
            <p>[,MSG={NO | CC | CP | AC | AP}]</p>
            <blockquote>
               <p>Message output option:</p>
               <ul>
                  <li>NO - no messages are printed.</li>
                  <li>CC - critical messages only are printed.&nbsp; They appear on the console.</li>
                  <li>CP - critical messages only are printed.&nbsp; They appear on the printer.</li>
                  <li>AC - all messages are printed.&nbsp; They appear on the console.</li>
                  <li>AP - all messages are printed.&nbsp; They appear on the printer.</li>
               </ul>
            </blockquote>
            <p>[,DIAG]</p>
            <blockquote>
               <p>Only for use in problem determination.&nbsp; It should never be used for normal sort or merge jobs, as it degrades sort/merge
                  performance.&nbsp; It causes the program to print diagnostic messages and control
                  cards.&nbsp; If the program terminates in the sort or merge phases with a critical
                  message, use of this parameter also produces an OCl abnormal termination dump for
                  diagnostic use.
               </p>
            </blockquote>
         </blockquote>
      </blockquote>
      <p>&nbsp;</p>
      <h3>Examples</h3>
      <blockquote>
         <table width="75%" cellspacing="1" border="1">
            <tbody><tr>
               <td width="33%">
                  <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="SORTj01"></a>Sort
                     1 tape dataset, creating a disk dataset
               </p></td>
            </tr>
            <tr>
               <td width="33%">
                  <pre><b>//SORT     JOB 1,'SORT-1',CLASS=A,MSGCLASS=X                         
//SORT     EXEC PGM=SORT,REGION=4M,PARM='MSG=AP'                     
//SYSOUT    DD SYSOUT=*                                              
//SORTLIB   DD DSN=SYSC.SORTLIB,DISP=SHR                            
//SORTIN    DD DSN=STATIS.DMTD,UNIT=TAPE,VOL=SER=018352,LABEL=(1,SL), 
//             DCB=(RECFM=FB,LRECL=135,BLKSIZE=1350)                 
//SORTOUT   DD DISP=(,CATLG,DELETE),DSN=HMVS01.STATIS.DATA,          
//             DCB=(RECFM=FB,LRECL=135,BLKSIZE=23355),               
//             SPACE=(CYL,(3),RLSE),UNIT=SYSDA,VOL=SER=MVS385        
//SYSIN     DD *                                                     
 SORT FIELDS=(1,8,ZD,A)                                              
 RECORD TYPE=F,LENGTH=(135)                                          
 END                                                                 
/*                                                                   
//SORTWK01  DD UNIT=SORTDA,SPACE=(CYL,(50,50))
//SORTWK02  DD UNIT=SORTDA,SPACE=(CYL,(50,50))
//                                                                  </b></pre>
               </td>
            </tr>
            <tr>
               <td width="33%">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="SORTj02"></a>Sort
                  2 tape datasets (implicit merge), creating a disk dataset
               </td>
            </tr>
            <tr>
               <td width="33%">
                  <pre><b>//SORT     JOB 1,'SORT-2',CLASS=A,MSGCLASS=X                    
//SORT     EXEC PGM=SORT,REGION=4M,PARM='MSG=AP'                
//SYSOUT    DD SYSOUT=*                                         
//SORTLIB   DD DSN=SYSC.SORTLIB,DISP=SHR                        
//SORTIN    DD DSN=STATIS.DMTD.PH1,UNIT=TAPE,VOL=SER=025972, <font color="#0000FF">in1</font>    
//             LABEL=(1,SL),                                    
//             DCB=(RECFM=FB,LRECL=135,BLKSIZE=1350)            
//          DD DSN=STATIS.DMTD.PH2,UNIT=TAPE,VOL=SER=010877, <font color="#0000FF">in2</font>    
//             LABEL=(1,SL),                                    
//             DCB=(RECFM=FB,LRECL=135,BLKSIZE=1350)            
//SORTOUT   DD DISP=(,CATLG,DELETE),DSN=HMVS02.STATIS.DATA,     
//             DCB=(RECFM=FB,LRECL=135,BLKSIZE=23355),          
//             SPACE=(CYL,(6),RLSE),UNIT=SYSDA,VOL=SER=MVS385   
//SYSIN     DD *                                                
 SORT FIELDS=(1,8,ZD,A)                                         
 RECORD TYPE=F,LENGTH=(135)                                     
 END                                                            
/*                                                              
//SORTWK01  DD UNIT=SORTDA,SPACE=(CYL,(50,50))                  
//SORTWK02  DD UNIT=SORTDA,SPACE=(CYL,(50,50))                  
//</b></pre>
               </td>
            </tr>
            <tr>
               <td width="33%">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="SORTj03"></a>Merge
                  2 disk datasets, creating a disk dataset
               </td>
            </tr>
            <tr>
               <td width="33%">
                  <pre><b>//SORT     JOB 1,'SORT-3',CLASS=A,MSGCLASS=X                    
//SORT     EXEC PGM=SORT,REGION=4M,PARM='MSG=AP'                
//SYSOUT    DD SYSOUT=*                                         
//SORTLIB   DD DSN=SYSC.SORTLIB,DISP=SHR                        
//SORTIN01  DD DSN=HMVS02.STATIS.DATA.BL1,DISP=SHR                 
//SORTIN02  DD DSN=HMVS02.STATIS.DATA.BL2,DISP=SHR                 
//SORTOUT   DD DISP=(,CATLG,DELETE),DSN=HMVS02.STATIS.DATA,     
//             DCB=(RECFM=FB,LRECL=135,BLKSIZE=23355),          
//             SPACE=(CYL,(12),RLSE),UNIT=SYSDA,VOL=SER=MVS385  
//SYSIN     DD *                                                
 MERGE FIELDS=(50,15,CH,A)                                      
 RECORD TYPE=F,LENGTH=(135)                                     
 END                                                            
/*                                                              
//                                                              </b></pre>
               </td>
            </tr>
            <tr>
               <td width="33%"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="SORTj04"></a></b>Sort
                  disk dataset on split sequence field
               </td>
            </tr>
            <tr>
               <td width="33%">
                  <pre><b>//SORT     JOB 1,'SORT-4',CLASS=A,MSGCLASS=X                    
//SORT     EXEC PGM=SORT,REGION=4M,PARM='MSG=AP'                
//SYSOUT    DD SYSOUT=*                                         
//SORTLIB   DD DSN=SYSC.SORTLIB,DISP=SHR                        
//SORTIN    DD DSN=HMVS02.STATIS.DATA,DISP=SHR                  
//SORTOUT   DD DISP=(,CATLG,DELETE),DSN=HMVS02.STATIS.RVI01,    
//             DCB=(RECFM=FB,LRECL=135,BLKSIZE=23355),          
//             SPACE=(CYL,(12),RLSE),UNIT=SYSDA,VOL=SER=MVS385  
//SYSIN     DD *                                                
 SORT FIELDS=(80,5,CH,D,1,8,ZD,A)                               
 RECORD TYPE=F,LENGTH=(135)                                     
 END                                                            
/*                                                              
//SORTWK01  DD UNIT=SORTDA,SPACE=(CYL,(50,50))                  
//SORTWK02  DD UNIT=SORTDA,SPACE=(CYL,(50,50))                  
//SORTWK03  DD UNIT=SORTDA,SPACE=(CYL,(50,50))                  
//                                                              </b></pre>
               </td>
            </tr>
            <tr>
               <td width="33%">
                  &nbsp;&nbsp;&nbsp;&nbsp; <a name="SORTj05"></a>Sort disk dataset on split
                  sequence field, all CH data
               </td>
            </tr>
            <tr>
               <td width="33%">
                  <pre><b>//SORT     JOB 1,'SORT-5',CLASS=A,MSGCLASS=X 
//SORT     EXEC PGM=SORT,REGION=4M,PARM='MSG=AP' 
//SYSOUT    DD SYSOUT=* 
//SORTLIB   DD DSN=SYSC.SORTLIB,DISP=SHR 
//SORTIN    DD DISP=SHR,DSN=HMVS01.DF125A5 
//SORTOUT   DD DISP=(,CATLG,DELETE),DSN=HMVS01.DF125A5.SORTED, 
//             DCB=(RECFM=FB,LRECL=125,BLKSIZE=23375), 
//             SPACE=(CYL,(15),RLSE),UNIT=SYSDA,VOL=SER=MVS380 
//SYSIN     DD * 
SORT FIELDS=(80,5,A,2,5,D),FORMAT=CH         <font color="#0000FF">&lt;- both fields are CH, so able to use alternate format SORT statement</font>
RECORD TYPE=F,LENGTH=(125) 
END 
/* 
//SORTWK01  DD UNIT=SORTDA,SPACE=(CYL,(50,50)) 
//SORTWK02  DD UNIT=SORTDA,SPACE=(CYL,(50,50)) 
//SORTWK03  DD UNIT=SORTDA,SPACE=(CYL,(50,50)) 
// </b></pre>
               </td>
            </tr>
         </tbody></table>
      </blockquote>
      <p><font size="1">Source:&nbsp; <a href="http://http//bitsavers.org/pdf/ibm/360/os/R21.0_Mar72/GC28-6543-8_OS_Sort_Merge_Rel_21_Feb73.pdf" target="_blank">GC28-6543-8
         OS Sort/Merge Program</a></font>
      </p>
      <hr size="8" noshade="noshade">
      <h2><a name="SUPERLST"></a>SUPERLST <font size="2">[written by R. F. Morse,
         located in SYSC.LINKLIB]</font>
      </h2>
      <p>Used to provide VTOC listing, with optional Partitioned dataset directory
         information and volume allocation map.&nbsp; SUPERLST was originally
      written by R. F. Morse and is now maintained by Greg Price
         and is located in File #134 of the CBT
         tape.&nbsp; SUPERLST requires the following DD statements:
      </p>
      <ul>
         <li>SYSPRINT - defines a sequential output dataset.</li>
         <li>VOL????? - defines the DASD volume to be listed.</li>
      </ul>
      <blockquote>
         <p>Any number of DD statements may be provided, as long as the name begins with
            'VOL'.&nbsp; SUPERLST will process all DD names in a single execution.
         </p>
      </blockquote>
      <h3>&nbsp;</h3>
      <h3>Program Parameter (PARM= on EXEC statement)</h3>
      <blockquote>
         <p>The PARM parameter on the EXEC statement is used to supply optional
            parameters to the SUPERLST program.&nbsp; The parameters are:
         </p>
         <blockquote>
            <p>MAP</p>
            <blockquote>
               <p>Specifies that after the dataset name and attribute list (in collating sequence order) a volume space
                  (allocation) map is to be produced.&nbsp;
               </p>
            </blockquote>
            <p>PDS</p>
            <blockquote>
               <p>Specifies that the directories of all Partitioned datasets found on the volume are to be opened and read.&nbsp;
                  Statistics such as member and directory block counts are reported.&nbsp; If&nbsp;
                  DUMP was also specified then the contents of the directories are also dumped.
               </p>
            </blockquote>
            <p>DUMP</p>
            <blockquote>
               <p>Specifies that the report is to also include a hex dump of each VTOC entry.</p>
            </blockquote>
         </blockquote>
      </blockquote>
      <h3>&nbsp;</h3>
      <h3>Control Statements</h3>
      <blockquote>
         <p>SUPERLST uses no control statements.</p>
      </blockquote>
      <h3><br>
         Examples
      </h3>
      <blockquote>
         <table width="75%" cellspacing="1" border="1">
            <tbody><tr>
               <td width="33%">
                  <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="SUPERLSTj01"></a>List
                     VTOCs and PDS directories on two volumes
               </p></td>
            </tr>
            <tr>
               <td>
                  <pre><b>//SUPERLST JOB (0001),SUPERLST,CLASS=S,MSGCLASS=X               
//SUPERLST EXEC PGM=SUPERLST,REGION=2048K,PARM=''  PDS/MAP/DUMP 
//SYSPRINT DD  SYSOUT=*                                         
//VOLUME1  DD  DISP=SHR,UNIT=SYSALLDA,VOL=SER=PUB001            
//VOLUME2  DD  DISP=SHR,UNIT=SYSALLDA,VOL=SER=PUB000
//                                                              </b></pre>
               </td>
            </tr>
         </tbody></table>
      </blockquote>
      <hr size="8" noshade="noshade">
      <h2><a name="SYSREPRO"></a>SYSREPRO <font size="2">[written by Bill Godfrey, located in
         SYSC.LINKLIB]</font>
      </h2>
      <p>Used for copying data records from a sequential dataset or member of a
         partitioned dataset to another sequential dataset or member.&nbsp; It is faster
         than IEBGENER and prints a summary of the copy operation including the record
         counts.&nbsp; If the output DD does not have DCB attributes supplied, the
         attributes will be copied from the input dataset.&nbsp; If the BLKSIZE is
         omitted, the system determined BLKSIZE will be used.&nbsp; The program was written by Bill
         Godfrey and the source may be found in File #316 of the CBT Tape.&nbsp; SYSREPRO
         requires the following DD statements:
      </p>
      <ul>
         <li>SYSPRINT - defines a sequential output message dataset.</li>
         <li>SYSUT1 - defines the input sequential dataset or partitioned dataset
            member.
         </li>
         <li>SYSUT2 - defines the output sequential dataset or partitioned dataset
            member.
         </li>
      </ul>
      <h3>&nbsp;</h3>
      <h3>Program Parameter (PARM= on EXEC statement)</h3>
      <blockquote>
         <p>The optional PARM is used to modify the operation of SYSREPRO.&nbsp; The
            values and their function are:
         </p>
         <blockquote>
            <p>n1,n2,n3,n4</p>
            <blockquote>
               <p>If n1 is specified, that number of records will be copied from the input
                  dataset to the output dataset.
               </p>
               <p>If n2 is specified, that number of records will be skipped before copying
                  begins
               </p>
               <p>If n3 and n4 are specified, only n4 out of every n3 records are to be
                  copied.
               </p>
            </blockquote>
            <p>&nbsp;</p>
         </blockquote>
      </blockquote>
      <h3>Control Statements</h3>
      <blockquote>
         <p>SYSREPRO uses no control statements.</p>
      </blockquote>
      <h3>&nbsp;</h3>
      <h3>Examples</h3>
      <blockquote>
         <table width="75%" cellspacing="1" border="1">
            <tbody><tr>
               <td width="33%">
                  <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="SYSREPROj01"></a>Print
                     a card dataset
               </p></td>
            </tr>
            <tr>
               <td>
                  <pre><b>//SYSREPRO JOB (001),'SYSREPRO-1',CLASS=A,MSGCLASS=X       
//SYSREPRO EXEC PGM=SYSREPRO,REGION=512K                   
//SYSPRINT DD  SYSOUT=*                                    
//SYSUT1   DD  UNIT=01C,DCB=(RECFM=FB,LRECL=80,BLKSIZE=80) 
//SYSUT2   DD  SYSOUT=*                                    
//                                                         </b></pre>
               </td>
            </tr>
            <tr>
               <td width="33%">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="SYSREPROj02"></a>Copy
                  a sequential dataset, disk to disk
               </td>
            </tr>
            <tr>
               <td width="33%">
                  <pre><b>//SYSREPRO JOB (001),'SYSREPRO-2',CLASS=A,MSGCLASS=X       
//SYSREPRO EXEC PGM=SYSREPRO,REGION=512K                   
//SYSPRINT DD  SYSOUT=*                                    
//SYSUT1   DD  DISP=SHR,DSN=HMVS01.SORTDATA.TRE             
//SYSUT2   DD  DISP=(,CATLG),DSN=HMVS01.SORTDATA.QUATRO,    
//             UNIT=SYSDA,VOL=SER=PUB000,                  
//             DCB=(JAY01.SORTDATA.TRE),                   
//             SPACE=(CYL,(12),RLSE)                       
//                                                         </b></pre>
               </td>
            </tr>
            <tr>
               <td width="33%">
                  <b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="SYSREPROj03"></a></b>Copy
                  a tape dataset to disk
               </td>
            </tr>
            <tr>
               <td width="33%">
                  <pre><b>//SYSREPRO JOB (001),'SYSREPRO-3',CLASS=A,MSGCLASS=X    
//SYSREPRO EXEC PGM=SYSREPRO,REGION=512K                
//SYSPRINT DD  SYSOUT=*                                 
//SYSUT1   DD  DISP=OLD,DSN=TEST.D0135.ONE,             
//             UNIT=TAPE,VOL=SER=22008C,LABEL=(1,SL)    
//SYSUT2   DD  DISP=(,CATLG),DSN=JAY01.SORTTEST.DATA,     
//             UNIT=SYSDA,VOL=SER=PUB000,               
//             SPACE=(CYL,(12),RLSE),                   
//             DCB=(JAY01.POLICY.ONE)                 
//                                                      </b></pre>
               </td>
            </tr>
            <tr>
               <td width="33%">
                  <b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="SYSREPROj04"></a></b>Add
                  member to existing partitioned dataset from cards
               </td>
            </tr>
            <tr>
               <td width="33%">
                  <pre><b>//SYSREPRO JOB (001),'SYSREPRO-4',CLASS=A,MSGCLASS=X       
//SYSREPRO EXEC PGM=SYSREPRO,REGION=512K                   
//SYSPRINT DD  SYSOUT=*                                    
//SYSUT1   DD  UNIT=01C,DCB=BLKSIZE=80                     
//SYSUT2   DD  DISP=MOD,DSN=JAY01.VSAMIO.SOURCE(NEWPROG)   
//                                                         </b></pre>
               </td>
            </tr>
         </tbody></table>
      </blockquote>
      <hr size="8" noshade="noshade">
      <h2><a name="TAPEMAP"></a>TAPEMAP <font size="2">[originally from UCLA, last
         modified by Sam Golob, located in SYSC.LINKLIB]</font>
      </h2>
      <p>Used to read a tape volume and report everything it contains, including
         detailed information about file contents when the creation program is
         recognized.&nbsp; The version currently installed is 2.5 and the source may be
         found on File #299 of the CBT Tape.&nbsp; TAPEMAP requires the following DD
         statements:
      </p>
      <ul>
         <li>SYSPRINT - defines a sequential output dataset (list of files found on
            tape).
         </li>
         <li>SYSPRNT2 - defines a sequential output dataset (detailed information about
            individual files).
         </li>
         <li>SYSUT1 - defines the tape volume to be mapped.</li>
      </ul>
      <h3>&nbsp;</h3>
      <h3>Control Statements</h3>
      <blockquote>
         <p>TAPEMAP uses no control statements.</p>
      </blockquote>
      <h3><br>
         Examples
      </h3>
      <blockquote>
         <table width="75%" cellspacing="1" border="1">
            <tbody><tr>
               <td width="33%">
                  <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="TAPEMAPj01"></a>Analyze
                     tape and report on files and their contents
               </p></td>
            </tr>
            <tr>
               <td>
                  <pre><b>//TAPEMAP  JOB (001),'TAPEMAP',CLASS=A,MSGCLASS=X        
//TAPEMAP  EXEC PGM=TAPEMAP,REGION=512K,PARM='TEST'          
//SYSPRINT  DD SYSOUT=*                                      
//SYSPRNT2  DD SYSOUT=*                                      
//SYSUT1    DD DSN=T000001,                                  
//             VOL=SER=000001,                               
//             DISP=(OLD,KEEP),                              
//             LABEL=(1,BLP),                                
//             UNIT=(TAPE,,DEFER)                            
//                                                                                    </b></pre>
               </td>
            </tr>
         </tbody></table>
      </blockquote>
      <hr size="8" noshade="noshade">
      <h2><a name="TAPESCAN"></a>TAPESCAN <font size="2">[written by Will Daland,
         located in SYSC.LINKLIB]</font>
      </h2>
      <p>Used to read a tape volume and report an overview of the datasets on a tape,
         copy files and recover data past the first end of volume indicator.&nbsp;
         Information includes record and byte count, length estimate, display fo the
         first 100 bytes of the first records of each dataset, and the physical tape file
         number.&nbsp; Original author was Will Daland, but modified by others; the
         source may be found on File #102 of the CBT Tape.&nbsp; <b><font color="#0000FF">I
         would suggest taking a look at COPYMODS.</font></b>
      </p>
      <p>TAPESCAN requires the
         following DD statements:
      </p>
      <ul>
         <li>SYSPRINT - defines a sequential output dataset (list of files found on
            tape).
         </li>
         <li>INPUT - defines the tape volume to be read.</li>
         <li>OUTPUT - optionally defines a tape volume to receive copy of input tape
            volume.
         </li>
      </ul>
      <h3>&nbsp;</h3>
      <h3>Program Parameter (PARM= on EXEC statement)</h3>
      <blockquote>
         <p>The PARM is used to supply all parameters to TAPESCAN.&nbsp; The parameter
            values are:
         </p>
         <blockquote>
            <p>COPY</p>
            <blockquote>
               <p>Create a copy of the input datasets, labels, and tape marks on OUTPUT
                  DD.&nbsp; NOCOUNT may not be specified when COPY is specified.&nbsp; The
                  default is COPY off.&nbsp;
               </p>
            </blockquote>
            <p>EOVMOD</p>
            <blockquote>
               <p>Places the INPUT data to be copied after the last dataset on OUTPUT.&nbsp;
                  This parameter implies COPY.&nbsp; NOCOUNT may not be specified when EOVMOD is
                  specified.&nbsp; The default is EOVMOD off.&nbsp;
               </p>
            </blockquote>
            <p>ERRLIMn</p>
            <blockquote>
               <p>The maximum number of I/O errors allowed before processing is terminated is
                  specified by n.&nbsp; The default is ERRLIM50.&nbsp;
               </p>
            </blockquote>
            <p>LISTn</p>
            <blockquote>
               <p>The number of blocks from each dataset which have records printed is
                  specified by n.&nbsp; The default is 4.&nbsp;
               </p>
            </blockquote>
            <p>MAXEOVn</p>
            <blockquote>
               <p>Processing will continue until n end of volume indicators have been
                  found.&nbsp; Processing will stop when either MAXTMn or MAXEOVn is
                  exceeded.&nbsp; If SKIPEOVn is used, then MAXEOVn must be one greater than
                  SKIPEOVn.&nbsp; The default value is 1.
               </p>
            </blockquote>
            <p>MAXTMn</p>
            <blockquote>
               <p>Stop processing after n tape marks have been encountered.&nbsp; This will
                  not continue beyond MAXEOVn.&nbsp; The default is to process until MAXEOVn is
                  reached.
               </p>
            </blockquote>
            <p>NOCOUNT</p>
            <blockquote>
               <p>To save I/O time, the counting feature may be turned off with NOCOUNT.&nbsp;
                  The number of physical blocks, the maximum, average, and minimum block sizes,
                  the length and the total number of bytes processed will not be reported.&nbsp;
                  This parameter may not be used with COPY or EOVMOD.&nbsp; The default is
                  NOCOUNT off.&nbsp;
               </p>
            </blockquote>
            <p>NOHEX</p>
            <blockquote>
               <p>The hexadecimal equivalent of the blocks printed from each record will not
                  be produced.&nbsp; The default is NOHEX off.&nbsp;
               </p>
            </blockquote>
            <p>NOLIST</p>
            <blockquote>
               <p>The content of data records will not be printed.&nbsp; The default is
                  NOLIST off.&nbsp;
               </p>
            </blockquote>
            <p>NOSUMMARY</p>
            <blockquote>
               <p>The summary of datasets for Standard Label tape will not be printed.&nbsp;
                  The default is NOSUMMARY off.&nbsp;
               </p>
            </blockquote>
            <p>NOVOLSER</p>
            <blockquote>
               <p>During a COPY operation between two Standard Label tapes, the volume header
                  label will not be copied.&nbsp; The default is NOVOLSER off.&nbsp;
               </p>
            </blockquote>
            <p>SKIPEOVn</p>
            <blockquote>
               <p>Processing will start after n number of end of volume indicators have been
                  encountered.&nbsp; Ensure that MAXEOVn is at least one greater than SKIPEOVn.&nbsp;
                  The default is 0.&nbsp;
               </p>
            </blockquote>
            <p>SKIPTMn</p>
            <blockquote>
               <p>Start processing after n tape marks have been encountered.&nbsp; Processing
                  will not start past the MAXEOVn.&nbsp; When both SKIPTMn and SKIPEOVn are
                  specified the maximum amount of skipping is done.&nbsp; The default is
                  0.&nbsp;
               </p>
            </blockquote>
            <p>VTOC</p>
            <blockquote>
               <p>For a Standard Label tape, produce only the VTOC report.&nbsp;</p>
            </blockquote>
         </blockquote>
      </blockquote>
      <p>&nbsp;</p>
      <h3>Control Statements</h3>
      <blockquote>
         <p>TAPESCAN uses no control statements.</p>
      </blockquote>
      <h3><br>
         Examples
      </h3>
      <blockquote>
         <table width="75%" cellspacing="1" border="1">
            <tbody><tr>
               <td width="33%">
                  <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="TAPESCANj01"></a>Print
                     dataset VTOC for SL tape
               </p></td>
            </tr>
            <tr>
               <td>
                  <pre><b>//TAPESCAN JOB 1,'TAPESCAN-1',CLASS=A,MSGCLASS=X            
//TAPESCAN EXEC PGM=TAPESCAN,REGION=1024K,                  
//   PARM='VTOC'                                            
//SYSPRINT  DD SYSOUT=*                                     
//INPUT     DD DSN=DUMP.JAY01,                              
//             UNIT=(TAPE,,DEFER),DISP=OLD,VOL=SER=22003A,  
//             DCB=(EROPT=ACC),LABEL=(,SL)                  
//                                                          </b></pre>
               </td>
            </tr>
            <tr>
               <td>
                  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="TAPESCANj02"></a>Copy
                  4th and 5th datasets to second tape
               </td>
            </tr>
            <tr>
               <td>
                  <pre><b>//TAPESCAN JOB 1,'TAPESCAN-2',CLASS=A,MSGCLASS=X            
//*
//* Copy the 4th and 5th files of a SL tape to the 2nd and 3rd
//* files to a tape which already contains 1 file. Do not copy 
//* the volume header record or produce the hex output. List
//* the first 20 records of the input datasets. Stop processing
//* after 5 I/O errors.
//*
//TAPESCAN EXEC PGM=TAPESCAN,REGION=1024K,                  
//   PARM='COPY,NOVOLSER,EOVMOD,SKIPTM10,MAXTM16,LIST20,NOHEX'                                            
//SYSPRINT  DD SYSOUT=*                                     
//INPUT     DD UNIT=2400-7,DISP=OLD,
//             DCB=(TRTCH=ET,DEN=1,ERROPT=ACC),VOL=SER=TRACK7
//OUTPUT    DD UNIT=2400-4,LABEL=2,VOL=SER=OTPTTP
//                                                       </b></pre>
               </td>
            </tr>
         </tbody></table>
      </blockquote>
      <hr size="8" noshade="noshade">
      <h2><a name="UNUPDTE"></a>UNUPDTE <font size="2">[originally from SPLA PL1 MODs
         tape, located in SYSC.LINKLIB]</font>
      </h2>
      <p>Used for sequentializing a partitioned dataset.&nbsp; All members of a partitioned dataset are used to create a
         sequential dataset; each member is preceded by an ADD control statement.&nbsp;
         UNUPDTE will process Fixed or Variable length records, with any LRECL allowed by
         MVS.&nbsp; The resulting file may then be input to UPDTE, IEBUPDTE, or PDSLOAD to construct a new partitioned
         dataset containing the offloaded members.&nbsp; The most recent version of
         UNUPDTE is located in File #093 of the CBT
         tape.&nbsp; The program was updated by Art Tansky.&nbsp; UNUPDTE requires the following DD statements:
      </p>
      <ul>
         <li>SYSPRINT - defines a sequential output message dataset.</li>
         <li>SYSUT1 - defines the input partitioned dataset.</li>
         <li>SYSUT2 - defines the output sequential dataset.</li>
      </ul>
      <p><b><font color="#0000FF">I would also suggest taking a look at OFFLOAD.</font></b></p>
      <h3>&nbsp;</h3>
      <h3>Control Statements</h3>
      <blockquote>
         <p>UNUPDTE uses no control statements.</p>
      </blockquote>
      <h3>&nbsp;</h3>
      <h3>Examples</h3>
      <blockquote>
         <table width="75%" cellspacing="1" border="1">
            <tbody><tr>
               <td width="33%">
                  <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="UNUPDTEj01"></a>Offload members of a partitioned dataset
                     to sequential dataset
               </p></td>
            </tr>
            <tr>
               <td>
                  <pre><b>//UNUPDTE  JOB (01),'UNUPDTE-1',CLASS=S,MSGCLASS=X                 
//UNUPDTE  EXEC PGM=UNUPDTE,REGION=1024K                           
//SYSPRINT  DD SYSOUT=*                                            
//SYSUT1    DD DISP=SHR,DSN=SYSC.VSAMIO.SOURCE                     
//SYSUT2    DD DISP=NEW,DSN=SYSC.VSAMIO.SOURCE,                    
//             UNIT=TAPE,VOL=SER=SCRTCH,                           
//             DCB=(DSORG=PS,RECFM=FB,LRECL=80,BLKSIZE=3120,DEN=3) 
//                                                                 </b></pre>
               </td>
            </tr>
         </tbody></table>
      </blockquote>
      <hr size="8" noshade="noshade">
      <h2><a name="UPDTE"></a>UPDTE <font size="2">[originally from SPLA PL1 MODs
         tape, located in SYSC.LINKLIB]</font>
      </h2>
      <p>Used for recreating a partitioned dataset from a sequential dataset that
         contains ADD control statements interspersed with data records.&nbsp; UPDTE will
         process Fixed or Variable length records, with any LRECL allowed by MVS.&nbsp; The most recent version of
         UPDTE is located in File #093 of the CBT
         tape.&nbsp; The program was last updated by R. E. Styma.&nbsp; UPDTE
         requires the following DD statements:
      </p>
      <ul>
         <li>SYSPRINT - defines a sequential output message dataset.</li>
         <li>SYSIN - defines the input sequential dataset.</li>
         <li>SYSUT2 - defines the output partitioned dataset.</li>
      </ul>
      <p><b><font color="#0000FF">I would also suggest taking a look at PDSLOAD.</font></b></p>
      <h3>&nbsp;</h3>
      <h3>Control Statements</h3>
      <blockquote>
         <p>UPDTE uses no control statements.</p>
      </blockquote>
      <h3>&nbsp;</h3>
      <h3>Examples</h3>
      <blockquote>
         <table width="75%" cellspacing="1" border="1">
            <tbody><tr>
               <td width="33%">
                  <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="UPDTEj01"></a>Load partitioned dataset
                     from sequential dataset
               </p></td>
            </tr>
            <tr>
               <td>
                  <pre><b>//UPDTE    JOB (SYS),'UPDTE-1',CLASS=S,MSGCLASS=X             
//UPDTE    EXEC PGM=UPDTE,REGION=1024K                        
//SYSPRINT  DD SYSOUT=*                                       
//SYSIN     DD DISP=OLD,DSN=SYSC.VSAMIO.SOURCE,               
//             UNIT=TAPE,VOL=SER=22009A,LABEL=(,SL)           
//SYSUT2   DD  DISP=(,KEEP,DELETE),DSN=HMVS02.VSAMIO.SOURCE,  
//             UNIT=SYSDA,VOL=SER=TST380,                     
//             SPACE=(TRK,(180,,30),RLSE),                    
//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=23440)          
//</b></pre>
               </td>
            </tr>
         </tbody></table>
      </blockquote>
      <hr size="8" noshade="noshade">
      <h2><a name="VTOCLIST"></a>VTOCLIST <font size="2">[written by P. E. Havercan,
         located in SYSC.LINKLIB]</font>
      </h2>
      <p>Used to provide formatted VTOC listing.&nbsp; The most recent version of
         VTOCLIST is located in File #343 of the CBT Overflow tape.&nbsp; The program was
         last updated by John Kalinich.&nbsp; VTOCLIST requires the following DD statements:
      </p>
      <ul>
         <li>SYSPRINT - defines a sequential output dataset.</li>
         <li>SYSUT1 - defines the DASD volume to be listed.</li>
      </ul>
      <p><b><font color="#0000FF">I
         would also suggest taking a look at SUPERLST.</font></b>
      </p>
      <h3>&nbsp;</h3>
      <h3>Program Parameter (PARM= on EXEC statement)</h3>
      <blockquote>
         <p>The PARM parameter on the EXEC statement may be used to supply an optional
            parameter to the VTOCLIST program.&nbsp; The parameter is:
         </p>
         <blockquote>
            <p>PDS</p>
            <blockquote>
               <p>Specifies that the creation date and last reference date will be
                  replaced with directory blocks allocated and used.&nbsp; Use of the PDS
                  parameter may cause waits for datasets reserved/in use by other programs.
               </p>
            </blockquote>
         </blockquote>
      </blockquote>
      <h3>&nbsp;</h3>
      <h3>Control Statements</h3>
      <blockquote>
         <p>VTOCLIST uses no control statements.</p>
      </blockquote>
      <h3><br>
         Examples
      </h3>
      <blockquote>
         <table width="75%" cellspacing="1" border="1">
            <tbody><tr>
               <td width="33%">
                  <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="VTOCLISTj01"></a>List
                     VTOC for DASD volume
               </p></td>
            </tr>
            <tr>
               <td width="33%">
                  <pre><b>//VTOCLIST JOB (1),VTOCLIST,CLASS=A,MSGCLASS=X         
//VTOCLIST EXEC PGM=VTOCLIST'                          
//SYSPRINT  DD SYSOUT=*                                
//SYSUT1    DD DISP=OLD,UNIT=SYSALLDA,VOL=SER=MVSRES   
//                                                     </b></pre>
               </td>
            </tr>
            <tr>
               <td width="33%">
                  <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="VTOCLISTj02"></a>List
                     VTOC for DASD volume with PDS directory information
               </p></td>
            </tr>
            <tr>
               <td>
                  <pre><b>//VTOCLIST JOB (1),VTOCLIST,CLASS=A,MSGCLASS=X        
//VTOCLIST EXEC PGM=VTOCLIST,PARM='PDS'               
//SYSPRINT  DD SYSOUT=*                               
//SYSUT1    DD DISP=OLD,UNIT=SYSALLDA,VOL=SER=PUB000  
//</b></pre>
               </td>
            </tr>
         </tbody></table>
      </blockquote>
      <hr size="8" noshade="noshade">
      <h2><a name="XMIT370"></a>XMIT370 <font size="2">[written by Jim Morrison,
         located in SYSC.LINKLIB]</font>
      </h2>
      <p>Used to read partitioned datasets to produce XMIT files equivalent to the TSO/E
         TRANSMIT command processor or a similar facility.&nbsp; The resulting XMIT
         dataset can be processed using the TSO/E RECEIVE command processor, Hercules
         dasdload, RECV370, or any of the other UnXmit programs as detailed at <a href="http://planetmvs.com/" target="_blank">http://planetmvs.com</a>
         on the UnXmit Information Exchange page.&nbsp; XMIT370 was written by Jim
         Morrison
         and is located in File #571 of the CBT
         tape.&nbsp; RECV370
         requires the following DD statements:
      </p>
      <ul>
         <li>SYSPRINT - defines a sequential output message dataset (IEBCOPY messages).</li>
         <li>XMITLOG - defines a sequential output message dataset (XMIT370 messages).</li>
         <li>SYSIN - unused, but required by IEBCOPY.</li>
         <li>SYSUT1 - defines partitioned input dataset.</li>
         <li>SYSUT2 - work dataset.</li>
         <li>XMITOUT - defines sequential output dataset (XMIT).</li>
      </ul>
      <h3>&nbsp;</h3>
      <h3>Control Statements</h3>
      <blockquote>
         <p>XMIT370 uses no control statements.</p>
      </blockquote>
      <h3>&nbsp;</h3>
      <h3>Examples</h3>
      <blockquote>
         <table width="75%" cellspacing="1" border="1">
            <tbody><tr>
               <td width="33%">
                  <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="XMIT370j01"></a>Pack
                     partitioned dataset into XMIT
               </p></td>
            </tr>
            <tr>
               <td>
                  <pre><b>//XMIT370  JOB (001),'XMIT370',CLASS=A,MSGCLASS=X                     
//XMIT370  PROC                                                       
//XMIT370  EXEC PGM=XMIT370,REGION=1024K                              
//XMITLOG   DD SYSOUT=*                     XMIT370 OUTPUT MESSAGES   
//SYSPRINT  DD SYSOUT=*                     IEBCOPY OUTPUT MESSAGES   
//SYSIN     DD DUMMY                        IEBCOPY REQUIRES          
//SYSUT1    DD DDNAME=XMITIN                INPUT DATASET             
//SYSUT2    DD UNIT=SYSDA,                  WORK DATASET              
//             SPACE=(CYL,(10,10)),                                   
//             DCB=BLKSIZE=5600                                       
//XMITOUT   DD DDNAME=XMITOUT               OUTPUT DATASET            
//         PEND                                                       
//XMIT1    EXEC XMIT370                                               
//XMITIN   DD  DISP=SHR,DSN=JAY01.COBOL.XMIT     &lt;- INPUT             
//SYSUT2   DD  DSN=HMVS01.MVTCOBOL.SOURCE,       &lt;- OUTPUT            
//             VOL=SER=MVS381,UNIT=SYSDA,                             
//             SPACE=(CYL,(5,,15),RLSE),                              
//             DISP=(,CATLG)                                          
//                                                                    </b><b>                                                 </b></pre>
               </td>
            </tr>
         </tbody></table>
      </blockquote>
      <hr size="8" noshade="noshade">
      <h2><a name="ZAPDSCB"></a>ZAPDSCB <font size="2">[written by Dave Phillips,
         located in SYSC.LINKLIB]</font>
      </h2>
      <p>Used to update DSCBs for specified datasets with values supplied on DD
         statements.&nbsp; The DSCB is updated without regard to the actual dataset
         format.&nbsp; ZAPDSCB was written by Dave Phillips
         and is located in File #163 of the CBT
         tape.&nbsp; ZAPDSCB
         requires the following DD statements:
      </p>
      <ul>
         <li>SNAP - defines a sequential output dataset to receive a snap dump if an
            I/O error occurs.
         </li>
         <li>ZAP????? - defines datasets whose DSCBs are to be modified.</li>
      </ul>
      <blockquote>
         <p>Any number of DD statements may be provided, as long as the name begins with
            'ZAP'.&nbsp;&nbsp;
         </p>
      </blockquote>
      <p>The values which may be changed are:</p>
      <ul>
         <li>Expiration date - can be set to zero via RETPD=0</li>
         <li>ASM2 use count - can be set to zero via FCB=ZUSE</li>
         <li>Secondary space amount - set via SPACE=(TRK,(0,##))</li>
         <li>DSORG</li>
         <li>RECFM</li>
         <li>BLKSIZE</li>
         <li>LRECL</li>
         <li>KEYLEN</li>
         <li>RKP</li>
         <li>OPTCD</li>
         <li>Password protection - can be removed via FCB=NOPW or set via
            LABEL=(,,PASSWORD) and LABEL=(,,NOPWREAD)
         </li>
      </ul>
      <p> <b><font color="#0000FF">I
         would also suggest taking a look at FIXDSCB.</font></b>
      </p>
      <p>&nbsp;</p>
      <h3>Control Statements</h3>
      <blockquote>
         <p>ZAPDSCB uses no control statements.</p>
      </blockquote>
      <h3>&nbsp;</h3>
      <h3>Examples</h3>
      <blockquote>
         <table width="75%" cellspacing="1" border="1">
            <tbody><tr>
               <td width="33%">
                  <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="ZAPDSCBj01"></a>Modify
                     DSCB fields for dataset
               </p></td>
            </tr>
            <tr>
               <td>
                  <pre><b>//ZAPDSCB  JOB (001),'ZAPDSCB',CLASS=A,MSGCLASS=X       
//ZAPDSCB  EXEC PGM=ZAPDSCB                             
//SNAP      DD SYSOUT=*     SNAP DUMP WHEN I/O ERROR    
//SYSUDUMP  DD SYSOUT=*     ABEND DUMP OTHER ERRORS     
//ZAP0000   DD UNIT=3350,VOL=SER=SRC000,DISP=SHR,       
//             DSN=MVSSRC.EREPSY.F01,DCB=DSORG=PS       
//                                                      </b></pre>
               </td>
            </tr>
         </tbody></table>
      </blockquote>
      <hr size="8" noshade="noshade">
      <h2><a name="ZTDUMPTP"></a>ZTDUMPTP <font size="2">[written by Jim Marshall,
         located in SYSC.LINKLIB]</font>
      </h2>
      <p>Used to print data records from datasets on tape.&nbsp; ZTDUMPTP was written by
         Jim Marshall
         and is located in File #316 of the CBT
         tape.&nbsp; ZTDUMPTP
         requires the following DD statements:
      </p>
      <ul>
         <li>SYSPRINT - defines a sequential output message dataset.</li>
         <li>SYSIN - defines the sequential input dataset that contains ZTDUMPTP Control
            statements.
         </li>
         <li>FILE - defines the tape volume.</li>
      </ul>
      <h3>&nbsp;</h3>
      <h3>Control Statements</h3>
      <blockquote>
         <p><a name="ZTDUMPTPfiles"></a>FILES=n</p>
         <p>The FILES control statement specifies the number of consecutive files to dump.&nbsp; The default value
            is 1.
         </p>
         <hr color="#808080">
         <p><a name="ZTDUMPTPrec"></a>REC=n</p>
         <p>The REC control statement specifies the number of consecutive records to dump.&nbsp; The default
            value is ALL.
         </p>
         <hr color="#808080">
         <p><a name="ZTDUMPTPskpfil"></a>SKPFIL=n</p>
         <p>The SKPFIL control statement specifies the number of consecutive files to skip.&nbsp; The default value
            is 0.
         </p>
         <hr color="#808080">
         <p><a name="ZTDUMPTPskprec"></a>SKPREC=n</p>
         <p>The SKPREC control statement specifies the number of consecutive records to skip.&nbsp; The default
            value is 0.
         </p>
         <hr color="#808080">
         <p><a name="ZTDUMPTPprint"></a>PRINT=YES</p>
         <p>The PRINT control statement specifies character format of data record is to be printed alongside hex
            dump.&nbsp; The default is NO.
         </p>
         <hr color="#808080">
         <p><a name="ZTDUMPTPrun"></a>RUN=YES</p>
         <p>The RUN control statement specifies the tape is to be rewound and unloaded before processing next
            control card.&nbsp; The default is NO.&nbsp; Allows for processing multiple
            tapes in a single execution.
         </p>
         <hr color="#808080">
         <p><a name="ZTDUMPTPredun"></a>REDUN=NO</p>
         <p>The REDUN control statement specifies exit to end of job on redundant record.&nbsp; The default is
            NO.&nbsp; When set to YES, all redundant records are indicated.
         </p>
         <hr color="#808080">
         <p><a name="ZTDUMPTPmode"></a>MODE=nn</p>
         <p>The MODE control statement specifies the tape drive mode set command code.&nbsp;&nbsp;</p>
      </blockquote>
      <h3>&nbsp;</h3>
      <h3>Examples</h3>
      <blockquote>
         <table width="75%" cellspacing="1" border="1">
            <tbody><tr>
               <td width="33%">
                  <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="ZTDUMPTPj01"></a>Dump
                     and print first 20 records from first 5 files on tape
               </p></td>
            </tr>
            <tr>
               <td>
                  <pre><b>//ZTDUMPTP JOB (1),'ZTDUMPTP',CLASS=A,MSGCLASS=X                  
//ZTDUMPTP EXEC PGM=ZTDUMPTP                                       
//FILE     DD UNIT=TAPE,DSN=ANYTAPE,VOL=SER=000000,LABEL=(1,BLP) 
//SYSPRINT DD SYSOUT=*                                           
//SYSIN    DD *                                                  
  FILES=5,REC=20,PRINT=YES 
//                                                               </b></pre>
               </td>
            </tr>
         </tbody></table>
      </blockquote>
      <hr size="8" noshade="noshade">
      <h2><a name="ZZRELINK"></a>ZZRELINK <font size="2">[written by J. Scullion, located in SYSC.LINKLIB]</font></h2>
      <p>Used to re-link-edit one or more existing load modules.&nbsp; ZZRELINK
         was written by J. Scullion and has been updated by Gerhard Postpischil.&nbsp;
         The source may be found on CBT Tape File #860 (original in #316).&nbsp; ZZRELINK
         requires the following DD statements:
      </p>
      <ul>
         <li>SYSPRINT - defines a sequential output message dataset.</li>
         <li>SYSPUNCH - (optional, required to produce JCL for Link Editor job) defines
            a sequential output dataset.
         </li>
         <li>SYSLOUT - (optional, required when Link Editor invoked directly) defines a
            sequential output dataset.
         </li>
         <li>SYSUT1 - work dataset</li>
         <li>SYSUT2 - work dataset</li>
         <li>SYSUT3 - work dataset</li>
         <li>SYSIN - defines a sequential input dataset that contains ZZRELINK control
            statements.
         </li>
      </ul>
      <p><b>Note:</b>&nbsp; If SYSPUNCH is provided, the JCL is created and punched
         that will perform the re-link-edit of the modules specified for selection.&nbsp;
         If SYSPUNCH is <b>not</b> provided, the Link Editor is loaded dynamically by
         ZZRELINK and the modules specified for selection will be re-link-edited
         immediately.
      </p>
      <p>&nbsp;</p>
      <h3>Control Statements</h3>
      <blockquote>
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="9%">
                  <pre><a name="ZZRELINKlink"></a>LINK</pre>
               </td>
               <td width="91%">
                  <pre>OUTDD=ddname</pre>
               </td>
            </tr>
            <tr>
               <td width="9%">
                  <pre></pre>
               </td>
               <td width="91%">
                  <pre>,INDD={ddname | (ddname1[,ddname2]...)}</pre>
               </td>
            </tr>
         </tbody></table>
         <p>The LINK control statement specifies the DD names to be used for the target library to receive the
            re-link-edited load modules and to specify the library, or libraries, containing
            source load modules.&nbsp; The parameters are:
         </p>
         <blockquote>
            <p>OUTDD=ddname,</p>
            <blockquote>
               <p>Specifies the DD name for the output dataset.</p>
            </blockquote>
            <p>INDD={ddname | (ddname1[,ddname2]...)}</p>
            <blockquote>
               <p>Specifies one or more DD names for the input dataset(s).&nbsp; If more
                  than one ddname is specified, they must be enclosed in parentheses and
                  separated by commas.
               </p>
               <p>If a load module would duplicate one already in the 
target load
                  library, the existing load module will not be 
replaced, unless the replace option is specified.&nbsp; To replace
                  any duplicate members encountered, enclose the ddname 
for which the
                  replace option is to be used in an additional pair of 
parentheses and
                  follow the ddname with a comma followed by R:
               </p>
               <blockquote>
                  <p>INDD=(ddname1,(ddname2,R),ddname3)</p>
                  <blockquote>
                     <p>will result in any members in ddname2 that have the same name as a
                        load module already present in the target load library to replace the
                        load module already existing in the target library.
                     </p>
                  </blockquote>
               </blockquote>
            </blockquote>
         </blockquote>
         <hr color="#808080">
         <table width="50%" cellspacing="0" cellpadding="0" border="0">
            <tbody><tr>
               <td width="15%">
                  <pre><a name="ZZRELINKselect"></a>SELECT     </pre>
               </td>
               <td width="85%">
                  <pre>MEMBER={name | (name1[,name2]...) | ((name,newname)[,(name2,newname2)...)}</pre>
               </td>
            </tr>
         </tbody></table>
         <p>The SELECT control statement specifies individual members to be copied from the input dataset(s).&nbsp; If
            more than one member name is specified, they must be enclosed in parentheses
            and separated by commas.&nbsp; Multiple SELECT statements may be specified, in
            which case the subsequent statements are processed as a continuation of the
            first.&nbsp; In order to rename a member, the name must be enclosed in an
            additional set of parentheses and followed by a comma and the newname.
         </p>
         <p>If no SELECT statement is provided, <b>all</b> members of the input load
            library will be selected for re-link-edit to the target library.
         </p>
      </blockquote>
      <h3>&nbsp;</h3>
      <h3>Examples</h3>
      <blockquote>
         <table width="75%" cellspacing="1" border="1">
            <tbody><tr>
               <td width="33%">
                  <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="ZZRELINKj01"></a>Create
                     (on SYSPUNCH) JCL for job to relink a load module
               </p></td>
            </tr>
            <tr>
               <td width="33%">
                  <pre><b>//ZZRELINK JOB (001),'ZZRELINK-1',CLASS=A,MSGCLASS=X  
//ZZRELINK EXEC PGM=ZZRELINK,REGION=4096K
//SYSPRINT  DD SYSOUT=*                               
//OUTLIB    DD DISP=MOD,DSN=JAY01.RELINK.LOADLIB      
//INLIB     DD DISP=SHR,DSN=SYS2.LINKLIB              
//SYSPUNCH  DD SYSOUT=*,DCB=(BLKSIZE=80,RECFM=F)      
//SYSUT1    DD UNIT=VIO,SPACE=(80,(320,90))           
//SYSUT2    DD UNIT=VIO,SPACE=(80,(320,90))           
//SYSUT3    DD UNIT=VIO,SPACE=(80,(320,90))           
//SYSLOUT   DD SYSOUT=*                               
//SYSIN     DD  *                                     
  LINK INDD=INLIB,OUTDD=OUTLIB                        
  SELECT MEMBER=VSIOMODT                              
/*                                                    
//                                                     </b></pre>
               </td>
            </tr>
            <tr>
               <td width="33%">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="ZZRELINKj02"></a>Re-link-edit
                  all members of a load library to a new library
               </td>
            </tr>
            <tr>
               <td width="33%">
                  <pre><b>//ZZRELINK JOB (001),'ZZRELINK-2',CLASS=A,MSGCLASS=X  
//ZZRELINK EXEC PGM=ZZRELINK,REGION=4096K
//SYSPRINT  DD SYSOUT=*                               
//OUTLIB    DD DISP=(,CATLG),DSN=HMVS02.LOAD      
//INLIB     DD DISP=SHR,DSN=HMVS01.LOAD              
//SYSUT1    DD UNIT=VIO,SPACE=(80,(320,90))           
//SYSUT2    DD UNIT=VIO,SPACE=(80,(320,90))           
//SYSUT3    DD UNIT=VIO,SPACE=(80,(320,90))           
//SYSLOUT   DD SYSOUT=*                               
//SYSIN     DD  *                                     
  LINK INDD=INLIB,OUTDD=OUTLIB                        
/*                                                    
//</b></pre>
               </td>
            </tr>
            <tr>
               <td width="33%">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="ZZRELINKj03"></a>Re-link-edit
                  a load module, renaming it into the input library
               </td>
            </tr>
            <tr>
               <td width="33%">
                  <pre><b>//ZZRELINK JOB (001),'ZZRELINK-3',CLASS=A,MSGCLASS=X    
//ZZRELINK EXEC PGM=ZZRELINK,REGION=4096K               
//SYSPRINT  DD SYSOUT=*                                 
//OUTLIB    DD DISP=MOD,DSN=HMVS01           <font color="#0000FF">&lt;- target and
</font>//INLIB     DD DISP=SHR,DSN=HMVS01           <font color="#0000FF">&lt;- source library the same</font>
//SYSUT1    DD UNIT=VIO,SPACE=(80,(320,90))             
//SYSUT2    DD UNIT=VIO,SPACE=(80,(320,90))             
//SYSUT3    DD UNIT=VIO,SPACE=(80,(320,90))             
//SYSLOUT   DD SYSOUT=*                                 
//SYSIN     DD  *                                       
  LINK INDD=INLIB,OUTDD=OUTLIB                          
  SELECT MEMBER=((VSIOMODX,VSIOMODT))                   
/*                                                      
//                                                      </b></pre>
               </td>
            </tr>
            <tr>
               <td width="33%">
                  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a name="ZZRELINKj04"></a>Re-link-edit
                  a group of modules to a new library, replacing duplicates
               </td>
            </tr>
            <tr>
               <td width="33%">
                  <pre><b>//ZZRELINK JOB (001),'ZZRELINK-4',CLASS=A,MSGCLASS=X    
//ZZRELINK EXEC PGM=ZZRELINK,REGION=4096K               
//SYSPRINT  DD SYSOUT=*                                 
//OUTLIB    DD DISP=MOD,DSN=HMVS02        
//INLIB     DD DISP=SHR,DSN=SYS2.LINKLIB        
//SYSUT1    DD UNIT=VIO,SPACE=(80,(320,90))             
//SYSUT2    DD UNIT=VIO,SPACE=(80,(320,90))             
//SYSUT3    DD UNIT=VIO,SPACE=(80,(320,90))             
//SYSLOUT   DD SYSOUT=*                                 
//SYSIN     DD  *                                       
  LINK INDD=(INLIB,R),OUTDD=OUTLIB                          
  SELECT MEMBER=(UPDMAIN,UPDTSUB1,UPDTSUB2)
  SELECT MEMBER=(UPDSUB3,UPDTSUB4,UPDTSUB5)
/*                                                      
//</b></pre>
               </td>
            </tr>
         </tbody></table>
      </blockquote>
      <hr size="8" noshade="noshade">
      <hr>
      <p><img src="moseley.index_files/dinomail.gif" width="275" height="116" border="0"></p>
      <hr>
      <p align="center"><input type="BUTTON" value="Back to Previous Page" onclick="history.go(-1)"><a href="http://www.jaymoseley.com/hercules/index.html" class="button">Return
         to Site Home Page</a>&nbsp;
      </p>
      <hr>
      <p>
         This page was last updated on <!--webbot bot="Timestamp"
            s-type="EDITED" s-format="%B %d, %Y" startspan -->February 07, 2022<!--webbot bot="Timestamp" i-CheckSum="41670" endspan -->.
      </p>
   
</body></html>                                               